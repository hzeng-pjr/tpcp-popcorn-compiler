diff --git a/.gitignore b/.gitignore
index 07d4a129e5..c659e59921 100644
--- a/.gitignore
+++ b/.gitignore
@@ -44,3 +44,5 @@ core
 /linuxthreads_db
 /rtkaio
 *.pyc
+
+.vscode
\ No newline at end of file
diff --git a/Makeconfig b/Makeconfig
index f252842979..3c30ee3bea 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -358,7 +358,7 @@ real-static-start-installed-name = $(static-start-installed-name)
 endif
 
 ifeq (yesyes,$(build-shared)$(have-z-combreloc))
-combreloc-LDFLAGS = -Wl,-z,combreloc
+combreloc-LDFLAGS = -Wl,-z,combreloc -Wl,--allow-shlib-undefined
 LDFLAGS.so += $(combreloc-LDFLAGS)
 LDFLAGS-rtld += $(combreloc-LDFLAGS)
 endif
@@ -1272,7 +1272,7 @@ all-subdirs = csu assert ctype locale intl catgets math setjmp signal	    \
 	      grp pwd posix io termios resource misc socket sysvipc gmon    \
 	      gnulib iconv iconvdata wctype manual shadow gshadow po argp   \
 	      localedata timezone rt conform debug mathvec support	    \
-	      dlfcn elf
+	      dlfcn elf remote_io
 
 ifeq ($(build-crypt),yes)
 all-subdirs += crypt
diff --git a/Makerules b/Makerules
index 1e9c18f0d8..eeb1854103 100644
--- a/Makerules
+++ b/Makerules
@@ -538,7 +538,7 @@ lib%.so: lib%_pic.a $(+preinit) $(+postinit) $(link-libc-deps)
 
 define build-shlib-helper
 $(LINK.o) -shared -static-libgcc -Wl,-O1 $(sysdep-LDFLAGS) \
-	  $(if $($(@F)-no-z-defs)$(no-z-defs),,-Wl,-z,defs) $(rtld-LDFLAGS) \
+	  $(if $($(@F)-no-z-defs)$(no-z-defs),,) $(rtld-LDFLAGS) \
 	  $(extra-B-$(@F:lib%.so=%).so) -B$(csu-objpfx) \
 	  $(extra-B-$(@F:lib%.so=%).so) $(load-map-file) \
 	  -Wl,-soname=lib$(libprefix)$(@F:lib%.so=%).so$($(@F)-version) \
@@ -597,7 +597,7 @@ endef
 
 define build-module-helper
 $(LINK.o) -shared -static-libgcc $(sysdep-LDFLAGS) $(rtld-LDFLAGS) \
-	  $(if $($(@F)-no-z-defs)$(no-z-defs),,-Wl,-z,defs) \
+	  $(if $($(@F)-no-z-defs)$(no-z-defs),,) \
 	  -B$(csu-objpfx) $(load-map-file) \
 	  $(LDFLAGS.so) $(LDFLAGS-$(@F:%.so=%).so) \
 	  -L$(subst :, -L,$(rpath-link)) -Wl,-rpath-link=$(rpath-link)
diff --git a/csu/Versions b/csu/Versions
index 43010c3443..509cdf13e2 100644
--- a/csu/Versions
+++ b/csu/Versions
@@ -8,6 +8,6 @@ libc {
     gnu_get_libc_release; gnu_get_libc_version;
   }
   GLIBC_PRIVATE {
-    errno;
+    errno; __popcorn_stack_base;
   }
 }
diff --git a/csu/libc-start.c b/csu/libc-start.c
index 12468c5a89..0c17fee4f5 100644
--- a/csu/libc-start.c
+++ b/csu/libc-start.c
@@ -122,6 +122,13 @@ STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **
      __attribute__ ((noreturn));
 
 
+/* Store the highest stack address dedicated to function activations. */
+void *__popcorn_stack_base = NULL;
+extern void pcn_server_init (void);
+
+int __libc_start_main_popcorn (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
+			       int, char **, char **) __attribute__((weak));
+
 /* Note: the fini parameter is ignored here for shared library.  It
    is registered with __cxa_atexit.  This had the disadvantage that
    finalizers were called in more than one place.  */
@@ -138,8 +145,12 @@ LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
   /* Result of the 'main' function.  */
   int result;
 
+  __popcorn_stack_base = argv;
   __libc_multiple_libcs = &_dl_starting_up && !_dl_starting_up;
 
+  // Re-enable this after RIO supports mmap.
+  //pcn_server_init ();
+
 #ifndef SHARED
   _dl_relocate_static_pie ();
 
@@ -305,7 +316,15 @@ LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
       THREAD_SETMEM (self, cleanup_jmp_buf, &unwind_buf);
 
       /* Run the program.  */
+#ifdef SHARED
+      pcn_server_init ();
+      if (__libc_start_main_popcorn)
+	result = __libc_start_main_popcorn (main, argc, argv, __environ MAIN_AUXVEC_PARAM);
+      else
+	result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
+#else
       result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
+#endif
     }
   else
     {
diff --git a/elf/Makefile b/elf/Makefile
index f9646f9c8c..a9f180ddb0 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -21,11 +21,11 @@ subdir		:= elf
 
 include ../Makeconfig
 
-headers		= elf.h bits/elfclass.h link.h bits/link.h
+headers		= elf.h bits/elfclass.h link.h bits/link.h popcorn.h
 routines	= $(all-dl-routines) dl-support dl-iteratephdr \
 		  dl-addr dl-addr-obj enbl-secure dl-profstub \
 		  dl-origin dl-libc dl-sym dl-sysdep dl-error \
-		  dl-reloc-static-pie
+		  dl-reloc-static-pie dl-remote-io
 
 # The core dynamic linking functions are in libc for the static and
 # profiled libraries.
diff --git a/elf/Versions b/elf/Versions
index 3b09901f6c..69b52af54a 100644
--- a/elf/Versions
+++ b/elf/Versions
@@ -30,6 +30,11 @@ libc {
     # Internal error handling support.  Interposes the functions in ld.so.
     _dl_signal_exception; _dl_catch_exception;
     _dl_signal_error; _dl_catch_error;
+
+    # Popcorn Linux.
+    _dl_rio_print_dso;
+    _dl_rio_populate_dso_entries;
+    _dl_pcn_migration_entry;
   }
 }
 
@@ -78,5 +83,10 @@ ld {
 
     # Set value of a tunable.
     __tunable_get_val;
+
+    # Popcorn Linux.
+    _dl_rio_print_dso;
+    _dl_rio_populate_dso_entries;
+    _dl_pcn_migration_entry;
   }
 }
diff --git a/elf/dl-init.c b/elf/dl-init.c
index 55d528c7a5..3b7ad2190f 100644
--- a/elf/dl-init.c
+++ b/elf/dl-init.c
@@ -18,6 +18,7 @@
 
 #include <stddef.h>
 #include <ldsodefs.h>
+#include "dl-popcorn.h"
 
 
 /* Type of the initializer.  */
@@ -80,6 +81,13 @@ _dl_init (struct link_map *main_map, int argc, char **argv, char **env)
   ElfW(Dyn) *preinit_array = main_map->l_info[DT_PREINIT_ARRAY];
   ElfW(Dyn) *preinit_array_size = main_map->l_info[DT_PREINIT_ARRAYSZ];
   unsigned int i;
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
+
+  argc = pcn_data->argc;
+  argv = pcn_data->argv;
+  env = pcn_data->envp;
+
+  //_dl_debug_printf ("%s: tp = %lx\n", __FUNCTION__, GET_TP);
 
   if (__glibc_unlikely (GL(dl_initfirst) != NULL))
     {
diff --git a/elf/dl-lookup.c b/elf/dl-lookup.c
index 378f28fa7d..72c7f3b583 100644
--- a/elf/dl-lookup.c
+++ b/elf/dl-lookup.c
@@ -965,6 +965,7 @@ _dl_setup_hash (struct link_map *map)
     {
       Elf32_Word *hash32
 	= (void *) D_PTR (map, l_info[ELF_MACHINE_GNU_HASH_ADDRIDX]);
+      // _dl_debug_printf ("%s: hash32 = %lx, ", __FUNCTION__, hash32);
       map->l_nbuckets = *hash32++;
       Elf32_Word symbias = *hash32++;
       Elf32_Word bitmask_nwords = *hash32++;
diff --git a/elf/dl-map-segments.h b/elf/dl-map-segments.h
index ac9f09ab4c..5d8b53c795 100644
--- a/elf/dl-map-segments.h
+++ b/elf/dl-map-segments.h
@@ -17,6 +17,8 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <dl-load.h>
+#include <sysdep-cancel.h>
+#include "dl-popcorn.h"
 
 /* This implementation assumes (as does the corresponding implementation
    of _dl_unmap_segments, in dl-unmap-segments.h) that shared objects
@@ -33,6 +35,9 @@ _dl_map_segments (struct link_map *l, int fd,
                   struct link_map *loader)
 {
   const struct loadcmd *c = loadcmds;
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
+  unsigned int flags = MAP_COPY | MAP_FILE;
+  int i;
 
   if (__glibc_likely (type == ET_DYN))
     {
@@ -52,10 +57,25 @@ _dl_map_segments (struct link_map *l, int fd,
                                   c->mapstart & GLRO(dl_use_load_bias))
            - MAP_BASE_ADDR (l));
 
+      if (pcn_data->num_maps > 0)
+	{
+	  for (i = 0; i < pcn_data->num_maps; i++)
+	    if (strcmp (l->l_name, pcn_data->maps[i].name) == 0) {
+	      mappref = pcn_data->maps[i].start;
+	      flags = MAP_PRIVATE | MAP_FIXED;
+//	      _dl_debug_printf ("previous mapping for %s found at %x\n",
+//				l->l_name, mappref);
+	    }
+	}
+
+//      _dl_debug_printf ("mmap (%x, %u, %u, %u, %u, %u)\n",
+//			mappref, maplength, c->prot, flags, fd,
+//			c->mapoff);
+
       /* Remember which part of the address space this object uses.  */
-      l->l_map_start = (ElfW(Addr)) __mmap ((void *) mappref, maplength,
+      l->l_map_start = (ElfW(Addr)) SYSCALL_CANCEL (mmap, (void *) mappref, maplength,
                                             c->prot,
-                                            MAP_COPY|MAP_FILE,
+                                            flags,
                                             fd, c->mapoff);
       if (__glibc_unlikely ((void *) l->l_map_start == MAP_FAILED))
         return DL_MAP_SEGMENTS_ERROR_MAP_SEGMENT;
diff --git a/elf/dl-minimal.c b/elf/dl-minimal.c
index 42192f8a7b..b65ed6c47b 100644
--- a/elf/dl-minimal.c
+++ b/elf/dl-minimal.c
@@ -67,6 +67,7 @@ malloc (size_t n)
 	 page to reduce number of mmap calls.  */
       caddr_t page;
       size_t nup = (n + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
+      struct link_map *l = &GL (dl_rtld_map);
       if (__glibc_unlikely (nup == 0 && n != 0))
 	return NULL;
       nup += GLRO(dl_pagesize);
@@ -77,6 +78,8 @@ malloc (size_t n)
       if (page != alloc_end)
 	alloc_ptr = page;
       alloc_end = page + nup;
+      l->l_alloc_ptr = page;
+      l->l_alloc_end = nup;
     }
 
   alloc_last_block = (void *) alloc_ptr;
diff --git a/elf/dl-misc.c b/elf/dl-misc.c
index e6cf247b46..328e140141 100644
--- a/elf/dl-misc.c
+++ b/elf/dl-misc.c
@@ -35,6 +35,10 @@
 #include <dl-writev.h>
 #include <not-cancel.h>
 
+#if defined(__x86_64__) || defined(__aarch64__)
+#define NEED_L
+#endif
+
 /* Read the whole contents of FILE into new mmap'd space with given
    protections.  *SIZEP gets the size of the file.  On error MAP_FAILED
    is returned.  */
@@ -127,7 +131,7 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
 	  char fill = ' ';
 	  int width = -1;
 	  int prec = -1;
-#if LONG_MAX != INT_MAX
+#ifdef NEED_L
 	  int long_mod = 0;
 #endif
 
@@ -158,7 +162,7 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
 	     can use the same code for size_t.  */
 	  if (*fmt == 'l' || *fmt == 'Z')
 	    {
-#if LONG_MAX != INT_MAX
+#ifdef NEED_L
 	      long_mod = 1;
 #endif
 	      ++fmt;
@@ -172,7 +176,7 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
 	      {
 		/* We have to make a difference if long and int have a
 		   different size.  */
-#if LONG_MAX != INT_MAX
+#ifdef NEED_L
 		unsigned long int num = (long_mod
 					 ? va_arg (arg, unsigned long int)
 					 : va_arg (arg, unsigned int));
diff --git a/elf/dl-popcorn.h b/elf/dl-popcorn.h
new file mode 100644
index 0000000000..8d3ae1ac6d
--- /dev/null
+++ b/elf/dl-popcorn.h
@@ -0,0 +1,19 @@
+#ifndef DL_POPCORN_H
+#define DL_POPCORN_H
+
+#include "popcorn.h"
+
+static inline void pcn_break (void)
+{
+  struct dl_pcn_data *data = (void *) DL_PCN_STATE;
+
+#ifdef __x86_64__
+  if (data->pcn_break)
+    asm volatile ("int3;");
+#else
+  if (data->pcn_break)
+    ;
+#endif
+}
+
+#endif
diff --git a/elf/dl-remote-io.c b/elf/dl-remote-io.c
new file mode 100644
index 0000000000..fe3d9f5ecd
--- /dev/null
+++ b/elf/dl-remote-io.c
@@ -0,0 +1,125 @@
+/* Run time dynamic linker interface with the remote_io subsystem.  */
+
+#include <ldsodefs.h>
+#include <link.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "dl-popcorn.h"
+
+#include <nptl/descr.h>
+#include <tls.h>
+
+unsigned long _dl_pcn_stack_init;
+unsigned long _dl_pcn_migration_entry __attribute__ ((weak));
+
+static unsigned long
+round_down (unsigned long a, unsigned long b)
+{
+  return a / b * b;
+}
+
+unsigned long
+round_up (unsigned long a, unsigned long b)
+{
+  return (a + b - 1) / b * b;
+}
+
+struct link_map *
+dl_rio_get_rtld_global (void)
+{
+  /* The rtld_global object is defined in rtld.c. But it is accessible
+     by the GL macros defined in <sysdeps/generic/ldsodefs.h>.  */
+
+  return &GL (dl_rtld_map);
+}
+
+static void
+dump_file (struct link_map *map)
+{
+  unsigned long start, size;
+  int i;
+
+  printf ("%s (%lx-%lx)\n", map->l_name, map->l_map_start, map->l_map_end);
+
+  for (i = 0; i < map->l_phnum; i++)
+    {
+      if (map->l_phdr[i].p_type != PT_LOAD)
+	continue;
+
+      start = round_down (map->l_phdr[i].p_vaddr + map->l_addr, PCN_PAGE_SIZE);
+      size = map->l_phdr[i].p_memsz;
+      printf ("  %lx -> %lx\n", start, start+size);
+    }
+}
+
+void
+_dl_rio_print_dso (void)
+{
+  struct link_map *l;
+
+  for (l = &GL (dl_rtld_map); l != NULL; l = l->l_prev)
+    {
+      if (l->l_name[0] == '\0')
+	continue;
+      if (strcmp (l->l_name, "linux-vdso.so.1") == 0)
+	continue;
+
+      dump_file (l);
+    }
+}
+
+int
+count_map_entries (struct link_map *map)
+{
+  int cnt = 0;
+
+  for (; map; map = map->l_prev)
+    {
+      if (map->l_name[0] == '\0')
+	continue;
+      if (strcmp (map->l_name, "linux-vdso.so.1") == 0)
+	continue;
+      cnt++;
+    }
+
+  return cnt;
+}
+
+void
+_dl_rio_populate_dso_entries (void)
+{
+  struct link_map *l = &GL (dl_rtld_map), *map;
+  int i, j;
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
+
+  //printf ("sizeof (struct pthread) = %u\n", sizeof (struct pthread));
+  //printf ("sizeof (tcbhead_t) = %u\n", sizeof (tcbhead_t));
+
+  if (pcn_data->num_maps != 0)
+    {
+      for (i = 0; i < pcn_data->num_maps; i++)
+	free (pcn_data->maps[i].name);
+    }
+
+  for (map = l, j = 0; map; map = map->l_prev)
+    {
+      if (map->l_name[0] == '\0')
+	continue;
+      if (strcmp (map->l_name, "linux-vdso.so.1") == 0)
+	continue;
+
+      pcn_data->maps[j].name = strdup (map->l_name);
+      pcn_data->maps[j].start = map->l_map_start;
+      pcn_data->maps[j].size = map->l_map_end - map->l_map_start;
+
+      j++;
+    }
+
+  pcn_data->maps[j].name = strdup ("dl-malloc");
+  pcn_data->maps[j].start = l->l_alloc_ptr;
+  pcn_data->maps[j].size = l->l_alloc_end;
+  j++;
+
+  pcn_data->num_maps = j;
+}
diff --git a/elf/dl-sysdep.c b/elf/dl-sysdep.c
index 854570821c..3293b45bc2 100644
--- a/elf/dl-sysdep.c
+++ b/elf/dl-sysdep.c
@@ -47,6 +47,8 @@
 #include <dl-tunables.h>
 #include <dl-auxv.h>
 
+#include "popcorn.h"
+
 extern char **_environ attribute_hidden;
 extern char _end[] attribute_hidden;
 
@@ -117,14 +119,22 @@ _dl_sysdep_start (void **start_argptr,
   user_entry = (ElfW(Addr)) ENTRY_POINT;
   GLRO(dl_platform) = NULL; /* Default to nothing known about the platform.  */
 
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
+
   for (av = GLRO(dl_auxv); av->a_type != AT_NULL; set_seen (av++))
     switch (av->a_type)
       {
       case AT_PHDR:
-	phdr = (void *) av->a_un.a_val;
+	if (pcn_data->phdrs)
+	  phdr = pcn_data->phdrs;
+	else
+	  phdr = (void *) av->a_un.a_val;
 	break;
       case AT_PHNUM:
-	phnum = av->a_un.a_val;
+	if (pcn_data->phdrs)
+	  phnum = pcn_data->phnum;
+	else
+	  phnum = av->a_un.a_val;
 	break;
       case AT_PAGESZ:
 	GLRO(dl_pagesize) = av->a_un.a_val;
diff --git a/elf/dl-tls.c b/elf/dl-tls.c
index fa03234610..bba47234a2 100644
--- a/elf/dl-tls.c
+++ b/elf/dl-tls.c
@@ -24,10 +24,16 @@
 #include <unistd.h>
 #include <sys/param.h>
 #include <atomic.h>
+#include <sysdep-cancel.h>
 
 #include <tls.h>
 #include <dl-tls.h>
 #include <ldsodefs.h>
+#include "dl-popcorn.h"
+
+#ifndef TLS_TCB_PCN_PAD
+#define TLS_TCB_PCN_PAD 0x0
+#endif
 
 /* Amount of excess space to allocate in the static TLS area
    to allow dynamic loading of modules defining IE-model TLS data.  */
@@ -222,7 +228,7 @@ _dl_determine_tlsoffset (void)
 			    + TLS_TCB_SIZE);
 #elif TLS_DTV_AT_TP
   /* The TLS blocks start right after the TCB.  */
-  size_t offset = TLS_TCB_SIZE;
+  size_t offset = TLS_TCB_SIZE + TLS_TCB_PCN_PAD;
 
   for (size_t cnt = 0; slotinfo[cnt].map != NULL; ++cnt)
     {
@@ -298,6 +304,9 @@ allocate_dtv (void *result)
   else
     result = NULL;
 
+//  _dl_debug_printf ("%s: dtv = %lx @ %u bytes, tcbp = %lx\n", __FUNCTION__, dtv,
+//		    dtv_length + 2 * sizeof (dtv_t), result);
+
   return result;
 }
 
@@ -327,23 +336,53 @@ tcb_to_pointer_to_free_location (void *tcb)
   return original_pointer_location;
 }
 
+/* This function needs to consider multiple threads eventually.  */
+static void
+*pcn_alloc_static_tls (size_t size)
+{
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
+  void *data;
+
+  if (pcn_data->tls_static_block != NULL)
+    return pcn_data->tls_static_block;
+
+  size += PCN_PAGE_SIZE - 1;
+  size &= ~(PCN_PAGE_SIZE - 1);
+
+  data = (void *) SYSCALL_CANCEL (mmap, (void *)DL_PCN_STATE + pcn_data->pcn_data_size, size,
+		  PROT_READ | PROT_WRITE,
+		  MAP_PRIVATE | MAP_FIXED_NOREPLACE | MAP_ANONYMOUS, 0, 0);
+  pcn_data->tls_static_block = data;
+  pcn_data->pcn_data_size += size;
+  pcn_data->tls_init = -1;
+
+//  _dl_debug_printf ("%s: allocated %u bytes of TLS @ %lx\n", __FUNCTION__,
+//		    size, data);
+
+  return data;
+}
+
 void *
 _dl_allocate_tls_storage (void)
 {
   void *result;
   size_t size = GL(dl_tls_static_size);
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
+
+//  _dl_debug_printf ("%s: allocating static TLS block\n", __FUNCTION__);
 
 #if TLS_DTV_AT_TP
   /* Memory layout is:
      [ TLS_PRE_TCB_SIZE ] [ TLS_TCB_SIZE ] [ TLS blocks ]
 			  ^ This should be returned.  */
-  size += TLS_PRE_TCB_SIZE;
+  size += TLS_PRE_TCB_SIZE + TLS_TCB_PCN_PAD;
 #endif
 
   /* Perform the allocation.  Reserve space for the required alignment
      and the pointer to the original allocation.  */
   size_t alignment = GL(dl_tls_static_align);
-  void *allocated = malloc (size + alignment + sizeof (void *));
+  ///void *allocated = malloc (size + alignment + sizeof (void *));
+  void *allocated = pcn_alloc_static_tls (size + alignment + sizeof (void *));
   if (__glibc_unlikely (allocated == NULL))
     return NULL;
 
@@ -371,7 +410,12 @@ _dl_allocate_tls_storage (void)
   /* Clear the TCB data structure and TLS_PRE_TCB_SIZE bytes before
      it.  We can't ask the caller (i.e. libpthread) to do it, because
      we will initialize the DTV et al.  */
-  memset (result - TLS_PRE_TCB_SIZE, '\0', TLS_PRE_TCB_SIZE + TLS_TCB_SIZE);
+  if (pcn_data->tls_init < 0)
+    {
+      //_dl_debug_printf ("%s: initializing static TLS block\n", __FUNCTION__);
+      memset (result - TLS_PRE_TCB_SIZE, '\0', TLS_PRE_TCB_SIZE + TLS_TCB_SIZE);
+      pcn_data->tls_init = 0;
+    }
 #endif
 
   /* Record the value of the original pointer for later
@@ -443,6 +487,7 @@ _dl_allocate_tls_init (void *result)
   struct dtv_slotinfo_list *listp;
   size_t total = 0;
   size_t maxgen = 0;
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
 
   /* Check if the current dtv is big enough.   */
   if (dtv[-1].counter < GL(dl_tls_max_dtv_idx))
@@ -504,6 +549,25 @@ _dl_allocate_tls_init (void *result)
 	  dtv[map->l_tls_modid].pointer.val = dest;
 
 	  /* Copy the initialization image and clear the BSS part.  */
+
+//	  _dl_debug_printf ("%s: reserving tls for %s\n", __FUNCTION__,
+//			    map->l_name);
+
+	  /* Don't reinitialize TLS data for the main executable after
+	     reloading ld-linux.  */
+	  if (map->l_name[0] == '\0' && pcn_data->tls_init == 0)
+	    {
+//	      _dl_debug_printf ("%s: initializing TLS module 1\n",
+//				__FUNCTION__);
+	      pcn_data->tls_init = 1;
+	    }
+	  else if (map->l_name[0] == '\0' && pcn_data->tls_init > 0)
+	    {
+//	      _dl_debug_printf ("%s: skipping TLS module 1\n",
+//				__FUNCTION__);
+	      continue;
+	    }
+
 	  memset (__mempcpy (dest, map->l_tls_initimage,
 			     map->l_tls_initimage_size), '\0',
 		  map->l_tls_blocksize - map->l_tls_initimage_size);
diff --git a/elf/get-dynamic-info.h b/elf/get-dynamic-info.h
index 4f6a86ef37..92451da488 100644
--- a/elf/get-dynamic-info.h
+++ b/elf/get-dynamic-info.h
@@ -44,6 +44,7 @@ elf_get_dynamic_info (struct link_map *l, ElfW(Dyn) *temp)
 #endif
 
   info = l->l_info;
+  //_dl_debug_printf ("%s: dyn = %lx\n", __FUNCTION__, dyn);
 
   while (dyn->d_tag != DT_NULL)
     {
diff --git a/elf/popcorn.h b/elf/popcorn.h
new file mode 100644
index 0000000000..7f75f0f23e
--- /dev/null
+++ b/elf/popcorn.h
@@ -0,0 +1,59 @@
+#ifndef POPCORN_H
+#define POPCORN_H
+
+#define DL_PCN_STATE 0x700000000000
+#define PCN_PAGE_SIZE 0x1000
+#define PCN_HETEROGENEOUS 1
+#define PCN_FILENAME 64
+
+#define PCN_NSIG 64
+
+struct pcn_sig {
+  void *pcn_sa_handler;
+  unsigned long pcn_sa_mask;
+  int pcn_sa_flags;
+};
+
+struct mmap_entries {
+  char *name;
+  unsigned long start, size;
+};
+
+struct dl_pcn_data {
+  unsigned long pcn_entry;
+  int pcn_break;
+  void *arg;
+  int argc;
+  char **argv;
+  char **envp;
+  char filename[64];
+  void *thread_pointer;
+  void *tls_static_block;
+  int tls_init;
+  void *phdrs;
+  int phnum;
+  int pcn_data_size;
+  int num_maps;
+
+  int pcn_remote_io_active;
+  unsigned int pcn_server_ip;
+  unsigned short pcn_server_port;
+  int pcn_server_sockfd;
+  int pcn_client_sockfd;
+  unsigned int pcn_local_ip;
+
+  int rio_migrate_pending;
+  int rio_child_pid;
+
+  int rio_debug;
+
+  unsigned long rio_sa_active;
+  struct pcn_sig rio_sa_sigs[PCN_NSIG];
+
+  struct mmap_entries maps[];
+};
+
+extern void _dl_rio_print_dso (void);
+extern void _dl_rio_populate_dso_entries (void);
+
+#endif
diff --git a/elf/rtld.c b/elf/rtld.c
index 553cfbd1b7..bf9aa0f447 100644
--- a/elf/rtld.c
+++ b/elf/rtld.c
@@ -45,6 +45,8 @@
 #include <stap-probe.h>
 #include <stackinfo.h>
 #include <not-cancel.h>
+#include <sysdep-cancel.h>
+#include "dl-popcorn.h"
 
 #include <assert.h>
 
@@ -468,6 +470,8 @@ _dl_start (void *arg)
 # define bootstrap_map info.l
 #endif
 
+  struct dl_pcn_data *pcn_data;
+
   /* This #define produces dynamic linking inline functions for
      bootstrap relocation instead of general-purpose relocation.
      Since ld.so must not have any undefined symbols the result
@@ -500,8 +504,28 @@ _dl_start (void *arg)
 # endif
 #endif
 
+  pcn_data = (struct dl_pcn_data *)SYSCALL_CANCEL (mmap, (void *)DL_PCN_STATE, PCN_PAGE_SIZE,
+		      PROT_READ | PROT_WRITE,
+		      MAP_PRIVATE | MAP_FIXED_NOREPLACE | MAP_ANONYMOUS, 0, 0);
+
+  if (pcn_data == MAP_FAILED || pcn_data == (void *) -EEXIST)
+    pcn_data = (void *) DL_PCN_STATE;
+
+  if (pcn_data->arg == NULL)
+    {
+      pcn_data->arg = arg;
+      pcn_data->pcn_data_size = PCN_PAGE_SIZE;
+      pcn_data->rio_child_pid = -1;
+      pcn_data->rio_debug = 1;
+    }
+  else
+    arg = pcn_data->arg;
+
+  //pcn_break ();
+
   /* Figure out the run-time load address of the dynamic linker itself.  */
   bootstrap_map.l_addr = elf_machine_load_address ();
+  //_dl_debug_printf ("bootstrap_map.l_addr = %lx\n", bootstrap_map.l_addr);
 
   /* Read our own dynamic section and fill in the info array.  */
   bootstrap_map.l_ld = (void *) bootstrap_map.l_addr + elf_machine_dynamic ();
@@ -697,6 +721,8 @@ static bool tls_init_tp_called;
 static void *
 init_tls (void)
 {
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
+
   /* Number of elements in the static TLS block.  */
   GL(dl_tls_static_nelem) = GL(dl_tls_max_dtv_idx);
 
@@ -717,6 +743,11 @@ init_tls (void)
   /* No need to check the return value.  If memory allocation failed
      the program would have been terminated.  */
 
+//  _dl_debug_printf ("%s: dl_tls_dtv_slotinfo_list = %lx @ %u bytes\n",
+//		    __FUNCTION__, GL(dl_tls_dtv_slotinfo_list),
+//		    sizeof (struct dtv_slotinfo_list)
+//		    + nelem * sizeof (struct dtv_slotinfo));
+
   struct dtv_slotinfo *slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;
   GL(dl_tls_dtv_slotinfo_list)->len = nelem;
   GL(dl_tls_dtv_slotinfo_list)->next = NULL;
@@ -760,6 +791,13 @@ cannot allocate TLS data structures for initial thread\n");
     _dl_fatal_printf ("cannot set up thread-local storage: %s\n", lossage);
   tls_init_tp_called = true;
 
+  pcn_data->thread_pointer = tcbp;
+
+//  _dl_debug_printf ("%s: tcbp = %lx (%lx), DTV = %lx, TP = %lx\n",
+//		    __FUNCTION__, tcbp, THREAD_DTV(), GET_DTV (tcbp), GET_TP);
+//  _dl_debug_printf ("%s: SINGLE_THREAD_P = %u\n", __FUNCTION__,
+//		    SINGLE_THREAD_P);
+
   return tcbp;
 }
 
@@ -1098,6 +1136,7 @@ dl_main (const ElfW(Phdr) *phdr,
   bool prelinked = false;
   bool rtld_is_main = false;
   void *tcbp = NULL;
+  struct dl_pcn_data *pcn_data = (void *) DL_PCN_STATE;
 
   GL(dl_init_static_tls) = &_dl_nothread_init_static_tls;
 
@@ -1119,6 +1158,17 @@ dl_main (const ElfW(Phdr) *phdr,
   _dl_starting_up = 1;
 #endif
 
+  if (pcn_data->pcn_entry)
+    *user_entry = pcn_data->pcn_entry;
+
+  /*
+  _dl_debug_printf ("phdr = 0x%x, phnum = %u, user_entry = 0x%x, auxv = 0x%x\n",
+		    phdr, phnum, *user_entry, auxv);
+  _dl_debug_printf ("pcn_data: arg = 0x%x, entry = 0x%x, break = %u\n",
+		    pcn_data->arg, pcn_data->pcn_entry,
+		    pcn_data->pcn_break);
+  */
+
   if (*user_entry == (ElfW(Addr)) ENTRY_POINT)
     {
       /* Ho ho.  We are not the program interpreter!  We are the program
@@ -1503,7 +1553,7 @@ ERROR: '%s': cannot process note segment.\n", _dl_argv[0]);
 		      + GL(dl_rtld_map).l_info[DT_SONAME]->d_un.d_ptr);
       newname.next = NULL;
       newname.dont_free = 1;
-
+      //_dl_debug_printf ("%s: newname = %s\n", __FUNCTION__, newname.name);
       assert (GL(dl_rtld_map).l_libname->next == NULL);
       GL(dl_rtld_map).l_libname->next = &newname;
     }
@@ -1538,10 +1588,10 @@ ERROR: '%s': cannot process note segment.\n", _dl_argv[0]);
   struct link_map **first_preload = &GL(dl_rtld_map).l_next;
   /* Set up the data structures for the system-supplied DSO early,
      so they can influence _dl_init_paths.  */
-  setup_vdso (main_map, &first_preload);
+  //setup_vdso (main_map, &first_preload);
 
   /* With vDSO setup we can initialize the function pointers.  */
-  setup_vdso_pointers ();
+  //setup_vdso_pointers ();
 
 #ifdef DL_SYSDEP_OSCHECK
   DL_SYSDEP_OSCHECK (_dl_fatal_printf);
@@ -2360,6 +2410,26 @@ ERROR: '%s': cannot process note segment.\n", _dl_argv[0]);
   _dl_unload_cache ();
 #endif
 
+  if (pcn_data->argv == NULL)
+    {
+      int len = strlen (_dl_argv[0]) + 1;
+
+      pcn_data->argc = _dl_argc;
+      pcn_data->argv = _dl_argv;
+      pcn_data->envp = environ;
+
+      assert (len < PCN_FILENAME);
+
+      memcpy (pcn_data->filename, _dl_argv[0], len);
+    }
+
+//  {
+//    void *tp = GET_TP;
+//    void *self = THREAD_SELF;
+//    _dl_debug_printf ("%s: tp = %lx, thread_self = %lx, sizeof (pthread) = %u\n",
+//		      __FUNCTION__, tp, self, sizeof (struct pthread));
+//  }
+
   /* Once we return, _dl_sysdep_start will invoke
      the DT_INIT functions and then *USER_ENTRY.  */
 }
diff --git a/include/link.h b/include/link.h
index aea268439c..6391d9af8e 100644
--- a/include/link.h
+++ b/include/link.h
@@ -245,6 +245,9 @@ struct link_map
     /* End of the executable part of the mapping.  */
     ElfW(Addr) l_text_end;
 
+    /* Keep track of mmap allocations.  */
+    ElfW(Addr) l_alloc_ptr, l_alloc_end;
+
     /* Default array for 'l_scope'.  */
     struct r_scope_elem *l_scope_mem[4];
     /* Size of array allocated for 'l_scope'.  */
diff --git a/include/sys/epoll.h b/include/sys/epoll.h
index 86e0a54e62..c517271dae 100644
--- a/include/sys/epoll.h
+++ b/include/sys/epoll.h
@@ -1,6 +1,10 @@
 #ifndef _SYS_EPOLL_H
 #include_next <sys/epoll.h>
 
+libc_hidden_proto (epoll_create)
+libc_hidden_proto (epoll_ctl)
+libc_hidden_proto (epoll_wait)
+
 # ifndef _ISOMAC
 
 libc_hidden_proto (epoll_pwait)
diff --git a/include/sys/stat.h b/include/sys/stat.h
index b82d452780..7a108df9e3 100644
--- a/include/sys/stat.h
+++ b/include/sys/stat.h
@@ -14,6 +14,8 @@ extern int __mkdir (const char *__path, __mode_t __mode);
 libc_hidden_proto (__mkdir)
 extern int __mknod (const char *__path,
 		    __mode_t __mode, __dev_t __dev);
+extern int __do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag);
+
 #if IS_IN (libc) || (IS_IN (rtld) && !defined NO_RTLD_HIDDEN)
 hidden_proto (__fxstat)
 hidden_proto (__fxstat64)
@@ -21,6 +23,7 @@ hidden_proto (__lxstat)
 hidden_proto (__lxstat64)
 hidden_proto (__xstat)
 hidden_proto (__xstat64)
+hidden_proto (__do_fxstatat)
 #endif
 extern __inline__ int __stat (const char *__path, struct stat *__statbuf)
 {
diff --git a/io/Makefile b/io/Makefile
index d9a1da4566..ab5d367e5f 100644
--- a/io/Makefile
+++ b/io/Makefile
@@ -33,7 +33,7 @@ routines :=								\
 	utime								\
 	mkfifo mkfifoat							\
 	stat fstat lstat stat64 fstat64 lstat64 fstatat fstatat64	\
-	xstat fxstat lxstat xstat64 fxstat64 lxstat64 statx		\
+	xstat fxstat lxstat xstat64 fxstat64 lxstat64 statx do_fxstatat \
 	mknod mknodat xmknod xmknodat					\
 	fxstatat fxstatat64						\
 	statfs fstatfs statfs64 fstatfs64				\
@@ -55,7 +55,7 @@ routines :=								\
 	posix_fadvise posix_fadvise64					\
 	posix_fallocate posix_fallocate64				\
 	sendfile sendfile64 copy_file_range 				\
-	utimensat futimens
+	utimensat futimens						\
 
 # These routines will be omitted from the libc shared object.
 # Instead the static object files will be included in a special archive
diff --git a/io/Versions b/io/Versions
index f7e5dbe49e..8702710c20 100644
--- a/io/Versions
+++ b/io/Versions
@@ -132,6 +132,14 @@ libc {
     fcntl64;
     statx;
   }
+  GLIBC_2.31 {
+    epoll_create;
+    epoll_ctl;
+    epoll_wait;
+    __epoll_create;
+    __epoll_ctl;
+    __epoll_wait;
+  }
   GLIBC_PRIVATE {
     __libc_fcntl64;
     __fcntl_nocancel;
diff --git a/io/do_fxstatat.c b/io/do_fxstatat.c
new file mode 100644
index 0000000000..3adb6d95b1
--- /dev/null
+++ b/io/do_fxstatat.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 2005-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Ho hum, since fxstatat == fxstatat64 we must get rid of the
+   prototype or gcc will complain since they don't strictly match.  */
+#define __fxstatat64 __fxstatat64_disable
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+int
+__do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  if (vers != _STAT_VER_KERNEL && vers != _STAT_VER_LINUX)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return INLINE_SYSCALL (newfstatat, 4, fd, file, st, flag);
+}
+libc_hidden_weak (__do_fxstatat)
diff --git a/nptl/Makefile b/nptl/Makefile
index 2df4c9098c..35f165c085 100644
--- a/nptl/Makefile
+++ b/nptl/Makefile
@@ -146,7 +146,8 @@ libpthread-routines = nptl-init nptlfreeres vars events version pt-interp \
 		      mtx_trylock mtx_unlock call_once cnd_broadcast \
 		      cnd_destroy cnd_init cnd_signal cnd_timedwait cnd_wait \
 		      tss_create tss_delete tss_get tss_set pthread_mutex_conf \
-		      libpthread-compat
+		      libpthread-compat \
+		      pthread_migrate __set_thread_area arch_crash
 #		      pthread_setuid pthread_seteuid pthread_setreuid \
 #		      pthread_setresuid \
 #		      pthread_setgid pthread_setegid pthread_setregid \
diff --git a/nptl/Versions b/nptl/Versions
index ff6fc06002..0a294a9c9f 100644
--- a/nptl/Versions
+++ b/nptl/Versions
@@ -287,5 +287,8 @@ libpthread {
     __pthread_barrier_init; __pthread_barrier_wait;
     __shm_directory;
     __libpthread_freeres;
+    pthread_set_migrate_args; pthread_get_migrate_args;
+    __set_thread_area;
+    crash_aarch64; crash_powerpc64; crash_riscv64; crash_x86_64;
   }
 }
diff --git a/nptl/__set_thread_area.c b/nptl/__set_thread_area.c
new file mode 100644
index 0000000000..d1b962cd13
--- /dev/null
+++ b/nptl/__set_thread_area.c
@@ -0,0 +1,6 @@
+#include "pthreadP.h"
+
+int __set_thread_area(void *p)
+{
+  return TLS_INIT_TP(p);
+}
diff --git a/nptl/arch_crash.c b/nptl/arch_crash.c
new file mode 100644
index 0000000000..21af9f8a67
--- /dev/null
+++ b/nptl/arch_crash.c
@@ -0,0 +1,64 @@
+#include <stdbool.h>
+
+/* Only crash if we're executing on aarch64 */
+bool crash_aarch64(long a, long b, long c, long d)
+{
+#ifdef __aarch64__
+  __asm__ __volatile__("mov x0, %0;"
+                       "mov x1, %1;"
+                       "mov x2, %2;"
+                       "mov x3, %3;"
+                       "mov x4, xzr; ldr x4, [x4]" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "x0", "x1", "x2", "x3", "x4");
+  return true;
+#else
+  return false;
+#endif
+}
+
+/* Only crash if we're executing on powerpc64 */
+bool crash_powerpc64(long a, long b, long c, long d)
+{
+#ifdef __powerpc64__
+  __asm__ __volatile__("mr 0, %0;"
+                       "mr 1, %1;"
+                       "mr 2, %2;"
+                       "mr 3, %3;"
+                       ".long 0" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "r0", "r1", "r2", "r3");
+  return true;
+#else
+  return false;
+#endif
+}
+
+/* Only crash if we're executing on riscv64 */
+bool crash_riscv64(long a, long b, long c, long d)
+{
+#ifdef __riscv64__
+  __asm__ __volatile__("addi x1, %0, 0;"
+                       "addi x2, %1, 0;"
+                       "addi x3, %2, 0;"
+                       "addi x4, %3, 0;" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "x1", "x2", "x3", "x4");
+  return true;
+#else
+  return false;
+#endif
+}
+
+/* Only crash if we're executing on x86-64 */
+bool crash_x86_64(long a, long b, long c, long d)
+{
+#ifdef __x86_64__
+  __asm__ __volatile__("mov %0, %%rax;"
+                       "mov %1, %%rbx;"
+                       "mov %2, %%rcx;"
+                       "mov %3, %%rdx;"
+                       "hlt" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "rax", "rbx", "rcx", "rdx");
+  return true;
+#else
+  return false;
+#endif
+}
diff --git a/nptl/descr.h b/nptl/descr.h
index 5f1f35e9a4..fe8115a24a 100644
--- a/nptl/descr.h
+++ b/nptl/descr.h
@@ -54,7 +54,44 @@
   ((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - 1) \
    / PTHREAD_KEY_2NDLEVEL_SIZE)
 
+/* Replacement type for __m128 since this file is included by ld.so,
+   which is compiled with -mno-sse.  It must not change the alignment
+   of rtld_savespace_sse.  */
+typedef struct
+{
+  int i[4];
+} __128bits;
 
+/* x86_64 tcbhead */
+typedef struct
+{
+  void *tcb;		/* Pointer to the TCB.  Not necessarily the
+			   thread descriptor used by libpthread.  */
+  dtv_t *dtv;
+  void *self;		/* Pointer to the thread descriptor.  */
+  int multiple_threads;
+  int gscope_flag;
+  uintptr_t sysinfo;
+  uintptr_t stack_guard;
+  uintptr_t pointer_guard;
+  unsigned long int vgetcpu_cache[2];
+  /* Bit 0: X86_FEATURE_1_IBT.
+     Bit 1: X86_FEATURE_1_SHSTK.
+   */
+  unsigned int feature_1;
+  int __glibc_unused1;
+  /* Reservation of some values for the TM ABI.  */
+  void *__private_tm[4];
+  /* GCC split stack support.  */
+  void *__private_ss;
+  /* The lowest address of shadow stack,  */
+  unsigned long long int ssp_base;
+  /* Must be kept even if it is no longer used by glibc since programs,
+     like AddressSanitizer, depend on the size of tcbhead_t.  */
+  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));
+
+  void *__padding[8];
+} x86_64_tcbhead_t;
 
 
 /* Internal version of the buffer to store cancellation handler
@@ -126,40 +163,8 @@ struct priority_protection_data
 /* Thread descriptor data structure.  */
 struct pthread
 {
-  union
-  {
-#if !TLS_DTV_AT_TP
-    /* This overlaps the TCB as used for TLS without threads (see tls.h).  */
-    tcbhead_t header;
-#else
-    struct
-    {
-      /* multiple_threads is enabled either when the process has spawned at
-	 least one thread or when a single-threaded process cancels itself.
-	 This enables additional code to introduce locking before doing some
-	 compare_and_exchange operations and also enable cancellation points.
-	 The concepts of multiple threads and cancellation points ideally
-	 should be separate, since it is not necessary for multiple threads to
-	 have been created for cancellation points to be enabled, as is the
-	 case is when single-threaded process cancels itself.
-
-	 Since enabling multiple_threads enables additional code in
-	 cancellation points and compare_and_exchange operations, there is a
-	 potential for an unneeded performance hit when it is enabled in a
-	 single-threaded, self-canceling process.  This is OK though, since a
-	 single-threaded process will enable async cancellation only when it
-	 looks to cancel itself and is hence going to end anyway.  */
-      int multiple_threads;
-      int gscope_flag;
-    } header;
-#endif
-
-    /* This extra padding has no special purpose, and this structure layout
-       is private and subject to change without affecting the official ABI.
-       We just have it here in case it might be convenient for some
-       implementation-specific instrumentation hack or suchlike.  */
-    void *__padding[24];
-  };
+  /* Least common denominator for a header.  */
+  x86_64_tcbhead_t header;
 
   /* This descriptor's link on the `stack_used' or `__stack_user' list.  */
   list_t list;
@@ -228,6 +233,12 @@ struct pthread
   {
     __pthread_slist_t robust_list;
     struct robust_list_head robust_head;
+
+    /* Padding for Popcorn Linux  */
+    struct {
+      __pthread_slist_t pad_robust_list;
+      struct robust_list_head pad_robust_head;
+    };
   };
 
 # define ENQUEUE_MUTEX_BOTH(mutex, val)					      \
@@ -400,6 +411,9 @@ struct pthread
   /* Indicates whether is a C11 thread created by thrd_creat.  */
   bool c11;
 
+  /* Popcorn Linux Migration Arguments.  */
+  void *popcorn_migrate;
+
   /* This member must be last.  */
   char end_padding[];
 
@@ -408,4 +422,25 @@ struct pthread
 } __attribute ((aligned (TCB_ALIGNMENT)));
 
 
+#if defined (__x86_64__)
+
+# ifdef __ILP32__
+/* morestack.S in libgcc uses offset 0x40 to access __private_ss,   */
+_Static_assert (offsetof (struct pthread, header.__private_ss) == 0x40,
+		"offset of __private_ss != 0x40");
+/* NB: ssp_base used to be "long int __glibc_reserved2", which was
+   changed from 32 bits to 64 bits.  Make sure that the offset of the
+   next field, __glibc_unused2, is unchanged.  */
+_Static_assert (offsetof (struct pthread, header.__glibc_unused2) == 0x60,
+		"offset of __glibc_unused2 != 0x60");
+# else
+/* morestack.S in libgcc uses offset 0x70 to access __private_ss,   */
+_Static_assert (offsetof (struct pthread, header.__private_ss) == 0x70,
+		"offset of __private_ss != 0x70");
+_Static_assert (offsetof (struct pthread, header.__glibc_unused2) == 0x80,
+		"offset of __glibc_unused2 != 0x80");
+# endif
+
+#endif
+
 #endif	/* descr.h */
diff --git a/nptl/pthread_migrate.c b/nptl/pthread_migrate.c
new file mode 100644
index 0000000000..a14f99a23c
--- /dev/null
+++ b/nptl/pthread_migrate.c
@@ -0,0 +1,16 @@
+#include "pthreadP.h"
+
+void
+pthread_set_migrate_args (void *args)
+{
+  struct pthread *self = THREAD_SELF;
+  THREAD_SETMEM (self, popcorn_migrate, args);
+}
+
+void
+*pthread_get_migrate_args (void)
+{
+  struct pthread *self = THREAD_SELF;
+  void *args = THREAD_GETMEM (self, popcorn_migrate);
+  return args;
+}
diff --git a/remote_io/Makefile b/remote_io/Makefile
new file mode 100644
index 0000000000..91278f8247
--- /dev/null
+++ b/remote_io/Makefile
@@ -0,0 +1,54 @@
+# Copyright (C) 2022 RASEC Technologies
+# This file is part of the GNU C Library.
+
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, see
+# <https://www.gnu.org/licenses/>.
+
+#
+#	Sub-makefile for Remote I/O portion of the library.
+#
+subdir	:= remote_io
+
+include ../Makeconfig
+
+headers := remote_io.h local_io.h platform.h debug/log.h debug/arch_crash.h
+
+routines := rio_write rio_open rio_server rio_print log platform io \
+	    pcn_send pcn_open pcn_read rio_read pcn_fxstatat rio_fxstatat \
+	    pcn_mmap rio_mmap rio_vma local_io file_ops lio_util \
+	    lio_signal pcn_epoll rio_epoll pcn_fallocate rio_fallocate \
+	    pcn_sigaction rio_sigaction pcn_fcntl rio_fcntl \
+	    pcn_getcwd rio_getcwd pcn_close rio_close pcn_pipe rio_pipe \
+	    pcn_socket rio_socket pcn_bind rio_bind pcn_listen rio_listen \
+	    pcn_accept rio_accept pcn_connect rio_connect pcn_poll rio_poll
+
+$(objpfx)rio_write.os: $(common-objpfx)misc/bits/syscall.h
+
+others = popcorn_killd
+
+install-bin = popcorn_killd
+
+sysroot = `$(CC) -print-sysroot`
+rtld-LDFLAGS = $()
+
+# Debug workaround, because popcorn ld-linux is not backwards
+# compatible with the system's ld-linux.
+LDFLAGS-popcorn_killd = -Wl,-rpath,$(sysroot)/lib -Wl,-dynamic-linker,$(sysroot)/lib/ld-2.31.so
+
+popcorn_killd-modules = local_io lio_util lio_signal
+
+include ../Rules
+
+#$(objpfx)popcorn_killd: $(popcorn_killd-modules%=$(objpfx)%.o)
+#$(objpfx)popcorn_killd: $(objpfx)local_io.o $(objpfx)lio_util.o
diff --git a/remote_io/Versions b/remote_io/Versions
new file mode 100644
index 0000000000..121adc2652
--- /dev/null
+++ b/remote_io/Versions
@@ -0,0 +1,34 @@
+
+ld {
+  GLIBC_PRIVATE {
+    lio_error;
+    lio_strlen;
+  }
+}
+
+libc {
+  GLIBC_PRIVATE {
+    pcn_migrate;
+    pcn_server_connect;
+    pcn_server_init;
+    popcorn_log;
+    pcn_writev;
+    pcn_write;
+    pcn_openat;
+    pcn_close;
+    pcn_fxstatat;
+    pcn_sigaction;
+    pcn_epoll_create;
+    pcn_epoll_ctl;
+    pcn_epoll_wait;
+    pcn_fallocate;
+    pcn_mmap;
+    pcn_munmap;
+    pcn_get_ip;
+    pcn_unload_signals;
+    pcn_restore_signals;
+    pcn_accept;
+    pcn_connect;
+    pcn_read;
+  }
+}
diff --git a/remote_io/debug/arch_crash.h b/remote_io/debug/arch_crash.h
new file mode 100644
index 0000000000..2a77b89fed
--- /dev/null
+++ b/remote_io/debug/arch_crash.h
@@ -0,0 +1,19 @@
+#ifndef _ARCH_CRASH_H
+#define _ARCH_CRASH_H
+
+#include <stdbool.h>
+
+/* Crash, placing up to 4 values in the first 4 integer registers of the
+ * architecture on which we're executing. */
+bool crash(long a, long b, long c, long d);
+
+/* These APIs will crash an application *only* if called on the corresponding
+ * architecture, i.e., crash_aarch64() will only crash the program if the
+ * calling thread is executing on aarch64. Similar to above, place up to 4
+ * values in the first 4 integer registers. */
+
+bool crash_aarch64(long a, long b, long c, long d);
+bool crash_powerpc64(long a, long b, long c, long d);
+bool crash_x86_64(long a, long b, long c, long d);
+
+#endif
diff --git a/remote_io/debug/log.h b/remote_io/debug/log.h
new file mode 100644
index 0000000000..916f6bd3e8
--- /dev/null
+++ b/remote_io/debug/log.h
@@ -0,0 +1,14 @@
+#ifndef _DEBUG_LOG_H
+#define _DEBUG_LOG_H
+
+/*
+ * Open a per-thread log & log a statement.  Valid regardless of migration.
+ * @param format a message/format descriptor
+ * @param ... arguments to format descriptor
+ * @return the number of characters printed (excluding ending null byte) or -1
+ *         if there was an error
+ */
+int popcorn_log(const char *format, ...);
+
+#endif
+
diff --git a/remote_io/file_ops.c b/remote_io/file_ops.c
new file mode 100644
index 0000000000..b39054c66e
--- /dev/null
+++ b/remote_io/file_ops.c
@@ -0,0 +1,166 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "server.h"
+#include "message.h"
+#include "remote_io.h"
+#include "local_io.h"
+#include "popcorn.h"
+
+/* File I/O Operations.  */
+
+int rio_tmp_init = 0;
+
+void
+rio_init_tmpdir (void)
+{
+  struct stat st;
+  int res, tmp_dir = 0;
+
+  if (rio_tmp_init)
+    return;
+
+  res = lio_stat (PCN_TMP_DIR, &st);
+
+  if (res < 0)
+    tmp_dir = 0;
+  else if (res == 0 && !(st.st_mode & S_IFDIR))
+    lio_unlink (PCN_TMP_DIR);
+  else
+    tmp_dir = 1;
+
+  if (!tmp_dir)
+    mkdir (PCN_TMP_DIR, 0770);
+
+  rio_tmp_init = 1;
+}
+
+void
+rio_maybe_zap_file (const char *fname)
+{
+  struct stat st;
+  int res;
+
+  res = lio_stat (fname, &st);
+  if (res >= 0)
+    lio_unlink (fname);
+}
+
+int
+rio_get_file (struct pcn_msg_open *msg, int sockfd)
+{
+  struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+  struct pcn_msg_io_data iod;
+  struct pcn_msg_hdr ack;
+  int recv, res;
+  int newfd;
+  void *addr;
+  off_t offset = 0;
+
+  rio_init_tmpdir ();
+  rio_maybe_zap_file (msg->pathname);
+
+  rio_dbg_printf ("%s: creating file '%s'\n", __FUNCTION__, msg->pathname);
+
+  newfd = lio_open (msg->pathname, O_CREAT|O_RDWR|O_TRUNC, 0664);
+  if (newfd < 0)
+    lio_error ("%s: failed to create local copy of '%s'\n",
+	       __FUNCTION__, msg->pathname);
+
+  ack.msg_id = 0;
+  ack.msg_type = PCN_TYPE_CONTROL;
+  ack.msg_kind = PCN_CTL_ACK;
+  ack.msg_async = PCN_SEND_NORET;
+  ack.msg_size = sizeof (ack);
+  pcn_send (sockfd, &ack);
+
+  res = lio_get_msg (sockfd, &iod, sizeof (iod));
+  if (res < sizeof (iod))
+    lio_error ("%s: failed to receive incoming file size\n", __FUNCTION__);
+
+  //res = lio_fallocate (newfd, 0, 0, iod.data.cnt);
+  res = lio_ftruncate (newfd, iod.data.cnt);
+  if (res < 0)
+    lio_error ("%s: failed to truncate '%s'\n", __FUNCTION__, msg->pathname);
+
+  addr = lio_mmap (NULL, iod.data.cnt, PROT_WRITE, MAP_SHARED, newfd, 0);
+  if (addr == (void *)-1)
+    lio_error ("%s: failed to mmap '%s'\n", __FUNCTION__, msg->pathname);
+
+  rio_dbg_printf ("%s: receiving '%s', size = %u bytes in fd = %u\n",
+		  __FUNCTION__, msg->pathname, iod.data.cnt, newfd);
+
+  recv = 0;
+
+  while (recv < iod.data.cnt)
+    {
+      res = lio_read (sockfd, addr + recv, iod.data.cnt - recv);
+
+      if (res < 0)
+	lio_error ("%s: failed to receive file, res = %u\n", __FUNCTION__, res);
+
+      recv += res;
+      //rio_dbg_printf ("%s: received %u bytes (%u)\n", __FUNCTION__, recv, res);
+    }
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, addr);
+
+  lio_munmap (addr, iod.data.cnt);
+  lio_close (newfd);
+
+  lio_get_msg (sockfd, &ack, sizeof (ack));
+
+  rio_dbg_printf ("%s: received %u bytes\n", __FUNCTION__, res);
+
+  return abs(msg->dirfd);
+}
+
+int
+rio_send_file (struct pcn_msg_hdr *hdr)
+{
+  struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+  struct pcn_msg_io_data iod;
+  struct pcn_msg_hdr ack;
+  struct stat st;
+  int sockfd = pd->pcn_server_sockfd;
+  char fname[hdr->msg_size];
+  int sent, res;
+  int fd;
+  void *addr;
+  off_t offset = 0;
+
+  res = lio_get_msg (sockfd, fname, hdr->msg_size);
+
+  fd = lio_open (fname, O_RDONLY, 0);
+  lio_fstat (fd, &st);
+
+  rio_dbg_printf ("%s[%u]: sending file '%s', size = %u\n",
+		  __FUNCTION__, hdr->msg_id, fname, st.st_size);
+
+  sent = 0;
+  while (sent < st.st_size)
+    {
+      res = lio_sendfile (sockfd, fd, &offset, st.st_size - sent);
+
+      if (res < 0)
+	lio_error ("%s[%u]: failed to send file -- errno = %u\n",
+		   __FUNCTION__, hdr->msg_id, errno);
+
+      sent += res;
+    }
+
+  rio_dbg_printf ("%s[%u]: sent file '%s', size = '%u' bytes\n",
+		  __FUNCTION__, hdr->msg_id, fname, sent);
+
+  lio_close (fd);
+
+  res = lio_get_msg (sockfd, &ack, sizeof (ack));
+  LIO_ASSERT (res == sizeof (ack), "failed to receive ack\n");
+
+  return sent;
+}
diff --git a/remote_io/io.c b/remote_io/io.c
new file mode 100644
index 0000000000..ea144cdaf7
--- /dev/null
+++ b/remote_io/io.c
@@ -0,0 +1,15 @@
+#include <sysdep-cancel.h>
+
+#include <errno.h>
+#include "server.h"
+#include "local_io.h"
+
+int
+rio_msg_id (void)
+{
+  /* This will need to be updated because static DSO variables get
+     cleared out during migration.  */
+  static int rio_msg_id = 1000;
+
+  return rio_msg_id++;
+}
diff --git a/remote_io/lio_signal.c b/remote_io/lio_signal.c
new file mode 100644
index 0000000000..b1b04ca192
--- /dev/null
+++ b/remote_io/lio_signal.c
@@ -0,0 +1,63 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <sys/syscall.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/uio.h>
+#include <elf.h>
+#include <errno.h>
+#include <sys/auxv.h>
+#include <nptl/pthreadP.h>
+#include "remote_io.h"
+#include "local_io.h"
+
+/* Glibc: sysdeps/unix/sysv/linux/sigopts.h  */
+
+/* Return a mask that includes the bit for SIG only.  */
+# define __sigmask(sig) \
+  (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))
+
+/* Return the word index for SIG.  */
+# define __sigword(sig) (((sig) - 1) / (8 * sizeof (unsigned long int)))
+
+int
+lio_rt_sigaction (int sig, struct ksigaction *kact, struct ksigaction *koact,
+		  int nr)
+{
+  return SYSCALL_CANCEL (rt_sigaction,  sig, (uintptr_t) kact,
+			 (uintptr_t) koact, nr);
+}
+
+int
+lio_sigprocmask (int sig, sigset_t *set, sigset_t *oset, int nr)
+{
+  sigset_t local_newmask;
+
+  /* The only thing we have to make sure here is that SIGCANCEL and
+     SIGSETXID are not blocked.  */
+  if (set != NULL
+      && __glibc_unlikely (__sigismember (set, SIGCANCEL)
+	|| __glibc_unlikely (__sigismember (set, SIGSETXID))))
+    {
+      local_newmask = *set;
+      __sigdelset (&local_newmask, SIGCANCEL);
+      __sigdelset (&local_newmask, SIGSETXID);
+      set = &local_newmask;
+    }
+
+  return INLINE_SYSCALL_CALL (rt_sigprocmask, sig, set, oset, nr);
+}
+
+int
+lio_sigaddset (sigset_t *set, int sig)
+{
+  unsigned long int __mask = __sigmask (sig);
+  unsigned long int __word = __sigword (sig);
+
+  set->__val[__word] |= __mask;
+
+  return 0;
+}
\ No newline at end of file
diff --git a/remote_io/lio_util.c b/remote_io/lio_util.c
new file mode 100644
index 0000000000..f69a15916c
--- /dev/null
+++ b/remote_io/lio_util.c
@@ -0,0 +1,164 @@
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <linux/sockios.h>
+#include "local_io.h"
+
+int
+lio_strlen (char *a)
+{
+  int i;
+
+  for (i = 0; a[i] != '\0'; i++)
+    ;
+
+  return i;
+}
+
+int
+lio_strcmp (char *a, char *b)
+{
+  int i;
+
+  for (i = 0; a[i] != '\0' && b[i] != '\0' && a[i] == b[i]; i++)
+    ;
+
+  return a[i] - b[i];
+}
+
+void
+lio_print (const char *str)
+{
+  int len;
+
+  for (len = 0; str[len] != '\0'; len++)
+    ;
+
+  lio_write (1, str, len);
+}
+
+void
+lio_error (const char *restrict fmt, ...)
+{
+  va_list arg;
+
+  va_start (arg, fmt);
+  rio_dbg_vfprintf (STDOUT_FILENO, fmt, arg);
+  va_end (arg);
+
+  lio_spin ();
+  lio_exit (-1);
+}
+
+void
+lio_assert (int cond, const char *restrict msg, const char *restrict file, int lineno)
+{
+  if (cond)
+    return;
+
+  rio_dbg_printf ("%s:%u -- %s\n", file, lineno, msg);
+  lio_exit (EXIT_FAILURE);
+}
+
+void
+lio_memset (void *s, int c, size_t n)
+{
+  int i;
+  uint8_t *t = s;
+
+  for (i = 0; i < n; i++)
+    t[i] = c;
+}
+
+void
+lio_memcpy (void *restrict d, const void *s, size_t n)
+{
+  int i;
+  uint8_t *dd = d;
+  const uint8_t *ss = s;
+
+  for (i = 0; i < n; i++)
+    dd[i] = ss[i];
+}
+
+void
+lio_spin (void)
+{
+  volatile int lock = 1;
+  while (lock)
+    ;
+}
+
+/* This needs a proper malloc routine.  */
+void *
+lio_malloc (size_t size)
+{
+  void *mem = lio_mmap (NULL, size, PROT_READ | PROT_WRITE,
+			MAP_ANON | MAP_PRIVATE, -1, 0);
+
+  if (mem == NULL)
+    lio_error ("malloc failed\n");
+
+  //lio_printf ("allocated %u bytes @ %lx\n", size, mem);
+
+  return mem;
+}
+
+void
+lio_free (void *ptr)
+{
+  return;
+}
+
+void
+lio_assert_sock_free (int fd, char *fn, int lineno)
+{
+  int res;
+
+  /* man 3 tcp.  */
+  lio_ioctl_3 (fd, SIOCINQ, &res);
+  if (res != 0)
+    lio_error ("%s @ %u: detected incoming message fragments = %u\n", fn, lineno, res);
+
+  /*
+  lio_ioctl_3 (fd, SIOCOUTQ, &res);
+  if (res != 0)
+    lio_error ("%s @ %u: detected outgoing message fragments = %u\n", fn, lineno, res);
+  */
+}
+
+int
+lio_send_msg (int sockfd, void *data, int size)
+{
+  int count = 0;
+
+  do {
+    count += lio_write (sockfd, (char *)(data + count), size - count);
+  } while (count < size);
+}
+
+/* Read SIZE bytes from SOCK into BUF. SOCK is read until SIZE bytes
+   have been received or an error has been encounterd. */
+int
+lio_get_msg (int sock, void *buf, int size)
+{
+  int cnt = 0;
+  int res;
+
+  while (cnt < size)
+  {
+    res = lio_read (sock, &((char *)buf)[cnt], size - cnt);
+
+    if (res <= 0)
+      {
+	//rio_printf ("%s: error - lost data (%d -> %d/%d) - %d\n",
+	//	    __FUNCTION__, size, cnt, res, errno);
+	return res;
+      }
+
+      cnt += res;
+  }
+
+  return cnt;
+}
\ No newline at end of file
diff --git a/remote_io/local_io.c b/remote_io/local_io.c
new file mode 100644
index 0000000000..3112d7163e
--- /dev/null
+++ b/remote_io/local_io.c
@@ -0,0 +1,317 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/uio.h>
+#include <elf.h>
+#include <errno.h>
+#include <sys/auxv.h>
+#include <nptl/pthreadP.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <poll.h>
+#include <socketcall.h>
+#include <kernel-features.h>
+#include <sys/syscall.h>
+#include "remote_io.h"
+#include "local_io.h"
+
+int pcn_mode; // 1 = server
+
+void
+*lio_mmap(void *addr, size_t length, int prot, int flags,
+	      int fd, off_t offset)
+{
+#ifdef __NR_mmap2
+  return (void *) INLINE_SYSCALL_CALL (mmap2, addr, length, prot, flags, fd, offset);
+#else
+  return (void *) INLINE_SYSCALL_CALL (mmap, addr, length, prot, flags, fd, offset);
+#endif
+}
+
+int
+lio_munmap (void *addr, size_t len)
+{
+  return (int) INLINE_SYSCALL_CALL (munmap, addr, len);
+}
+
+int
+lio_mprotect (void *addr, size_t len, int prot)
+{
+  return SYSCALL_CANCEL (mprotect, (uintptr_t) addr, len, prot);
+}
+
+int
+lio_write (int fd, const void *buf, unsigned long count)
+{
+  return SYSCALL_CANCEL (write, fd, (uintptr_t) buf, count);
+}
+
+int
+lio_writev (int fd, const struct iovec *iov, int iovcnt)
+{
+  return SYSCALL_CANCEL (writev, fd, (uintptr_t) iov, iovcnt);
+}
+
+ssize_t
+lio_read(int fd, void *buf, size_t count)
+{
+  return SYSCALL_CANCEL (read, fd, (uintptr_t) buf, count);
+}
+
+ssize_t
+lio_pread(int fd, void *buf, size_t count, off_t offset)
+{
+  return SYSCALL_CANCEL (pread64, fd, (uintptr_t) buf, count, offset);
+}
+
+int
+lio_open (const char *pathname, int flags, mode_t mode)
+{
+#ifdef SYS_open
+  return SYSCALL_CANCEL (open, (uintptr_t)pathname, flags, mode);
+#else
+  return SYSCALL_CANCEL (openat, AT_FDCWD, (uintptr_t)pathname, flags, mode);
+#endif
+}
+
+int
+lio_openat (int dirfd, const char *pathname, int flags, mode_t mode)
+{
+  return SYSCALL_CANCEL (openat, dirfd, pathname, flags, mode);
+}
+
+int
+lio_close (int fd)
+{
+  return SYSCALL_CANCEL (close, fd);
+}
+
+int
+lio_fstatat(int dirfd, const char *restrict pathname,
+	    struct stat *restrict statbuf, int flags)
+{
+  INTERNAL_SYSCALL_DECL (err);
+
+  return INTERNAL_SYSCALL (newfstatat, err, 4, dirfd, pathname, statbuf, flags);
+}
+
+int
+lio_stat(const char *restrict pathname, struct stat *restrict statbuf)
+{
+  return __do_fxstatat (_STAT_VER, AT_FDCWD, pathname, statbuf, 0);
+}
+
+int 
+lio_fstat (int fd, struct stat *statbuf)
+{
+  return __do_fxstatat (_STAT_VER, fd, "", statbuf, AT_EMPTY_PATH);
+}
+
+int
+lio_truncate (const char *path, off_t length)
+{
+  return SYSCALL_CANCEL (truncate, path, length);
+}
+
+int
+lio_ftruncate (int fd, off_t length)
+{
+  return SYSCALL_CANCEL (ftruncate, fd, length);
+}
+
+int
+lio_fallocate (int fd, int mode, off_t offset, off_t len)
+{
+  return SYSCALL_CANCEL (fallocate, fd, mode,
+			 SYSCALL_LL (offset), SYSCALL_LL (len));
+}
+
+int
+lio_ioctl_3 (int fd, unsigned long request, const void *arg)
+{
+  return ioctl (fd, request, arg);
+}
+
+int
+lio_fcntl (int fd, int cmd, void *arg)
+{
+  LIO_ASSERT (cmd == F_GETFL || cmd == F_SETFL || F_GETFD,
+	      "unsupported fcntl arguments");
+
+  return INLINE_SYSCALL_CALL (fcntl, fd, cmd, (void *) arg);
+}
+
+int
+lio_link(const char *oldpath, const char *newpath)
+{
+  return INLINE_SYSCALL (linkat, 5, AT_FDCWD, oldpath, AT_FDCWD, newpath, 0);
+}
+
+int
+lio_unlink(const char *pathname)
+{
+  return INLINE_SYSCALL (unlinkat, 3, AT_FDCWD, pathname, 0);
+}
+
+int
+lio_getcwd (char *buf, size_t size)
+{
+  return INLINE_SYSCALL (getcwd, 2, buf, size);
+}
+
+void
+lio_exit (int status)
+{
+  SYSCALL_CANCEL (exit, status);
+}
+
+int
+lio_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
+{
+  return SYSCALL_CANCEL (accept4, fd, addr.__sockaddr__, len, 0);
+}
+
+int
+lio_accept_raw(int sockfd, const void *addr, socklen_t *addrlen)
+{
+  return SYSCALL_CANCEL (accept, sockfd, addr, addrlen);
+}
+
+int
+lio_socket(int domain, int type, int protocol)
+{
+  return SYSCALL_CANCEL (socket, domain, type, protocol);
+}
+
+ssize_t
+lio_sendfile (int out_fd, int in_fd, off_t *offset, size_t count)
+{
+  return SYSCALL_CANCEL (sendfile, out_fd, in_fd, offset, count);
+}
+
+int
+lio_bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
+{
+  return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, len);
+}
+
+int
+lio_bind_raw (int fd, const void *addr, socklen_t len)
+{
+  return INLINE_SYSCALL (bind, 3, fd, addr, len);
+}
+
+int
+lio_getsockname (int fd, __SOCKADDR_ARG addr, socklen_t *len)
+{
+  return INLINE_SYSCALL (getsockname, 3, fd, addr.__sockaddr__, len);
+}
+
+int
+lio_getsockopt (int fd, int level, int optname, const void *optval, socklen_t *len)
+{
+  return INLINE_SYSCALL (getsockopt, 5, fd, level, optname, optval, len);
+}
+
+int
+lio_setsockopt (int fd, int level, int optname, const void *optval, socklen_t len)
+{
+  return INLINE_SYSCALL (setsockopt, 5, fd, level, optname, optval, len);
+}
+
+int
+lio_listen (int sockfd, int backlog)
+{
+  return INLINE_SYSCALL (listen, 2, sockfd, backlog);
+}
+
+int
+lio_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
+{
+  return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, len);
+}
+
+int
+lio_connect_raw (int fd, const void *addr, socklen_t len)
+{
+  return SYSCALL_CANCEL (connect, fd, addr, len);
+}
+
+int
+lio_getpid (void)
+{
+  return SYSCALL_CANCEL (getpid);
+}
+
+int
+lio_gettid (void)
+{
+  return SYSCALL_CANCEL (gettid);
+}
+
+int
+lio_kill (pid_t pid, int sig)
+{
+  return SYSCALL_CANCEL (kill, pid, sig);
+}
+
+int
+lio_tgkill (pid_t pid, pid_t tid, int sig)
+{
+  return SYSCALL_CANCEL (tgkill, pid, tid, sig);
+}
+
+int
+lio_arch_prctl (int code, unsigned long addr)
+{
+#ifdef __x86_64__
+  return SYSCALL_CANCEL (arch_prctl, code, addr);
+#else
+  return 0;
+#endif
+}
+
+int
+lio_dup (int oldfd)
+{
+  return __dup (oldfd);
+}
+
+int
+lio_dup2 (int oldfd, int newfd)
+{
+  return SYSCALL_CANCEL (dup3, oldfd, newfd, 0);
+}
+
+int
+lio_pipe2 (int pfds[2], int flags)
+{
+  return INLINE_SYSCALL (pipe2, 2, pfds, flags);
+}
+
+int
+lio_epoll_create1 (int flags)
+{
+ return INLINE_SYSCALL (epoll_create1, 1, flags);
+}
+
+int
+lio_poll (struct pollfd *fds, int nfds, int timeout)
+{
+#ifdef __NR_poll
+  return SYSCALL_CANCEL (poll, fds, nfds, timeout);
+#else
+  return 0;
+#endif
+}
+
+int
+lio_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+	   const sigset_t *sigmask)
+{
+  return SYSCALL_CANCEL (ppoll, fds, nfds, tp, sigmask, _NSIG / 8);
+}
diff --git a/remote_io/local_io.h b/remote_io/local_io.h
new file mode 100644
index 0000000000..e368262fd7
--- /dev/null
+++ b/remote_io/local_io.h
@@ -0,0 +1,129 @@
+#ifndef LIO_H
+#define LIO_H
+
+#include <unistd.h>
+#include <stddef.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
+#include <signal.h>
+#include <stddef.h>
+
+#if defined (__x86_64__)
+#define pcn_break()  do { asm volatile ("int3;"); } while (0)
+#elif defined (__aarch64__)
+#define pcn_break()  do { asm volatile ("brk #01;"); } while (0)
+#else
+#define pcn_break() spin()
+#endif
+
+#define LIO_ASSERT(cond, msg) lio_assert ((int)(cond), msg, __FILE__, __LINE__)
+
+struct ksigaction {
+	void (*handler)(int);
+	unsigned long flags;
+	void (*restorer)(void);
+	unsigned mask[2];
+};
+
+struct iovec;
+
+#define lio_stdin STDIN_FILENO
+#define lio_stdout STDOUT_FILENO
+#define lio_stderr STDERR_FILENO
+
+extern int pcn_mode; // 1 = server
+
+extern void *lio_mmap(void *addr, size_t length, int prot, int flags,
+		     int fd, off_t offset);
+extern int lio_munmap (void *addr, size_t len);
+extern int lio_mprotect (void *addr, size_t len, int prot);
+extern int lio_write (int fd, const void *buf, unsigned long count);
+extern int lio_writev (int fd, const struct iovec *iov, int iovcnt);
+extern ssize_t lio_read(int fd, void *buf, size_t count);
+extern ssize_t lio_pread(int fd, void *buf, size_t count, off_t offset);
+extern int lio_open (const char *pathname, int flags, mode_t mode);
+extern int lio_openat (int dirfd, const char *pathname, int flags, mode_t mode);
+extern int lio_close (int fd);
+extern int lio_fstatat (int dirfd, const char *restrict pathname,
+			struct stat *restrict statbuf, int flags);
+extern int lio_fstat (int fd, struct stat *statbuf);
+extern int lio_stat (const char *restrict pathname,
+                    struct stat *restrict statbuf);
+extern int lio_truncate (const char *path, off_t length);
+extern int lio_ftruncate (int fd, off_t length);
+extern int lio_fallocate (int fd, int mode, off_t offset, off_t len);
+
+extern int lio_link (const char *oldpath, const char *newpath);
+extern int lio_unlink (const char *pathname);
+extern int lio_getcwd (char *buf, size_t size);
+
+extern int lio_ioctl_3 (int fd, unsigned long request, const void *arg);
+extern int lio_fcntl (int fd, int cmd, void *arg);
+
+extern int lio_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len);
+extern int lio_accept_raw (int sockfd, const void *addr, socklen_t *addrlen);
+extern int lio_socket (int domain, int type, int protocol);
+extern ssize_t lio_sendfile (int out_fd, int in_fd, off_t *offset, size_t count);
+extern int lio_bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
+extern int lio_bind_raw (int fd, const void * addr, socklen_t len);
+extern int lio_getsockname (int fd, __SOCKADDR_ARG addr, socklen_t *len);
+extern int lio_getsockopt (int fd, int level, int optname, const void *optval,
+			   socklen_t *len);
+extern int lio_setsockopt (int fd, int level, int optname, const void *optval,
+			   socklen_t len);
+extern int lio_listen (int sockfd, int backlog);
+extern int lio_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
+extern int lio_connect_raw (int fd, const void *addr, socklen_t len);
+
+extern void lio_exit (int status);
+extern int lio_getpid (void);
+extern int lio_gettid (void);
+extern int lio_kill (pid_t pid, int sig);
+extern int lio_tgkill (pid_t pid, pid_t tid, int sig);
+extern int lio_arch_prctl (int code, unsigned long addr);
+
+extern int lio_rt_sigaction (int sig, struct ksigaction *kact,
+			    struct ksigaction *koact, int nr);
+extern int lio_sigprocmask (int sig, sigset_t *set, sigset_t *oset, int nr);
+extern int lio_sigaddset (sigset_t *set, int sig);
+extern int lio_dup (int oldfd);
+extern int lio_dup2 (int oldfd, int newfd);
+extern int lio_pipe2 (int pfds[2], int flags);
+
+extern int lio_epoll_create1 (int flags);
+extern int lio_poll (struct pollfd *fds, int nfds, int timeout);
+extern int lio_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+		      const sigset_t *sigmask);
+
+/* Utility functions  */
+
+extern int lio_strlen (char *str);
+extern int lio_strcmp (char *a, char *b);
+extern void lio_memset (void *s, int c, size_t n);
+extern void lio_memcpy (void *restrict d, const void *s, size_t n);
+extern void lio_spin (void);
+
+extern int lio_dbg_printf (const char *fmt, ...);
+extern void lio_print (const char *str);
+extern void lio_error (const char *restrict fmt, ...);
+extern void lio_assert (int cond, const char *restrict msg,
+			const char *restrict file, int lineno);
+
+extern int lio_get_msg (int sock, void *buf, int size);
+extern int lio_send_msg (int sockfd, void *data, int size);
+
+extern void *lio_malloc (size_t size);
+extern void lio_free (void *ptr);
+
+extern void lio_assert_sock_free (int fd, char *fn, int lineno);
+
+/* Eventually this will be a debug option.  */
+#define lio_assert_empty_socket(fd) (lio_assert_sock_free ((fd), __FUNCTION__, __LINE__))
+
+/* Multi-versioned functions.  */
+extern int __do_epoll_ctl (int ver, int epfd, int op, int fd,
+			   struct epoll_event *event);
+extern int __do_epoll_wait (int ver, int epfd, struct epoll_event *events,
+			    int maxevents, int timeout);
+
+#endif
diff --git a/remote_io/log.c b/remote_io/log.c
new file mode 100644
index 0000000000..69a69d8327
--- /dev/null
+++ b/remote_io/log.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdarg.h>
+#include <unistd.h>
+
+#define BUF_SIZE 32
+
+int popcorn_log(const char *format, ...)
+{
+  int ret = -1;
+  char buf[BUF_SIZE];
+  FILE *fp;
+  va_list ap;
+
+  snprintf(buf, BUF_SIZE, "/tmp/%d.log", gettid());
+  fp = fopen(buf, "a");
+  if(fp) {
+    va_start(ap, format);
+    ret = vfprintf(fp, format, ap);
+    fclose(fp);
+  }
+  return ret;
+}
+
diff --git a/remote_io/message.h b/remote_io/message.h
new file mode 100644
index 0000000000..f917f21b2c
--- /dev/null
+++ b/remote_io/message.h
@@ -0,0 +1,215 @@
+#ifndef MESSAGE_H
+#define MESSAGE_H
+
+struct iovec;
+
+typedef enum {
+  PCN_TYPE_CONTROL,
+  PCN_TYPE_SYSCALL,
+  PCN_TYPE_RES,
+} pcn_msg_type;
+
+typedef enum {
+  PCN_SYS_OPEN,
+  PCN_SYS_CLOSE,
+  PCN_SYS_READ,
+  PCN_SYS_WRITE,
+  PCN_SYS_FXSTATAT,
+  PCN_SYS_MMAP,
+  PCN_SYS_MUNMAP,
+  PCN_SYS_EPOLL_CREATE,
+  PCN_SYS_EPOLL_CTL,
+  PCN_SYS_EPOLL_WAIT,
+  PCN_SYS_FALLOCATE,
+  PCN_SYS_RT_SIGACTION,
+  PCN_SYS_FCNTL,
+  PCN_SYS_GETCWD,
+  PCN_SYS_PIPE,
+  PCN_SYS_SOCKET,
+  PCN_SYS_GETSOCKOPT,
+  PCN_SYS_SETSOCKOPT,
+  PCN_SYS_BIND,
+  PCN_SYS_LISTEN,
+  PCN_SYS_ACCEPT,
+  PCN_SYS_CONNECT,
+  PCN_SYS_POLL,
+  PCN_SYS_PPOLL,
+} pcn_syscall;
+
+typedef enum {
+  PCN_CTL_ACK,
+  PCN_CTL_MIGRATE,
+  PCN_CTL_SYNC,
+} pcn_control;
+
+typedef enum {
+  PCN_SEND_SYNC = 0,
+  PCN_SEND_ASYNC,
+  PCN_SEND_NORET,
+} pcn_send_t;
+
+typedef enum {
+  PCN_SIG_SHUTDOWN,
+  PCN_SIG_KILL,
+  PCN_SIG_ADD,
+} pcn_signal_t;
+
+#define PCN_EPOLL_TYPE_CTL 1
+#define PCN_EPOLL_TYPE_WAIT 2
+
+struct pcn_msg_hdr {
+  pcn_msg_type msg_type;
+  int msg_kind;
+  int msg_id;
+  int msg_size;  /* size of the message payload. */
+  pcn_send_t msg_async;
+} __attribute__ ((packed));
+
+struct pcn_msg_open {
+  int flags;
+  mode_t mode;
+  int dirfd;
+  char pathname[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_close {
+  int fd;
+  int err;
+  int res;
+} __attribute__ ((packed));
+
+struct pcn_msg_read {
+  int fd;
+  int cnt;
+  char buf[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_fallocate {
+  int fd;
+  int mode;
+  off_t offset;
+  off_t len;
+} __attribute__ ((packed));
+
+struct pcn_msg_fxstatat {
+  int fd;
+  int flag;
+  int size;
+  int vers;
+  long st_dev;
+  long st_ino;
+  long st_mode;
+  long st_nlink;
+  long st_uid;
+  long st_gid;
+  long st_rdev;
+  long st_size;
+  long st_blksize;
+  long st_blocks;
+  struct timespec st_atim;
+  struct timespec st_mtim;
+  struct timespec st_ctim;
+  char pathname[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_mmap {
+  void *addr;
+  size_t length;
+  int prot;
+  int flags;
+  int fd;
+  off_t offset;
+} __attribute__ ((packed));
+
+struct pcn_msg_epoll {
+  int ver;
+  int epfd;
+  int arg1;
+  int arg2;
+  char events[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_signal {
+  int sig;
+  int pid;
+  int type;
+} __attribute__ ((packed));
+
+struct pcn_msg_fcntl {
+  int fd;
+  int cmd;
+  void *arg;
+} __attribute__ ((packed));
+
+struct pcn_msg_pipe {
+  int pfds[2];
+  int res;
+  int _errno;
+} __attribute__ ((packed));
+
+struct pcn_msg_socket {
+  int domain;
+  int type;
+  int protocol;
+} __attribute__ ((packed));
+
+struct pcn_msg_sockopt {
+  int sockfd;
+  int level;
+  int optname;
+  int optlen;
+  char optval[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_bind {
+  int sockfd;
+  int addrlen;
+  char addr[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_listen {
+  int sockfd;
+  int backlog;
+} __attribute__ ((packed));
+
+struct pcn_msg_poll {
+  int nfds;
+  int timeout;
+  struct timespec tp;
+  sigset_t sigmask;
+  char fds[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_io_mmap {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_mmap mmap;
+} __attribute__ ((packed));
+
+struct pcn_msg_io_open {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_open open;
+} __attribute__ ((packed));
+
+struct pcn_msg_io_data {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_read data;
+} __attribute__ ((packed));
+
+struct pcn_msg_io_close {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_close close;
+} __attribute__ ((packed));
+
+/* A generic PCN syscall response. */
+struct pcn_msg_res {
+  int res;
+  int id;
+  int rio_errno;
+};
+
+extern int pcn_send (int fd, struct pcn_msg_hdr *hdr);
+extern int pcn_send_iov (int fd, struct pcn_msg_hdr *hdr, struct iovec *payload, int cnt);
+extern void pcn_res (int fd, struct pcn_msg_res *res);
+extern int pcn_msg_ack (int fd, struct pcn_msg_hdr *hdr, int res);
+
+#endif
diff --git a/remote_io/notes.txt b/remote_io/notes.txt
new file mode 100644
index 0000000000..458215d9db
--- /dev/null
+++ b/remote_io/notes.txt
@@ -0,0 +1,21 @@
+redis
+ * ?
+
+xcalc
+ * access
+ * getpeername
+ * recvfrom
+ * recvmsg
+ * uname
+
+Unnecessary
+ * rt_sigprocmask
+
+Maybe?
+ * pread64
+ * sysinfo
+ 
+General
+ * Remove elf/rtld dependencies on remote_io (rio is probably
+   being pulled in from the system call forwarding)
+ * Add memory allocator for rtld
diff --git a/remote_io/pcn-platform.h b/remote_io/pcn-platform.h
new file mode 100644
index 0000000000..a8cf57648b
--- /dev/null
+++ b/remote_io/pcn-platform.h
@@ -0,0 +1,68 @@
+/*
+ * Popcorn-specific platform information.
+ *
+ * Author: Rob Lyerly <rlyerly@vt.edu>
+ * Date: February 13th, 2018
+ */
+
+#ifndef _PLATFORM_H
+#define _PLATFORM_H
+
+/* The size of a page in the system. */
+#define PAGESZ 4096UL
+
+/*
+ * Round down & up to the nearest pages, respectively.  Arguments must be of
+ * unsigned long/uint64_t type.
+ */
+#define PAGE_ROUND_DOWN( x ) ((x) & ~(PAGESZ - 1))
+#define PAGE_ROUND_UP( x ) PAGE_ROUND_DOWN((x) + PAGESZ - 1)
+
+/* The maximum number of nodes supported by the system. */
+#define MAX_POPCORN_NODES 32
+
+/* Status of thread within Popcorn's single system image */
+struct popcorn_thread_status {
+  int current_nid;  /* The thread's current node */
+  int proposed_nid; /* Destination node if somebody proposed migration */
+  int peer_nid;     /* Node ID of peer thread in SSI */
+  int peer_pid;     /* PID of peer thread in SSI */
+};
+
+/*
+ * Return the node ID on which the current thread is executing.
+ * @return the current node ID or -1 otherwise
+ */
+extern int popcorn_getnid(void);
+
+/*
+ * Query thread status information.  Populates the thread status struct with
+ * the current thread's status.
+ *
+ * @param status thread status struct
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+extern int popcorn_getthreadinfo(struct popcorn_thread_status *status);
+
+/* Status of nodes in Popcorn's single system image */
+struct popcorn_node_status {
+  unsigned int status; /* 1 if online, 0 if not */
+  int arch;            /* Architecture of node -- see arch.h */
+  int distance;        /* Hop distance between current and other node */
+};
+
+/*
+ * Query node status information.  Populates the integer passed via pointer
+ * with the ID of the origin node and populates the array of nodes status
+ * structs with their current status.
+ *
+ * @param origin pointer to integer to be set with the origin ID
+ * @param status array of node status structs, must have MAX_POPCORN_NODES
+ *               elements
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+extern int popcorn_getnodeinfo(int *origin,
+                        struct popcorn_node_status status[MAX_POPCORN_NODES]);
+
+#endif /* _PLATFORM_H */
+
diff --git a/remote_io/pcn_accept.c b/remote_io/pcn_accept.c
new file mode 100644
index 0000000000..45734c9ab2
--- /dev/null
+++ b/remote_io/pcn_accept.c
@@ -0,0 +1,57 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_accept (int sockfd, void *addr, int *addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_bind msg;
+  struct iovec payload[2];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_accept_raw (sockfd, addr, addrlen);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_ACCEPT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg) + *addrlen;
+
+  msg.sockfd = sockfd;
+  msg.addrlen = *addrlen;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = addr;
+  payload[1].iov_len = *addrlen;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+  if (res < sizeof (hdr) + hdr.msg_size)
+    lio_error ("%s: failed to send request\n", __FUNCTION__);
+
+  res = lio_get_msg (pd->pcn_server_sockfd, &msg, sizeof (msg));
+  res = lio_get_msg (pd->pcn_server_sockfd, addr, *addrlen);
+
+  if (msg.sockfd < 0)
+    errno = msg.addrlen;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, sockfd, addr, *addrlen, msg.sockfd, msg.addrlen);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  *addrlen = msg.addrlen;
+
+  return msg.sockfd;
+}
diff --git a/remote_io/pcn_bind.c b/remote_io/pcn_bind.c
new file mode 100644
index 0000000000..68322a2902
--- /dev/null
+++ b/remote_io/pcn_bind.c
@@ -0,0 +1,47 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_bind (int sockfd, const void *addr, int addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_bind msg;
+  struct iovec payload[2];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_bind_raw (sockfd, addr, addrlen);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_BIND;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + addrlen;
+
+  msg.sockfd = sockfd;
+  msg.addrlen = addrlen;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = addr;
+  payload[1].iov_len = addrlen;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u\n",
+		  __FUNCTION__, mid, sockfd, addr, addrlen, res);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_close.c b/remote_io/pcn_close.c
new file mode 100644
index 0000000000..8025d0f69e
--- /dev/null
+++ b/remote_io/pcn_close.c
@@ -0,0 +1,66 @@
+/* pcn_open needs to be seperated from rio_open because rtld uses
+   libc_pic.so when linking to establish a map file containing all of
+   the libc dependencies. This is complicated because both rtld and
+   libc use the same open64.c function to implement open64, but we
+   don't want rtld to use pcn_open because the RIO server may not be
+   setup yet. Hence, rio_open needs to be separated from pcn_openat so
+   that it may use malloc, free, and rio_printf.  */
+
+#include <sysdep-cancel.h>
+
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+// TODO: update to close any file descriptors locally if they used by mmap
+int
+pcn_close (int fd)
+{
+  struct pcn_msg_io_close msg;
+  struct pcn_msg_hdr ack;
+  int res;
+  int mid = rio_msg_id ();
+
+  if (!pd->pcn_remote_io_active)
+    return lio_close (fd);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  msg.close.fd = fd;
+
+  msg.hdr.msg_type = PCN_TYPE_SYSCALL;
+  msg.hdr.msg_kind = PCN_SYS_CLOSE;
+  msg.hdr.msg_id = mid;
+  msg.hdr.msg_async = PCN_SEND_NORET;
+  msg.hdr.msg_size = sizeof (msg);
+
+  //rio_dbg_printf ("%s[%u]: closing file descriptor %u\n",
+  //		  __FUNCTION__, mid, fd);
+
+  //rio_dbg_printf ("%s[%u]: sending %u bytes\n", __FUNCTION__, mid, msg.hdr.msg_size);
+  res = pcn_send (pd->pcn_server_sockfd, (struct pcn_msg_hdr *)&msg);
+  if (res < 0)
+    lio_error ("%s[%u]: failed to send close request. res = %u\n",
+	       __FUNCTION__, mid, res);
+
+  res = lio_get_msg (pd->pcn_server_sockfd, &ack, sizeof (struct pcn_msg_hdr));
+  if (res < sizeof (struct pcn_msg_hdr))
+    lio_error ("%s[%u]: failed to receive response from server\n",
+	       __FUNCTION__, mid);
+
+  if (ack.msg_type == PCN_CTL_SYNC)
+    rio_send_file (&ack);
+
+  res = lio_close (fd);
+
+  rio_dbg_printf ("%s[%u]: closed file descriptor %u -- res = %u\n",
+		  __FUNCTION__, mid, fd, ack.msg_size);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_connect.c b/remote_io/pcn_connect.c
new file mode 100644
index 0000000000..9156bbe984
--- /dev/null
+++ b/remote_io/pcn_connect.c
@@ -0,0 +1,48 @@
+#include <string.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_connect (int sockfd, const void *addr, int addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_bind msg;
+  struct iovec payload[2];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_connect_raw (sockfd, addr, addrlen);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_CONNECT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + addrlen;
+
+  msg.sockfd = sockfd;
+  msg.addrlen = addrlen;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = addr;
+  payload[1].iov_len = addrlen;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, sockfd, addr, addrlen, res, errno);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_epoll.c b/remote_io/pcn_epoll.c
new file mode 100644
index 0000000000..cb9613300b
--- /dev/null
+++ b/remote_io/pcn_epoll.c
@@ -0,0 +1,123 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/epoll.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_epoll_create (int size)
+{
+  struct pcn_msg_hdr hdr;
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_epoll_create1 (size);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_EPOLL_CREATE;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (hdr);
+
+  res = pcn_send (pd->pcn_server_sockfd, &hdr);
+
+  rio_dbg_printf ("%s[%u]: size = %u -- res = %u\n", __FUNCTION__, mid, size, res);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
+
+int
+pcn_epoll_ctl (int ver, int epfd, int op, int fd, struct epoll_event *event)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_epoll msg;
+  struct iovec payload[2];
+  ssize_t res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return __do_epoll_ctl (ver, epfd, op, fd, event);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = event;
+  payload[1].iov_len = sizeof (struct epoll_event);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_EPOLL_CTL;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (struct pcn_msg_epoll) + sizeof (struct epoll_event);
+
+  msg.ver = ver;
+  msg.epfd = epfd;
+  msg.arg1 = op;
+  msg.arg2 = fd;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  rio_dbg_printf ("%s[%u]: epfd = %u, op = %x, fd = %u, event = %x -- res = %u\n",
+		  __FUNCTION__, mid, epfd, op, fd, event, res);
+
+  return res;
+}
+
+int
+pcn_epoll_wait (int ver, int epfd, struct epoll_event *events, int maxevents,
+		int timeout)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_epoll msg;
+  struct iovec payload[1];
+  ssize_t res, revents;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return __do_epoll_wait (ver, epfd, events, maxevents, timeout);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_EPOLL_WAIT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (struct pcn_msg_epoll);
+
+  msg.ver = ver;
+  msg.epfd = epfd;
+  msg.arg1 = maxevents;
+  msg.arg2 = timeout;
+
+  revents = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (revents > 0)
+    res = lio_get_msg (pd->pcn_server_sockfd, events,
+		       revents * sizeof (struct epoll_event));
+
+  rio_dbg_printf ("%s[%u]: epfd = %u, events = %x, maxevents = %u, timeout = %u -- res = %u\n",
+		  __FUNCTION__, mid, epfd, events, maxevents, timeout, revents);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return revents;
+}
diff --git a/remote_io/pcn_fallocate.c b/remote_io/pcn_fallocate.c
new file mode 100644
index 0000000000..108b18fc1a
--- /dev/null
+++ b/remote_io/pcn_fallocate.c
@@ -0,0 +1,53 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+ssize_t
+pcn_fallocate (int fd, int mode, off_t offset, off_t len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_fallocate msg;
+  struct iovec payload[1];
+  ssize_t res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_fallocate (fd, mode, offset, len);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  msg.fd = fd;
+  msg.mode = mode;
+  msg.offset = offset;
+  msg.len = len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FALLOCATE;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//_		  FUNCTION__, mid, count, fd, buf);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, mode = %u, offset = %lx, len = %u -- res = %u\n",
+		  __FUNCTION__, mid, fd, mode, offset, len, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_fcntl.c b/remote_io/pcn_fcntl.c
new file mode 100644
index 0000000000..82aaac21b4
--- /dev/null
+++ b/remote_io/pcn_fcntl.c
@@ -0,0 +1,52 @@
+/* At present, the RIO server only supports F_GETFL, F_SETFL,
+   and F_GETFD.  */
+
+#include <fcntl.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_fcntl (int fd, int cmd, void *arg)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_fcntl msg;
+  struct iovec payload[1];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_fcntl (fd, cmd, arg);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  msg.fd = fd;
+  msg.cmd = cmd;
+  msg.arg = arg;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FCNTL;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, cmd = %x, arg = %lx -- res = %x\n",
+		  __FUNCTION__, mid, fd, cmd, arg, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_fxstatat.c b/remote_io/pcn_fxstatat.c
new file mode 100644
index 0000000000..d8db8f33a7
--- /dev/null
+++ b/remote_io/pcn_fxstatat.c
@@ -0,0 +1,80 @@
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+ssize_t
+pcn_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_fxstatat msg, rmsg;
+  struct iovec payload[2];
+  ssize_t res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return __do_fxstatat (vers, fd, file, st, flag);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+//  rio_dbg_printf ("%s[%u]: sizeof (struct stat) = %u\n",
+//		  __FUNCTION__, mid, sizeof (struct stat));
+
+  msg.fd = fd;
+  msg.flag = flag;
+  msg.size = sizeof (msg) + strlen (file) + 1;
+  msg.vers = vers;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)file;
+  payload[1].iov_len = strlen (file) + 1;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FXSTATAT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_ASYNC;
+  hdr.msg_size = msg.size;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+  res = lio_get_msg (pd->pcn_server_sockfd, &rmsg, sizeof (rmsg));
+
+  rio_dbg_printf ("%s[%u]: fd = %u, flag = %x, file = '%s' -> dev = %x, "
+		  "ino = %x, mode = %u, nlink = %x, uid = %x, gid = %x, "
+		  "rdev = %x, size = %u, blksize = %x, blocks = %u\n",
+		  __FUNCTION__, mid, fd, flag, file,
+		  rmsg.st_dev, rmsg.st_ino, rmsg.st_mode,
+		  rmsg.st_nlink, rmsg.st_uid, rmsg.st_gid,
+		  rmsg.st_rdev, rmsg.st_size,
+		  rmsg.st_blksize, rmsg.st_blocks);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  st->st_dev = rmsg.st_dev;
+  st->st_ino = rmsg.st_ino;
+  st->st_mode = rmsg.st_mode;
+  st->st_nlink = rmsg.st_nlink;
+  st->st_uid = rmsg.st_uid;
+  st->st_gid = rmsg.st_gid;
+  st->st_rdev = rmsg.st_dev;
+  st->st_size = rmsg.st_size;
+  st->st_blksize = rmsg.st_blksize;
+  st->st_blocks = rmsg.st_blocks;
+  st->st_atim = rmsg.st_atim;
+  st->st_mtim = rmsg.st_mtim;
+  st->st_ctim = rmsg.st_ctim;
+
+//  rio_dbg_printf ("%s[%u]: res = %u, filesize = %u\n",
+//		  __FUNCTION__, mid, res, st->st_size);
+
+  return res;
+}
diff --git a/remote_io/pcn_getcwd.c b/remote_io/pcn_getcwd.c
new file mode 100644
index 0000000000..b22d7d86ad
--- /dev/null
+++ b/remote_io/pcn_getcwd.c
@@ -0,0 +1,53 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_getcwd (char *buf, size_t size)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_read msg;
+  ssize_t res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_getcwd (buf, size);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_GETCWD;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = size;
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//_		  FUNCTION__, mid, count, fd, buf);
+
+  res = lio_send_msg (pd->pcn_server_sockfd, &hdr, sizeof (hdr));
+
+  res = lio_get_msg (pd->pcn_server_sockfd, &msg, sizeof (msg));
+
+  if (res <= 0)
+    {
+      rio_dbg_printf ("%s[%u]: res = %x\n", __FUNCTION__, mid, res);
+      return res;
+    }
+
+  res = lio_get_msg (pd->pcn_server_sockfd, buf, msg.cnt);
+
+  rio_dbg_printf ("%s[%u]: cwd = %s\n",__FUNCTION__, mid, buf);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_listen.c b/remote_io/pcn_listen.c
new file mode 100644
index 0000000000..b753e1943c
--- /dev/null
+++ b/remote_io/pcn_listen.c
@@ -0,0 +1,49 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_listen (int sockfd, int backlog)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_listen msg;
+  struct iovec payload[1];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_listen (sockfd, backlog);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_LISTEN;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+
+  msg.sockfd = sockfd;
+  msg.backlog = backlog;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, backlog = %u -- res = %u\n",
+		  __FUNCTION__, mid, sockfd, backlog, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_mmap.c b/remote_io/pcn_mmap.c
new file mode 100644
index 0000000000..855659b7a1
--- /dev/null
+++ b/remote_io/pcn_mmap.c
@@ -0,0 +1,192 @@
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+static int
+do_pcn_open_mmap (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_open *omsg = alloca (hdr->msg_size);
+  struct pcn_msg_hdr ack;
+  int newfd, res, flags;
+  char *name;
+
+  ack.msg_id = hdr->msg_id;
+  ack.msg_type = PCN_TYPE_CONTROL;
+  ack.msg_kind = PCN_CTL_ACK;
+  ack.msg_async = PCN_SEND_NORET;
+  ack.msg_size = sizeof (ack);
+
+  pcn_send (fd, &ack);
+
+  res = lio_get_msg (pd->pcn_server_sockfd, omsg, hdr->msg_size);
+  if (res < hdr->msg_size)
+    lio_error ("%s[%u]: failed to recive response from the remote_io server\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+//  rio_dbg_printf ("%s: hdr = { kind = %u, type = %u, id = %u, size = %u }\n",
+//		  __FUNCTION__, hdr->msg_kind, hdr->msg_type, hdr->msg_id,
+//		  hdr->msg_size);
+  rio_dbg_printf ("%s[%u]: res = { dirfd = %u, flags = %u, mode = %u, "
+		  "pathname = %s }\n",
+		  __FUNCTION__, hdr->msg_id, omsg->dirfd, omsg->flags, omsg->mode,
+		  omsg->pathname);
+
+  // Handle the case where the server has to transfer a file over the wire.
+  if (omsg->dirfd < 0)
+    omsg->dirfd = rio_get_file (omsg, pd->pcn_server_sockfd);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  rio_dbg_printf ("%s: mapping '%s', flags = %u\n", __FUNCTION__,
+		  omsg->pathname, omsg->flags);
+
+  flags = omsg->flags & ~(O_CREAT|O_TRUNC);
+
+  newfd = lio_open (omsg->pathname, flags, 0);
+
+  if (newfd != omsg->dirfd)
+    {
+      dup2 (newfd, omsg->dirfd);
+      lio_close (newfd);
+      newfd = omsg->dirfd;
+    }
+
+  return newfd;
+}
+
+void *
+pcn_mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
+{
+  struct pcn_msg_io_mmap msg;
+  struct pcn_msg_hdr hdr, ack;
+  struct pcn_msg_open omsg;
+  struct iovec payload[1];
+  ssize_t res = 0;
+  char *name;
+  int newfd = -1;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_mmap (addr, length, prot, flags, fd, offset);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  /* Don't need to disturb the server if this is an anonymous mapping.  */
+  if (flags & MAP_ANONYMOUS || flags & MAP_ANON)
+    return lio_mmap (addr, length, prot, flags, fd, offset);
+
+  msg.mmap.addr = addr;
+  msg.mmap.length = length;
+  msg.mmap.prot = prot;
+  msg.mmap.flags = flags;
+  msg.mmap.fd = fd;
+  msg.mmap.offset = offset;
+
+  msg.hdr.msg_type = PCN_TYPE_SYSCALL;
+  msg.hdr.msg_kind = PCN_SYS_MMAP;
+  msg.hdr.msg_id = mid;
+  msg.hdr.msg_async = PCN_SEND_NORET;
+  msg.hdr.msg_size = sizeof (msg);
+
+  rio_dbg_printf ("%s[%u]: addr = %lx, len = %lu, prot = %u, flags = %u, "
+		  "fd = %u, offset = %lx\n",
+		  __FUNCTION__, mid, addr, length, prot, flags, fd, offset);
+
+  res = pcn_send (pd->pcn_server_sockfd, (struct pcn_msg_hdr *)&msg);
+  if (res < 0)
+    lio_error ("%s[%u]: failed to send request to the remote_io server\n",
+	       __FUNCTION__, mid);
+
+  res = lio_get_msg (pd->pcn_server_sockfd, &hdr, sizeof (hdr));
+  if (res < sizeof (hdr))
+    lio_error ("%s[%u]: failed to receive response from server\n",
+	       __FUNCTION__, mid);
+
+  /* Has the file already been opened?   */
+  if (hdr.msg_type == PCN_TYPE_RES && hdr.msg_kind == PCN_SYS_OPEN)
+    newfd = do_pcn_open_mmap (&hdr, fd);
+  else if (hdr.msg_type == PCN_TYPE_CONTROL && hdr.msg_kind == PCN_CTL_ACK)
+    newfd = hdr.msg_size;
+  else
+    lio_error ("%s[%u]: unexpected response from remote i/o server\n",
+	       __FUNCTION__, mid);
+
+  LIO_ASSERT (newfd == fd, "mismatched file descriptors\n");
+
+  msg.mmap.addr = lio_mmap (addr, length, prot, flags, fd, offset);
+
+  res = lio_write (pd->pcn_server_sockfd, &msg.mmap.addr, sizeof (long));
+
+//  int count;
+//  ioctl (pd->pcn_server_sockfd, FIONREAD, &count);
+//  rio_dbg_printf ("%s[%u]: pending message bytes = %u\n", __FUNCTION__, mid, count);
+
+  lio_get_msg (pd->pcn_server_sockfd, &ack, sizeof (ack));
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return msg.mmap.addr;
+}
+
+/* RTL: Add a munmap wrapper in sysdeps/unix/sysv/linux/munmap.c and
+   call pcn_munmap.  */
+int
+pcn_munmap(void *addr, size_t length)
+{
+  struct pcn_msg_hdr hdr, ack;
+  struct pcn_msg_mmap msg = {0};
+  struct iovec payload[1];
+  ssize_t res = 0;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_munmap (addr, length);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  msg.addr = addr;
+  msg.length = length;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_MUNMAP;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg);
+
+  rio_dbg_printf ("%s[%u]: addr = %lx, len = %lu\n",
+		  __FUNCTION__, mid, addr, length);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, PCN_SEND_ASYNC);
+  if (res < 0)
+    lio_error ("%s[%u]: failed to unmap file", __FUNCTION__, mid);
+
+  res = lio_get_msg (pd->pcn_server_sockfd, &ack, sizeof (hdr));
+  if (res < 0)
+    lio_error ("%s[%u]: failed to unmap file", __FUNCTION__, mid);
+
+  if (ack.msg_type == PCN_CTL_SYNC)
+    rio_send_file (&ack);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return lio_munmap (addr, length);
+}
diff --git a/remote_io/pcn_open.c b/remote_io/pcn_open.c
new file mode 100644
index 0000000000..0d323f5232
--- /dev/null
+++ b/remote_io/pcn_open.c
@@ -0,0 +1,58 @@
+/* pcn_open needs to be seperated from rio_open because rtld uses
+   libc_pic.so when linking to establish a map file containing all of
+   the libc dependencies. This is complicated because both rtld and
+   libc use the same open64.c function to implement open64, but we
+   don't want rtld to use pcn_open because the RIO server may not be
+   setup yet. Hence, rio_open needs to be separated from pcn_openat so
+   that it may use malloc, free, and rio_printf.  */
+
+#include <sysdep-cancel.h>
+
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_openat(int dirfd, const char *pathname, int flags, mode_t mode)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  struct pcn_msg_open msg;
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_openat (dirfd, pathname, flags, mode);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  msg.flags = flags;
+  msg.mode = mode;
+  msg.dirfd = dirfd;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  payload[1].iov_base = (void *)pathname;
+  payload[1].iov_len = strlen (pathname) + 1;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_OPEN;
+  hdr.msg_id = mid;
+  hdr.msg_async = 0;
+  hdr.msg_size = sizeof (msg) + strlen (pathname) + 1;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: pathname = %s, flags = %x, mode = %x, dirfd = %x -- res = %u\n",
+		  __FUNCTION__, mid, pathname, msg.flags, msg.mode, msg.dirfd, res);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_pipe.c b/remote_io/pcn_pipe.c
new file mode 100644
index 0000000000..1a7f0690e7
--- /dev/null
+++ b/remote_io/pcn_pipe.c
@@ -0,0 +1,56 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_pipe (int pfds[2], int flags)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_pipe msg;
+  ssize_t res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_pipe2 (pfds, flags);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_PIPE;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = flags;
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//_		  FUNCTION__, mid, count, fd, buf);
+
+  res = lio_send_msg (pd->pcn_server_sockfd, &hdr, sizeof (hdr));
+
+  res = lio_get_msg (pd->pcn_server_sockfd, &msg, sizeof (msg));
+
+  if (res < 0 || msg.res)
+    {
+      rio_dbg_printf ("%s[%u]: failed to create pipe - %x / %x\n",
+		      __FUNCTION__, mid, res, msg.res, msg._errno);
+      return msg.res;
+    }
+
+  pfds[0] = msg.pfds[0];
+  pfds[1] = msg.pfds[1];
+
+  rio_dbg_printf ("%s[%u]: flags = %x, pdfs = [%u, %u]\n",
+		  __FUNCTION__, mid, flags, pfds[0], pfds[1]);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return msg.res;
+}
diff --git a/remote_io/pcn_poll.c b/remote_io/pcn_poll.c
new file mode 100644
index 0000000000..28da2379ac
--- /dev/null
+++ b/remote_io/pcn_poll.c
@@ -0,0 +1,101 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <poll.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+static int
+do_pcn_poll (int syscall, int mid, struct pollfd *fds, int nfds, int timeout,
+	     const struct timespec *tp, const sigset_t *sigmask)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_poll *msg;
+  struct iovec payload[2];
+  int res, fdsize, msg_size;
+
+  fdsize = sizeof (struct pollfd) * nfds;
+  msg_size = fdsize + sizeof (struct pcn_msg_poll);
+
+  msg = alloca (msg_size);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = syscall;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = msg_size;
+
+  msg->nfds = nfds;
+  msg->timeout = timeout;
+
+  if (tp == NULL)
+    lio_memset (&msg->tp, 0, sizeof (struct timespec));
+  else
+    msg->tp = *tp;
+
+  if (sigmask == NULL)
+    sigemptyset (&msg->sigmask);
+  else
+    msg->sigmask = *sigmask;
+
+  payload[0].iov_base = msg;
+  payload[0].iov_len = sizeof (struct pcn_msg_poll);
+  payload[1].iov_base = fds;
+  payload[1].iov_len = fdsize;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  lio_get_msg (pd->pcn_server_sockfd, msg, msg_size);
+
+  lio_memcpy (fds, msg->fds, fdsize);
+
+  res = msg->nfds;
+
+  return mid;
+}
+
+int
+pcn_poll (struct pollfd *fds, int nfds, int timeout)
+{
+  int res, mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_poll (fds, nfds, timeout);
+
+  res = do_pcn_poll (PCN_SYS_POLL, mid, fds, nfds, timeout,
+		     NULL, NULL);
+
+  rio_dbg_printf ("%s[%u]: fds = %lx, nfds = %u, timeout = %u -- res = %u\n",
+		  __FUNCTION__, mid, fds, nfds, timeout, res);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
+
+int
+pcn_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+	   const sigset_t *sigmask)
+{
+  int res, mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_ppoll (fds, nfds, tp, sigmask);
+
+  res = do_pcn_poll (PCN_SYS_PPOLL, mid, fds, nfds, 0,
+		     NULL, NULL);
+
+  rio_dbg_printf ("%s[%u]: fds = %lx, nfds = %u, tp = %x, sigmask = %x -- res = %u\n",
+		  __FUNCTION__, mid, fds, nfds, tp, sigmask, res);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
\ No newline at end of file
diff --git a/remote_io/pcn_read.c b/remote_io/pcn_read.c
new file mode 100644
index 0000000000..f0bf54b994
--- /dev/null
+++ b/remote_io/pcn_read.c
@@ -0,0 +1,54 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+ssize_t
+pcn_read (int fd, void *buf, size_t count)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_read msg;
+  struct iovec payload[1];
+  ssize_t res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_read (fd, buf, count);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  msg.fd = fd;
+  msg.cnt = count;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_READ;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//		  FUNCTION__, mid, count, fd, buf);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (res > 0)
+    lio_get_msg (pd->pcn_server_sockfd, buf, res);
+
+  rio_dbg_printf ("%s[%u]: read %u from fd %u into %lx -- res = %u\n",
+		  __FUNCTION__, mid, count, fd, buf, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_send.c b/remote_io/pcn_send.c
new file mode 100644
index 0000000000..4a3eb9a393
--- /dev/null
+++ b/remote_io/pcn_send.c
@@ -0,0 +1,105 @@
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+
+static int
+do_pcn_send_iov (int fd, struct pcn_msg_hdr *hdr, struct iovec *payload, int cnt)
+{
+  int size = 0;
+  int i, res;
+  struct iovec out[cnt+1];
+
+  for (i = 0; i < cnt; i++)
+    size += payload[i].iov_len;
+
+  out[0].iov_base = hdr;
+  out[0].iov_len = sizeof (struct pcn_msg_hdr);
+
+  for (i = 1; i <= cnt; i++) {
+    out[i].iov_base = payload[i-1].iov_base;
+    out[i].iov_len = payload[i-1].iov_len;
+  }
+
+//  rio_dbg_printf ("%s[%u]: sending message type=%u, kind=%u, size=%u\n",
+//		  __FUNCTION__, hdr->msg_id, hdr->msg_type, hdr->msg_kind, hdr->msg_size);
+
+  /* This write will terminate with a SIGPIPE if the connection
+     between the client and the host has closed unexpectedly.  */
+  res = lio_writev (fd, out, cnt + 1);
+
+//  rio_printf ("%s: sent %d bytes\n", __FUNCTION__, res);
+
+  return res;
+}
+
+int
+pcn_send_iov (int fd, struct pcn_msg_hdr *hdr, struct iovec *payload, int cnt)
+{
+  struct pcn_msg_res rio_res;
+  int res = 0;
+
+  res = do_pcn_send_iov (fd, hdr, payload, cnt);
+
+  if (hdr->msg_async == PCN_SEND_SYNC)
+  {
+    res = lio_read (fd, &rio_res, sizeof (rio_res));
+
+//    rio_dbg_printf ("%s[%u]: res = %u, errno = %x, id = %u, (%u / %u)\n",
+//		    __FUNCTION__, hdr->msg_id, rio_res.res, rio_res.rio_errno, rio_res.id,
+//		    res, sizeof (rio_res));
+
+    errno = rio_res.rio_errno;
+    res = rio_res.res;
+  }
+
+  return res;
+}
+
+int
+pcn_send (int fd, struct pcn_msg_hdr *hdr)
+{
+  struct pcn_msg_res rio_res;
+  int res;
+
+  res = lio_write (fd, hdr, hdr->msg_size);
+  //rio_dbg_printf ("%s[%u]: sent %x bytes\n", __FUNCTION__, hdr->msg_id, res);
+
+  if (hdr->msg_async == PCN_SEND_SYNC)
+  {
+    res = lio_read (fd, &rio_res, sizeof (rio_res));
+
+//    rio_dbg_printf ("%s[%u]: res = %x, errno = %x\n",
+//		    __FUNCTION__, hdr->msg_id, rio_res.res, rio_res.rio_errno);
+
+    errno = rio_res.rio_errno;
+    res = rio_res.res;
+  }
+
+  return res;
+}
+
+/* This should eventually use the generic message sending framework
+   to handle ASYNC messages more gracefully.  */
+void
+pcn_res (int fd, struct pcn_msg_res *res)
+{
+  lio_write (fd, res, sizeof (*res));
+}
+
+int
+pcn_msg_ack (int sockfd, struct pcn_msg_hdr *hdr, int res)
+{
+  struct pcn_msg_hdr ack;
+
+  ack.msg_kind = PCN_TYPE_CONTROL;
+  ack.msg_type = PCN_CTL_ACK;
+  ack.msg_id = hdr->msg_id;
+  ack.msg_size = res;
+
+  return lio_write (sockfd, &ack, sizeof (ack));
+}
diff --git a/remote_io/pcn_sigaction.c b/remote_io/pcn_sigaction.c
new file mode 100644
index 0000000000..76101c5492
--- /dev/null
+++ b/remote_io/pcn_sigaction.c
@@ -0,0 +1,113 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <signal.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_sigaction (int sig, const struct sigaction *act, struct sigaction *oacc, int size)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_signal msg;
+  struct iovec payload[1];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_rt_sigaction (sig, act, oacc, size);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_RT_SIGACTION;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+
+  msg.pid = 0;
+  msg.sig = sig;
+  msg.type = PCN_SIG_ADD;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, &payload, 1);
+
+  rio_dbg_printf ("%s[%u]: signal = %u -> res = %u\n", __FUNCTION__, mid, sig, res);
+
+  // Register the signal handler in dl_pcn_data
+  pd->rio_sa_active |= (1LL << msg.sig);
+  pd->rio_sa_sigs[msg.sig].pcn_sa_handler = act->sa_sigaction;
+  pd->rio_sa_sigs[msg.sig].pcn_sa_mask = *(unsigned long *)&act->sa_mask;
+  pd->rio_sa_sigs[msg.sig].pcn_sa_flags = act->sa_flags;
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return lio_rt_sigaction (sig, act, oacc, size);
+}
+
+int
+pcn_unload_signals (void)
+{
+  int i;
+  int status = pd->pcn_remote_io_active;
+
+  pd->pcn_remote_io_active = 0;
+
+  for (i = 0; i < PCN_NSIG; i++)
+    {
+      uint64_t sig = (1L << i);
+
+      if (pd->rio_sa_active & sig)
+        {
+          struct sigaction dfl;
+
+          rio_dbg_printf ("%s: removing signal '%u'\n", __FUNCTION__, i);
+
+          sigemptyset (&dfl.sa_mask);
+          sigaddset (&dfl.sa_mask, i);
+          dfl.sa_flags = 0;
+          sigaction (i, &dfl, NULL);
+        }
+    }
+
+  pd->pcn_remote_io_active = status;
+
+  return status;
+}
+
+int
+pcn_restore_signals (void)
+{
+  int i;
+  int status = pd->pcn_remote_io_active;
+
+  pd->pcn_remote_io_active = 0;
+
+  for (i = 0; i < PCN_NSIG; i++)
+    {
+      uint64_t sig = (1L << i);
+
+      if (pd->rio_sa_active & sig)
+        {
+          struct sigaction act;
+
+          rio_dbg_printf ("%s: restoring signal '%u'\n", __FUNCTION__, i);
+
+          lio_memcpy (&act.sa_mask, &pd->rio_sa_sigs[i].pcn_sa_mask, sizeof (long));
+          act.sa_flags = pd->rio_sa_sigs[i].pcn_sa_flags;
+          act.sa_handler = pd->rio_sa_sigs[i].pcn_sa_handler;
+          sigaction (i, &act, NULL);
+        }
+    }
+
+  pd->pcn_remote_io_active = status;
+
+  return status;
+}
diff --git a/remote_io/pcn_socket.c b/remote_io/pcn_socket.c
new file mode 100644
index 0000000000..480a190c3a
--- /dev/null
+++ b/remote_io/pcn_socket.c
@@ -0,0 +1,140 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+#include <errno.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+int
+pcn_socket (int domain, int type, int protocol)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_socket msg;
+  struct iovec payload[1];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_socket (domain, type, protocol);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SOCKET;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+
+  msg.domain = domain;
+  msg.type = type;
+  msg.protocol = protocol;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 1);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  rio_dbg_printf ("%s[%u]: domain = %x, type = %x, protocol = %x -- res = %u\n",
+		  __FUNCTION__, mid, domain, type, protocol, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  return res;
+}
+
+int
+pcn_setsockopt (int fd, int level, int optname, const void *optval,
+		int len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_sockopt msg;
+  struct iovec payload[2];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_setsockopt (fd, level, optname, optval, len);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SETSOCKOPT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + len;
+
+  msg.sockfd = fd;
+  msg.level = level;
+  msg.optname = optname;
+  msg.optlen = len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = optval;
+  payload[1].iov_len = len;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %u\n",
+		  __FUNCTION__, mid, fd, level, optname, optval, len, res);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
+
+int
+pcn_getsockopt (int fd, int level, int optname, const void *optval,
+		int *len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_sockopt msg, *rmsg;
+  struct iovec payload[2];
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_setsockopt (fd, level, optname, optval, len);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_GETSOCKOPT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg) + *len;
+
+  msg.sockfd = fd;
+  msg.level = level;
+  msg.optname = optname;
+  msg.optlen = *len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = optval;
+  payload[1].iov_len = *len;
+
+  rmsg = alloca (hdr.msg_size);
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  res = lio_get_msg (pd->pcn_server_sockfd, rmsg, hdr.msg_size);
+
+  res = rmsg->sockfd;
+  errno = rmsg->level;
+  lio_memcpy (optval, rmsg->optval, rmsg->optlen);
+  *len = rmsg->optlen;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %u\n",
+		  __FUNCTION__, mid, fd, level, optname, optval, *len, res);
+
+  lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
\ No newline at end of file
diff --git a/remote_io/platform.c b/remote_io/platform.c
new file mode 100644
index 0000000000..e4ce5b1905
--- /dev/null
+++ b/remote_io/platform.c
@@ -0,0 +1,20 @@
+#include <errno.h>
+#include "pcn-platform.h"
+
+int popcorn_getnid(void)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+int popcorn_getthreadinfo(struct popcorn_thread_status *a)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+int popcorn_getnodeinfo(int *a, struct popcorn_node_status *b)
+{
+  errno = ENOSYS;
+  return -1;
+}
diff --git a/remote_io/platform.h b/remote_io/platform.h
new file mode 100644
index 0000000000..1690818300
--- /dev/null
+++ b/remote_io/platform.h
@@ -0,0 +1,68 @@
+/*
+ * Popcorn-specific platform information.
+ *
+ * Author: Rob Lyerly <rlyerly@vt.edu>
+ * Date: February 13th, 2018
+ */
+
+#ifndef _PLATFORM_H
+#define _PLATFORM_H
+
+/* The size of a page in the system. */
+#define PAGESZ 4096UL
+
+/*
+ * Round down & up to the nearest pages, respectively.  Arguments must be of
+ * unsigned long/uint64_t type.
+ */
+#define PAGE_ROUND_DOWN( x ) ((x) & ~(PAGESZ - 1))
+#define PAGE_ROUND_UP( x ) PAGE_ROUND_DOWN((x) + PAGESZ - 1)
+
+/* The maximum number of nodes supported by the system. */
+#define MAX_POPCORN_NODES 32
+
+/* Status of thread within Popcorn's single system image */
+struct popcorn_thread_status {
+  int current_nid;  /* The thread's current node */
+  int proposed_nid; /* Destination node if somebody proposed migration */
+  int peer_nid;     /* Node ID of peer thread in SSI */
+  int peer_pid;     /* PID of peer thread in SSI */
+};
+
+/*
+ * Return the node ID on which the current thread is executing.
+ * @return the current node ID or -1 otherwise
+ */
+int popcorn_getnid();
+
+/*
+ * Query thread status information.  Populates the thread status struct with
+ * the current thread's status.
+ *
+ * @param status thread status struct
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+int popcorn_getthreadinfo(struct popcorn_thread_status *status);
+
+/* Status of nodes in Popcorn's single system image */
+struct popcorn_node_status {
+  unsigned int status; /* 1 if online, 0 if not */
+  int arch;            /* Architecture of node -- see arch.h */
+  int distance;        /* Hop distance between current and other node */
+};
+
+/*
+ * Query node status information.  Populates the integer passed via pointer
+ * with the ID of the origin node and populates the array of nodes status
+ * structs with their current status.
+ *
+ * @param origin pointer to integer to be set with the origin ID
+ * @param status array of node status structs, must have MAX_POPCORN_NODES
+ *               elements
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+int popcorn_getnodeinfo(int *origin,
+                        struct popcorn_node_status status[MAX_POPCORN_NODES]);
+
+#endif /* _PLATFORM_H */
+
diff --git a/remote_io/popcorn_killd.c b/remote_io/popcorn_killd.c
new file mode 100644
index 0000000000..c014432470
--- /dev/null
+++ b/remote_io/popcorn_killd.c
@@ -0,0 +1,406 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <unistd.h>
+#include <signal.h>
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <assert.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <poll.h>
+
+#include <sys/syscall.h>
+
+#include <elf/popcorn.h>
+#include "message.h"
+#include "local_io.h"
+#include "server.h"
+
+#define OPT_KILL (1 << 0)
+#define OPT_CLIENT (1 << 1)
+#define OPT_SIGNAL (1 << 2)
+
+#define BACKLOG 3
+
+int daemonize = 1;
+int verbose = 0;
+int port = POPCORN_KILLD_PORT;
+
+void
+print_help (char *execname)
+{
+  printf ("%s options:\n", execname);
+  printf ("  -c -> client mode; send kill message to server\n");
+  printf ("  -i [string] -> ip address of the server\n");
+  printf ("  -k -> terminate an active daemon\n");
+  printf ("  -p [int] -> port to listen for signal requests\n");
+  printf ("  -P [int] -> pid to forward a signal to\n");
+  printf ("  -s -> run in standalone mode, without spawning a daemon\n");
+  printf ("  -S [int] -> signal to send\n");
+  printf ("  -v -> emit verbose diagnostics\n");
+  printf ("  -h -> print usage\n");
+}
+
+int
+get_msg (int sock, void *buf, int size)
+{
+  int cnt = 0;
+  int res;
+
+  while (cnt < size)
+  {
+    res = read (sock, &((char *)buf)[cnt], size - cnt);
+
+    if (res <= 0)
+      {
+	//rio_printf ("%s: error - lost data (%d -> %d/%d) - %d\n",
+	//	    __FUNCTION__, size, cnt, res, errno);
+	return res;
+      }
+
+      cnt += res;
+  }
+
+  return cnt;
+}
+
+void
+terminate_daemon (void)
+{
+  struct pcn_msg_signal msg;
+  struct addrinfo hints, *ai;
+  uint32_t myip = pcn_get_ip ();
+  int sockfd, res;
+  char s_addr[INET_ADDRSTRLEN];
+  char buf[INET_ADDRSTRLEN], *s_port;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  inet_ntop (AF_INET, &myip, s_addr, INET_ADDRSTRLEN);
+  snprintf (buf, INET_ADDRSTRLEN, "%d", POPCORN_KILLD_PORT);
+  s_port = buf;
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0)
+    {
+      printf ("getaddrinfo: %s\n", gai_strerror (res));
+      exit (EXIT_FAILURE);
+    }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      exit (EXIT_FAILURE);
+    }
+
+  if (connect (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      perror ("connection failed");
+      printf ("   -> %s:%s\n", s_addr, s_port);
+      exit (EXIT_FAILURE);
+    }
+
+  freeaddrinfo (ai);
+
+  msg.pid = 0;
+  msg.sig = SIGKILL;
+  msg.type = PCN_SIG_SHUTDOWN;
+
+  write (sockfd, &msg, sizeof (msg));
+  close (sockfd);
+}
+
+void
+forward_signal (int sig, int pid, uint32_t ip)
+{
+  struct pcn_msg_signal msg;
+  struct addrinfo hints, *ai;
+  int sockfd, res;
+  char s_addr[INET_ADDRSTRLEN];
+  char buf[INET_ADDRSTRLEN], *s_port;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  inet_ntop (AF_INET, &ip, s_addr, INET_ADDRSTRLEN);
+  snprintf (buf, INET_ADDRSTRLEN, "%d", POPCORN_KILLD_PORT);
+  s_port = buf;
+
+  if (verbose)
+    printf ("Sending signal '%d' to pid '%d' @ ip = '%x'\n", sig, pid, ip);
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0)
+    {
+      printf ("getaddrinfo: %s\n", gai_strerror (res));
+      exit (EXIT_FAILURE);
+    }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      exit (EXIT_FAILURE);
+    }
+
+  if (connect (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      perror ("connection failed");
+      printf ("   -> %s:%s\n", s_addr, s_port);
+      exit (EXIT_FAILURE);
+    }
+
+  freeaddrinfo (ai);
+
+  msg.pid = pid;
+  msg.sig = sig;
+  msg.type = PCN_SIG_KILL;
+
+  write (sockfd, &msg, sizeof (msg));
+
+  close (sockfd);
+}
+
+int
+init_network (void)
+{
+  uint32_t myip = pcn_get_ip ();
+  int sockfd = -1;
+  struct addrinfo hints, *ai;
+  int res;
+  char buf[INET_ADDRSTRLEN], *s_addr = NULL, *s_port = NULL;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  snprintf (buf, INET_ADDRSTRLEN, "%d", POPCORN_KILLD_PORT);
+  s_port = buf;
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0)
+    {
+      printf ("getaddrinfo: %s\n", gai_strerror (res));
+      exit (EXIT_FAILURE);
+    }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      exit (EXIT_FAILURE);
+    }
+
+  if (bind (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      perror ("connection failed");
+      printf ("   -> %s:%s\n", s_addr, s_port);
+      exit (EXIT_FAILURE);
+    }
+
+  if (listen (sockfd, 2) == -1) {
+    perror ("listen");
+    exit (EXIT_FAILURE);
+  }
+
+  freeaddrinfo (ai);
+
+  return sockfd;
+}
+
+void
+event_loop (int sockfd)
+{
+  struct pollfd pfds[3];
+  int fd_count = 1;
+
+  pfds[0].fd = sockfd;
+  pfds[0].events = POLLIN;
+
+  while (1)
+    {
+      int poll_count = poll (pfds, fd_count, -1);
+      struct sockaddr_storage remoteaddr;
+      socklen_t addrlen;
+      int i;
+
+      if (poll_count == -1)
+	{
+	  perror ("poll");
+	  exit (EXIT_FAILURE);
+	}
+
+      for (i = 0; i < fd_count; i++)
+	{
+	  if (pfds[i].revents & POLLIN)
+	    {
+	      int res;
+
+	      if (pfds[i].fd == sockfd)
+		{
+		  addrlen = sizeof (remoteaddr);
+		  int client = accept (sockfd, (struct sockaddr *)&remoteaddr,
+				       &addrlen);
+
+		  if (client < 0)
+		    perror ("Failed to accept client");
+		  else
+		    {
+		      char buf[INET_ADDRSTRLEN];
+		      struct sockaddr_in *sin = (struct sockaddr_in *)&remoteaddr;
+
+		      if (verbose)
+			{
+			  inet_ntop (remoteaddr.ss_family, &sin->sin_addr, buf,
+				     INET_ADDRSTRLEN);
+			  printf ("Accepted client %s\n", buf);
+			}
+
+		      pfds[fd_count].fd = client;
+		      pfds[fd_count].events = POLLIN;
+		      pfds[fd_count].revents = 0;
+		      fd_count++;
+
+		      continue;
+		    }
+		}
+
+	      struct pcn_msg_signal msig;
+
+	      get_msg (pfds[i].fd, &msig, sizeof (msig));
+
+	      if (msig.type == PCN_SIG_SHUTDOWN)
+		{
+		  if (verbose)
+		    printf ("Terminating popcorn_killd\n");
+
+		  exit (EXIT_SUCCESS);
+		}
+
+	      if (verbose)
+		printf ("Forwarding signal '%d' to pid '%d'\n", msig.sig, msig.pid);
+
+	      kill (msig.pid, msig.sig);
+	      close (pfds[i].fd);
+
+	      fd_count--;
+	    }
+	}
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int c;
+  int options = 0;
+  char *hostaddr = NULL;
+  int sig = -1, pid = -1;
+  int sockfd;
+  uint32_t ip = 0;
+
+  /* Deactivate the RIO server.  */
+  static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+  pd->pcn_remote_io_active = 0;
+  close (pd->pcn_server_sockfd);
+
+  while ((c = getopt (argc, argv, "cki:hp:P:sS:v")) != -1)
+    switch (c)
+      {
+      case 'c':
+	options |= OPT_CLIENT;
+	break;
+
+      case 'k':
+	options |= OPT_KILL;
+	break;
+
+      case 'i':
+	hostaddr = strdup (optarg);
+	break;
+
+      case 'p':
+	port = atoi (optarg);
+	break;
+
+      case 'P':
+	pid = atoi (optarg);
+	break;
+
+      case 's':
+	daemonize = 0;
+	break;
+
+      case 'S':
+	options |= OPT_SIGNAL;
+	sig = atoi (optarg);
+	break;
+
+      case 'v':
+	verbose = 1;
+	break;
+
+      case 'h':
+      default:
+	print_help (argv[0]);
+	exit (EXIT_SUCCESS);
+      }
+
+  if (hostaddr != NULL)
+    {
+      ip = inet_addr (hostaddr);
+
+      if (verbose)
+	printf ("ip = %x\n", ip);
+
+      if (ip == INADDR_NONE)
+        {
+	  printf ("Error: Invalid IP address\n");
+	  exit (EXIT_FAILURE);
+	}
+    }
+
+  if (options & OPT_KILL)
+    {
+      terminate_daemon ();
+      exit (EXIT_SUCCESS);
+    }
+  else if (options & OPT_SIGNAL)
+    {
+      if (ip != 0)
+        {
+          forward_signal (sig, pid, ip);
+	  exit (EXIT_SUCCESS);
+	}
+
+      if (verbose)
+	printf ("Sending signal '%d' to pid '%d'\n", sig, pid);
+
+      kill (pid, sig);
+      exit (EXIT_SUCCESS);
+    }
+
+  if (daemonize && fork () != 0)
+    exit (EXIT_SUCCESS);
+
+  sockfd = init_network ();
+
+  event_loop (sockfd);
+
+  return 0;
+}
diff --git a/remote_io/remote_io.h b/remote_io/remote_io.h
new file mode 100644
index 0000000000..1579b66b33
--- /dev/null
+++ b/remote_io/remote_io.h
@@ -0,0 +1,78 @@
+#ifndef REMOTE_IO_H
+#define REMOTE_IO_H
+
+#include <stdarg.h>
+#include <stdint.h>
+#include <sys/uio.h>
+
+extern int pcn_remote_io_active;
+
+struct epoll_event;
+struct sigaction;
+struct pollfd;
+
+/* On a server process, pcn_server_sockfd represents the socket connection
+ * to the primary server if necessary. pcn_client_sockfd represents the
+ * connection to the client.
+ *
+ * On the local application, pcn_server_sockfd represents the socket
+ * connection to the local server, and pcn_client_sockfd is unused.
+ */
+//extern int pcn_server_sockfd;
+//extern int pcn_client_sockfd;
+//extern uint32_t pcn_local_ip;
+
+#define PCN_SERVER_INIT 1
+#define PCN_SERVER_READY 2
+
+extern ssize_t pcn_read(int fd, void *buf, size_t count);
+//extern ssize_t pcn_readv (int fd, const struct iovec *iov, int iovecnt);
+extern ssize_t pcn_write (int fd, const void *buf, size_t count);
+extern ssize_t pcn_writev (int fd, const struct iovec *iov, int iovecnt);
+extern int pcn_close(int fd);
+extern int pcn_openat(int dirfd, const char *pathname, int flags, mode_t mode);
+//extern int pcn_creat(const char *pathname, mode_t mode);
+extern ssize_t pcn_fxstatat(int vers, int fd, const char *file,
+			    struct stat *st, int flag);
+extern void *pcn_mmap(void *addr, size_t length, int prot, int flags,
+                      int fd, off_t offset);
+extern int pcn_munmap(void *addr, size_t length);
+extern int pcn_epoll_create (int size);
+extern int pcn_epoll_ctl (int ver, int epfd, int op, int fd,
+			  struct epoll_event *event);
+extern int pcn_epoll_wait (int ver, int epfd, struct epoll_event *events,
+			   int maxevents, int timeout);
+extern int pcn_poll (struct pollfd *fds, int nfds, int timeout);
+extern int pcn_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+		      const sigset_t *sigmask);
+extern int pcn_sigaction (int sig, const struct sigaction *act,
+			  struct sigaction *oacc, int size);
+extern int pcn_fcntl (int fd, int mode, void *arg);
+extern int pcn_getcwd (char *buf, size_t size);
+extern int pcn_pipe (int pfds[2], int flags);
+
+extern int pcn_socket (int domain, int type, int protocol);
+extern int pcn_getsockopt (int fd, int level, int optname, const void *optval,
+			   int *len);
+extern int pcn_setsockopt (int fd, int level, int optname, const void *optval,
+			   int len);
+extern int pcn_bind (int sockfd, const void *addr, int addrlen);
+extern int pcn_listen (int sockfd, int backlog);
+extern int pcn_accept (int sockfd, void *addr, int *addrlen);
+extern int pcn_connect (int sockfd, const void *addr, int addrlen);
+
+extern int pcn_server_connect (uint32_t ip);
+extern void pcn_start_server (void);
+extern void pcn_migrate (void);
+extern int pcn_unload_signals (void);
+extern int pcn_restore_signals (void);
+
+extern void rio_printf (const char *restrict str, ...);
+extern int rio_dbg_printf (const char *fmt, ...);
+extern int rio_dbg_fprintf (int fd, const char *fmt, ...);
+extern int rio_dbg_snprintf (char *str, size_t size, const char *fmt, ...);
+extern int rio_dbg_vfprintf (int fd, const char *restrict fmt, va_list arg);
+
+extern void dump_pcn_data (void);
+
+#endif
diff --git a/remote_io/rio_accept.c b/remote_io/rio_accept.c
new file mode 100644
index 0000000000..26ce65c196
--- /dev/null
+++ b/remote_io/rio_accept.c
@@ -0,0 +1,50 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_accept (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_bind *msg;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = lio_get_msg (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive accept message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = 0;
+  msg->sockfd = lio_accept_raw (msg->sockfd, (void *)msg->addr, &msg->addrlen);
+  msg->addrlen = errno;
+
+  if (msg->sockfd >= 0)
+    rio_fd_open_special (msg->sockfd, RIO_FD_ACCEPT);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->addr,
+		  msg->addrlen);
+
+  lio_send_msg (fd, msg, hdr->msg_size);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_bind.c b/remote_io/rio_bind.c
new file mode 100644
index 0000000000..6d4b750beb
--- /dev/null
+++ b/remote_io/rio_bind.c
@@ -0,0 +1,48 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_bind (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_bind *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = lio_get_msg (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive bind message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = 0;
+  ack.res = lio_bind_raw (msg->sockfd, (void *)msg->addr, msg->addrlen);
+  ack.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->addr,
+		  msg->addrlen);
+
+  lio_send_msg (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_close.c b/remote_io/rio_close.c
new file mode 100644
index 0000000000..37a725634b
--- /dev/null
+++ b/remote_io/rio_close.c
@@ -0,0 +1,59 @@
+/* open system call forwarding -- open, creat, and openat  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_close (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_close msg;
+  struct fdinfo *fdp;
+  int res, rclose;
+
+  res = lio_get_msg (fd, &msg, sizeof (msg));
+
+  lio_assert_empty_socket (fd);
+
+  fdp = rio_fd_find (msg.fd);
+
+  if (fdp == NULL)
+    lio_error ("%s[%u]: ERROR: missing data for fd = %u\n",
+	       __FUNCTION__, hdr->msg_id, msg.fd);
+
+  if (fdp->maps == 0 && (fdp->status & RIO_FD_DIRTY))
+    rio_file_sync (fd, hdr->msg_id, fdp);
+
+  rclose = lio_close (msg.fd);
+
+  rio_printf ("%s[%u]: closing '%s', fd = %d (mappings = %d) -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, fdp->name, fdp->fd, fdp->maps, rclose, errno);
+
+  rio_fd_rm (fdp);
+
+  fdp->fd = -rand ();
+
+  if (fdp->maps == 0)
+    free (fdp);
+  else
+    rio_fd_add_closed (fdp);
+
+  pcn_msg_ack (fd, hdr, 0);
+
+  return 0;
+}
diff --git a/remote_io/rio_connect.c b/remote_io/rio_connect.c
new file mode 100644
index 0000000000..720b631c05
--- /dev/null
+++ b/remote_io/rio_connect.c
@@ -0,0 +1,48 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_connect (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_bind *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = lio_get_msg (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive bind message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = 0;
+  ack.res = lio_connect_raw (msg->sockfd, (void *)msg->addr, msg->addrlen);
+  ack.rio_errno = errno;
+
+  rio_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg->sockfd, msg->addr,
+	      msg->addrlen, ack.res, errno);
+
+  lio_send_msg (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_epoll.c b/remote_io/rio_epoll.c
new file mode 100644
index 0000000000..9c21b992c6
--- /dev/null
+++ b/remote_io/rio_epoll.c
@@ -0,0 +1,86 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/epoll.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_epoll_create (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res res;
+
+  res.res = lio_epoll_create1 (0);
+  res.rio_errno = errno;
+
+  if (res.res >= 0)
+    rio_fd_open_special (res.res, RIO_FD_EPOLL);
+
+  rio_printf ("%s[%u]: epfd = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, res.res, res.rio_errno);
+
+  pcn_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return res.res;
+}
+
+int
+rio_get_epoll_ctl (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_epoll *msg;
+  struct pcn_msg_res res;
+
+  msg = malloc (sizeof (struct pcn_msg_epoll) + sizeof (struct epoll_event));
+
+  res.res = lio_get_msg (fd, msg, hdr->msg_size);
+
+  res.res = __do_epoll_ctl (msg->ver, msg->epfd, msg->arg1, msg->arg2,
+			    (struct epoll_event *)msg->events);
+
+  res.id = hdr->msg_id;
+  res.rio_errno = errno;
+
+  pcn_res (fd, &res);
+
+  rio_printf ("%s[%u]: epfd = %u, op = %x, fd = %u, ver = %u -> %u\n",
+	      __FUNCTION__, hdr->msg_id, msg->epfd, msg->arg1, msg->arg2,
+	      msg->ver, res.res);
+
+  free (msg);
+
+  return res.res;
+}
+
+int
+rio_get_epoll_wait (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_epoll msg;
+  struct pcn_msg_res res;
+  struct epoll_event *events;
+  
+  res.res = lio_get_msg (fd, &msg, hdr->msg_size);
+
+  events = malloc (sizeof (struct epoll_event) * msg.arg1);
+
+  res.res = __do_epoll_wait (msg.ver, msg.epfd, events, msg.arg1, msg.arg2);
+
+  res.id = hdr->msg_id;
+  res.rio_errno = errno;
+
+  pcn_res (fd, &res);
+
+  rio_printf ("%s[%u]: epfd = %u, maxevents = %u, timeout = %u, ver = %u -> %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.epfd, msg.arg1, msg.arg2,
+	      msg.ver, res.res);
+
+  if (res.res > 0)
+    lio_send_msg (fd, events, res.res * sizeof (struct epoll_event));
+
+  free (events);
+
+  return res.res;
+}
diff --git a/remote_io/rio_fallocate.c b/remote_io/rio_fallocate.c
new file mode 100644
index 0000000000..988a0fe596
--- /dev/null
+++ b/remote_io/rio_fallocate.c
@@ -0,0 +1,43 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_fallocate (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_fallocate msg;
+  struct pcn_msg_res res;
+
+  res.res = lio_get_msg (fd, &msg, hdr->msg_size);
+
+  res.res = lio_fallocate (msg.fd, msg.mode, msg.offset, msg.len);
+
+  rio_printf ("%s[%u]: fd = %u, mode = %u, offset = %lx, len = %u -- res = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.fd, msg.mode, msg.offset,
+	      msg.len, res.res);
+
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  lio_send_msg (fd, &res, sizeof (res));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_fcntl.c b/remote_io/rio_fcntl.c
new file mode 100644
index 0000000000..f8417bf04f
--- /dev/null
+++ b/remote_io/rio_fcntl.c
@@ -0,0 +1,45 @@
+/* fcntl system call forwarding.  At present, the RIO server
+   only supports F_GETFL, F_SETFL, and F_GETFD. */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <fcntl.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_fcntl (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_fcntl msg;
+  struct pcn_msg_res res;
+
+  res.res = lio_get_msg (fd, &msg, hdr->msg_size);
+
+  res.res = lio_fcntl (msg.fd, msg.cmd, msg.arg);
+
+  rio_printf ("%s[%u]: fd = %u, cmd = %x, arg = %lx -- res = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.fd, msg.cmd, msg.fd,
+	      res.res);
+
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  lio_send_msg (fd, &res, sizeof (res));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_fxstatat.c b/remote_io/rio_fxstatat.c
new file mode 100644
index 0000000000..d0c18812a3
--- /dev/null
+++ b/remote_io/rio_fxstatat.c
@@ -0,0 +1,71 @@
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_fxstatat (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_fxstatat *msg = malloc (hdr->msg_size);
+  struct pcn_msg_fxstatat res;
+  struct fdinfo *pfd;
+  struct iovec payload[2];
+  INTERNAL_SYSCALL_DECL (err);
+  struct stat kst;
+
+  res.fd = lio_get_msg (fd, msg, hdr->msg_size);
+
+  pfd = rio_fd_find (msg->fd);
+
+//  rio_printf ("%s[%u]: received fxstatat, size = %d\n",
+//	      __FUNCTION__, hdr->msg_id, hdr->msg_size);
+
+  if (pfd != NULL)
+    rio_printf ("%s[%u]: fd = %u, size = %u, flag = %x, file = '%s' (%s)\n",
+		__FUNCTION__, hdr->msg_id, msg->fd, msg->size, msg->flag,
+		msg->pathname, pfd->name);
+  else
+    rio_printf ("%s[%u]: fd = %u, size = %u, flag = %x, file = '%s'\n",
+		__FUNCTION__, hdr->msg_id, msg->fd, msg->size, msg->flag,
+		msg->pathname);
+
+  res.flag = __do_fxstatat (_STAT_VER, msg->fd, msg->pathname, &kst,
+			    msg->flag);
+  res.fd = errno;
+  res.size = sizeof (struct pcn_msg_fxstatat);
+
+  //rio_printf ("%s[%u]: res = %d, errno = %d\n", __FUNCTION__, hdr->msg_id, res.flag, res.fd);
+  rio_dbg_printf ("%s[%u]: dev = %x, ino = %x, mode = %u, nlink = %x uid = %x, gid = %x, "
+		  "rdev = %x, size = %u, blksize = %x, blocks = %u\n",
+		  __FUNCTION__, hdr->msg_id, kst.st_dev, kst.st_ino,
+		  kst.st_mode, kst.st_nlink, kst.st_uid, kst.st_gid,
+		  kst.st_rdev, kst.st_size, kst.st_blksize, kst.st_blocks);
+
+  res.st_dev = kst.st_dev;
+  res.st_ino = kst.st_ino;
+  res.st_mode = kst.st_mode;
+  res.st_nlink = kst.st_nlink;
+  res.st_uid = kst.st_uid;
+  res.st_gid = kst.st_gid;
+  res.st_rdev = kst.st_rdev;
+  res.st_size = kst.st_size;
+  res.st_blksize = kst.st_blksize;
+  res.st_blocks = kst.st_blocks;
+  res.st_atim = kst.st_atim;
+  res.st_mtim = kst.st_mtim;
+  res.st_ctim = kst.st_ctim;
+
+  lio_write (fd, &res, sizeof (struct pcn_msg_fxstatat));
+
+  free (msg);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_getcwd.c b/remote_io/rio_getcwd.c
new file mode 100644
index 0000000000..6c1a8f5946
--- /dev/null
+++ b/remote_io/rio_getcwd.c
@@ -0,0 +1,41 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_getcwd (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_read *msg;
+  int size = sizeof (struct pcn_msg_read) + hdr->msg_size;
+  int res;
+
+  msg = alloca (size);
+  
+  msg->cnt = lio_getcwd (msg->buf, hdr->msg_size);
+  msg->fd = errno;
+
+  res = lio_send_msg (fd, msg, sizeof (struct pcn_msg_read) + msg->cnt);
+
+  rio_dbg_printf ("%s[%u]: pathname = '%s' -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->buf, msg->cnt);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_listen.c b/remote_io/rio_listen.c
new file mode 100644
index 0000000000..1d057164cd
--- /dev/null
+++ b/remote_io/rio_listen.c
@@ -0,0 +1,45 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_listen (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_listen msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  res = lio_get_msg (fd, &msg, sizeof (msg));
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive listen message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  ack.res = lio_listen (msg.sockfd, msg.backlog);
+  ack.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, backlog = %u -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg.sockfd, msg.backlog,
+		  ack.res);
+
+  lio_send_msg (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_mmap.c b/remote_io/rio_mmap.c
new file mode 100644
index 0000000000..b3af4a127a
--- /dev/null
+++ b/remote_io/rio_mmap.c
@@ -0,0 +1,134 @@
+/* The Remote I/O Server doesn't actually need to mmap any files. Instead
+   it just delagates the mapping to the client. The server only needs to ensure
+   that the client hasa local copy of the mmap'ed file. On munmap, if the mmap
+   has PROT_WRITE and is not anonymous, the server's copy of the file must be
+   updated.  */
+
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+/* This is a simple counter that gets incremented / decremented as an mmaped
+   filed is cached locally for the client in the .cache-<pid> directory.
+   Eventually, this caching scheme could be improved, by letting multiple
+   processes share read-only files and by consistnecy checking (hashsum) of
+   the local files to ensure that the contents haven't changed between runs.  */
+static int rio_mmap_cache = 0;
+
+int
+rio_get_mmap (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_mmap msg;
+  struct pcn_msg_hdr ack;
+  struct fdinfo *cfd; // Requested fd by the client
+  int size, res, rfd;
+
+  rio_printf ("%s[%u]: received mmap, size = %d\n",
+	      __FUNCTION__, hdr->msg_id, hdr->msg_size);
+
+  size = lio_get_msg (fd, &msg, sizeof (struct pcn_msg_mmap));
+  if (size != hdr->msg_size - sizeof (struct pcn_msg_hdr))
+    {
+      rio_printf ("%s[%u]: only received %d of %d bytes\n",
+		  __FUNCTION__, hdr->msg_id, size, hdr->msg_size);
+      lio_exit (EXIT_FAILURE);
+    }
+
+  cfd = rio_fd_find (msg.fd);
+
+  if (cfd == NULL)
+    lio_error ("%s[%u]: could not locate file descriptor '%u'\n",
+	       __FUNCTION__, hdr->msg_id, msg.fd);
+
+  /* Check if the file has already been opened up locally for
+      a different mapping.  */
+  if (cfd->maps > 0)
+    pcn_msg_ack (fd, hdr, cfd->fd);
+  else
+    rio_file_copy (fd, hdr->msg_id, cfd);
+
+  rio_printf ("%s[%u]: mapping fd = %u, length = %u, flag = %x, file = '%s' -> '%s', maps = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.fd, msg.length, cfd->flags,
+	      cfd->name, cfd->lname, cfd->maps);
+
+  // Instruct client to open up local file
+  cfd->maps++;
+
+  if (!(msg.flags & MAP_PRIVATE) && (msg.prot & PROT_WRITE))
+    cfd->status |= RIO_FD_DIRTY;
+
+  /* Receive the actuall mapping from the client and add
+     it to the mmap tree  */
+  size = lio_get_msg (fd, &msg.addr, sizeof msg.addr);
+  rio_mmap_add (cfd, msg.addr, msg.length, msg.prot, msg.flags);
+
+//  int count;
+//  ioctl (fd, FIONREAD, &count);
+//  rio_dbg_printf ("%s[%u]: pending message bytes = %u\n",
+//		  __FUNCTION__, hdr->msg_id, count);
+
+  //lio_assert_empty_socket (fd);
+
+  ack.msg_id = hdr->msg_id;
+  ack.msg_type = PCN_TYPE_CONTROL;
+  ack.msg_kind = PCN_CTL_ACK;
+  ack.msg_async = PCN_SEND_NORET;
+  ack.msg_size = sizeof (ack);
+  pcn_send (fd, &ack);
+
+  return 0;
+}
+
+int
+rio_get_munmap (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_mmap msg;
+  struct iovec payload[2];
+  struct fdinfo *pfd;
+  struct mmapinfo *mi;
+  int size;
+
+  //rio_printf ("%s: received mmap, size = %d\n", __FUNCTION__, hdr->msg_size);
+
+  size = lio_get_msg (fd, &msg, hdr->msg_size);
+  if (size != hdr->msg_size)
+    {
+      rio_printf ("%s[%u]: only received %d of %d bytes\n",
+		  __FUNCTION__, hdr->msg_id, size, hdr->msg_size);
+      lio_exit (EXIT_FAILURE);
+    }
+
+  //rio_printf ("%s: unmapping address %lx\n", __FUNCTION__, msg.addr);
+
+  mi = rio_mmap_find (msg.addr);
+  pfd = mi->pfd;
+
+  pfd->maps--;
+  rio_mmap_rm (mi);
+  free (mi);
+
+  if (pfd->fd < 0 && pfd->maps == 0)
+    {
+      if (pfd->status & RIO_FD_DIRTY)
+	rio_file_sync(fd, hdr->msg_id, pfd);
+
+      rio_fd_rm_closed (pfd);
+      free (pfd);
+    }
+
+  pcn_msg_ack (fd, hdr, 0);
+
+  rio_printf ("%s[%u]: unmapping addr = %lx, length = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.addr, msg.length);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_open.c b/remote_io/rio_open.c
new file mode 100644
index 0000000000..cb2f57d84b
--- /dev/null
+++ b/remote_io/rio_open.c
@@ -0,0 +1,47 @@
+/* open system call forwarding -- open, creat, and openat  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_open (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_open *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+
+  res.res = lio_get_msg (fd, msg, hdr->msg_size);
+
+  errno = 0;
+  res.res = lio_openat (msg->dirfd, msg->pathname, msg->flags, msg->mode);
+  res.rio_errno = errno;
+
+  rio_fd_open (res.res, msg->flags, msg->mode, msg->pathname);
+
+  rio_printf ("%s[%u]: pathname = %s, flags = %x, mode = %x, dirfd = %d -- fd = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg->pathname, msg->flags,
+	      msg->mode, msg->dirfd, res.res, res.rio_errno);
+
+  free (msg);
+
+  pcn_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_pipe.c b/remote_io/rio_pipe.c
new file mode 100644
index 0000000000..924eafc238
--- /dev/null
+++ b/remote_io/rio_pipe.c
@@ -0,0 +1,41 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_pipe (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_pipe msg;
+  
+  msg.pfds[0] = -1;
+  msg.pfds[1] = -1;
+
+  msg.res = lio_pipe2 (msg.pfds, hdr->msg_size);
+  msg._errno = errno;
+
+  rio_printf ("%s[%u]: flags = %x, pdfs = [%u, %u] -- res = %u, errno = %u\n",
+	      __FUNCTION__, hdr->msg_id, hdr->msg_size, msg.pfds[0], msg.pfds[1],
+	      msg.res, msg._errno);
+
+  lio_send_msg (fd, &msg, sizeof (msg));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_poll.c b/remote_io/rio_poll.c
new file mode 100644
index 0000000000..7fd9bf0fed
--- /dev/null
+++ b/remote_io/rio_poll.c
@@ -0,0 +1,53 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_poll (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_poll *msg;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = lio_get_msg (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive bind message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  if (hdr->msg_kind == PCN_SYS_POLL)
+    res = lio_poll (msg->fds, msg->nfds, msg->timeout);
+  else
+    // TODO: account for NULL arguments for tp and sigmask
+    res = lio_ppoll (msg->fds, msg->nfds, &msg->tp, &msg->sigmask);
+
+  msg->nfds = res;
+  msg->timeout = errno;
+
+  rio_dbg_printf ("%s[%u]: kind = %s, nfds = %u, timeout = %lx -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id,
+		  hdr->msg_kind == PCN_SYS_POLL ? "PCN_SYS_POLL" : "PCN_SYS_PPOLL",
+		  msg->nfds, msg->timeout, res);
+
+  lio_send_msg (fd, msg, hdr->msg_size);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_print.c b/remote_io/rio_print.c
new file mode 100644
index 0000000000..4bcc7b92d1
--- /dev/null
+++ b/remote_io/rio_print.c
@@ -0,0 +1,275 @@
+/* This file is a modified version of dl-minimal.c.  */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <sys/uio.h>
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <popcorn.h>
+#include "local_io.h"
+
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+const char _itoa_lower_digits_rio[16] = "0123456789abcdef";
+
+#if defined(__x86_64__) || defined(__aarch64__)
+#define NEED_L
+#endif
+
+/* We always use _itoa instead of _itoa_word in ld.so since the former
+   also has to be present and it is never about speed when these
+   functions are used.  */
+char *
+pcn_itoa (unsigned long long int value, char *buflim, unsigned int base,
+       int upper_case)
+{
+  assert (! upper_case);
+
+  do
+    *--buflim = _itoa_lower_digits_rio[value % base];
+  while ((value /= base) != 0);
+
+  return buflim;
+}
+
+static int
+write_str (char *str, size_t size, struct iovec *iov, int niov)
+{
+  int ix, j, k;
+
+  for (ix = 0, j = 0; ix < size && j < niov; j++)
+    {
+      const char *buf = iov[j].iov_base;
+
+      for (k = 0; ix < size && k < iov[j].iov_len; k++, ix++)
+	str[ix] = buf[k];
+    }
+
+  if (ix < size)
+    str[ix] = '\0';
+
+  return ix;
+}
+
+/* Bare-bones printf implementation.  This function only knows about
+   the formats and flags needed and can handle only up to 64 stripes in
+   the output.  */
+static int
+pcn_dl_debug_vdprintf (int fd, int tag_p, char *str, size_t size,
+		       const char *fmt, va_list arg)
+{
+# define NIOVMAX 64
+  struct iovec iov[NIOVMAX];
+  int niov = 0;
+
+  while (*fmt != '\0')
+    {
+      const char *startp = fmt;
+
+      /* Skip everything except % and \n (if tags are needed).  */
+      while (*fmt != '\0' && *fmt != '%' && (! tag_p || *fmt != '\n'))
+	++fmt;
+
+      /* Append constant string.  */
+      assert (niov < NIOVMAX);
+      if ((iov[niov].iov_len = fmt - startp) != 0)
+	iov[niov++].iov_base = (char *) startp;
+
+      if (*fmt == '%')
+	{
+	  /* It is a format specifier.  */
+	  char fill = ' ';
+	  int width = -1;
+	  int prec = -1;
+#ifdef NEED_L
+	  int long_mod = 0;
+#endif
+
+	  /* Recognize zero-digit fill flag.  */
+	  if (*++fmt == '0')
+	    {
+	      fill = '0';
+	      ++fmt;
+	    }
+
+	  /* See whether with comes from a parameter.  Note that no other
+	     way to specify the width is implemented.  */
+	  if (*fmt == '*')
+	    {
+	      width = va_arg (arg, int);
+	      ++fmt;
+	    }
+
+	  /* Handle precision.  */
+	  if (*fmt == '.' && fmt[1] == '*')
+	    {
+	      prec = va_arg (arg, int);
+	      fmt += 2;
+	    }
+
+	  /* Recognize the l modifier.  It is only important on some
+	     platforms where long and int have a different size.  We
+	     can use the same code for size_t.  */
+	  if (*fmt == 'l' || *fmt == 'Z')
+	    {
+#ifdef NEED_L
+	      long_mod = 1;
+#endif
+	      ++fmt;
+	    }
+
+	  switch (*fmt)
+	    {
+	      /* Integer formatting.  */
+	    case 'u':
+	    case 'x':
+	      {
+		/* We have to make a difference if long and int have a
+		   different size.  */
+#ifdef NEED_L
+		unsigned long int num = (long_mod
+					 ? va_arg (arg, unsigned long int)
+					 : va_arg (arg, unsigned int));
+#else
+		unsigned long int num = va_arg (arg, unsigned int);
+#endif
+		/* We use alloca() to allocate the buffer with the most
+		   pessimistic guess for the size.  Using alloca() allows
+		   having more than one integer formatting in a call.  */
+		char *buf = (char *) __builtin_alloca (3 * sizeof (unsigned long int));
+		char *endp = &buf[3 * sizeof (unsigned long int)];
+		char *cp = pcn_itoa (num, endp, *fmt == 'x' ? 16 : 10, 0);
+
+		/* Pad to the width the user specified.  */
+		if (width != -1)
+		  while (endp - cp < width)
+		    *--cp = fill;
+
+		iov[niov].iov_base = cp;
+		iov[niov].iov_len = endp - cp;
+		++niov;
+	      }
+	      break;
+
+	    case 's':
+	      /* Get the string argument.  */
+	      iov[niov].iov_base = va_arg (arg, char *);
+	      iov[niov].iov_len = lio_strlen (iov[niov].iov_base);
+	      if (prec != -1)
+		iov[niov].iov_len = MIN ((size_t) prec, iov[niov].iov_len);
+	      ++niov;
+	      break;
+
+	    case '%':
+	      iov[niov].iov_base = (void *) fmt;
+	      iov[niov].iov_len = 1;
+	      ++niov;
+	      break;
+
+	    default:
+	      lio_error ("invalid format specifier\n");
+	    }
+	  ++fmt;
+	}
+      else if (*fmt == '\n')
+	{
+	  /* See whether we have to print a single newline character.  */
+	  if (fmt == startp)
+	    {
+	      iov[niov].iov_base = (char *) startp;
+	      iov[niov++].iov_len = 1;
+	    }
+	  else
+	    /* No, just add it to the rest of the string.  */
+	    ++iov[niov - 1].iov_len;
+
+	  /* Next line, print a tag again.  */
+	  tag_p = 1;
+	  ++fmt;
+	}
+    }
+
+  /* Finally write the result.  */
+  if (str != NULL)
+    return write_str (str, size, iov, niov);
+  else
+    return SYSCALL_CANCEL (writev, fd, iov, niov);
+}
+
+/* Write to debug file.  */
+int
+rio_dbg_printf (const char *fmt, ...)
+{
+  va_list arg;
+  int ret;
+  struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+  if (pd->rio_debug == 0)
+    return 0;
+
+  if (pcn_mode == 1)
+    lio_write (STDOUT_FILENO, "> pcn_server: ", 15);
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (STDOUT_FILENO, 0, NULL, 0, fmt, arg);
+  va_end (arg);
+
+  return ret;
+}
+
+/* Write to debug file.  */
+int
+rio_dbg_fprintf (int fd, const char *fmt, ...)
+{
+  va_list arg;
+  int ret;
+  struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+  if (pd->rio_debug == 0)
+    return 0;
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (fd, 0, NULL, 0, fmt, arg);
+  va_end (arg);
+
+  return ret;
+}
+
+int
+rio_dbg_snprintf (char *str, size_t size, const char *fmt, ...)
+{
+  va_list arg;
+  int ret;
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (-1, 0, str, size, fmt, arg);
+  va_end (arg);
+
+  return ret;
+}
+
+int
+rio_dbg_vfprintf (int fd, const char *restrict fmt, va_list arg)
+{
+  if (pcn_mode == 1)
+    lio_write (fd, "> pcn_server: ", 15);
+
+  return pcn_dl_debug_vdprintf (fd, 0, NULL, 0, fmt, arg);
+}
+
+int
+lio_dbg_printf (const char *fmt, ...)
+{
+  va_list arg;
+  int ret;
+
+  if (pcn_mode == 1)
+    lio_write (STDOUT_FILENO, "> pcn_server: ", 15);
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (STDOUT_FILENO, 0, NULL, 0, fmt, arg);
+  va_end (arg);
+
+  return ret;
+}
\ No newline at end of file
diff --git a/remote_io/rio_read.c b/remote_io/rio_read.c
new file mode 100644
index 0000000000..7dfaf7fb18
--- /dev/null
+++ b/remote_io/rio_read.c
@@ -0,0 +1,49 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_read (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_read *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+  void *buf;
+
+  res.res = lio_get_msg (fd, msg, hdr->msg_size);
+
+  buf = (char *) malloc (msg->cnt);
+  res.res = lio_read (msg->fd, buf, msg->cnt);
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  rio_printf ("%s[%u]: fd = %u, count = %u -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg->fd, msg->cnt, res.res, res.rio_errno);
+
+  lio_send_msg (fd, &res, sizeof (res));
+
+  if (res.res > 0)
+    lio_send_msg (fd, buf, res.res);
+
+  free (buf);
+  free (msg);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_server.c b/remote_io/rio_server.c
new file mode 100644
index 0000000000..95f3ed4c73
--- /dev/null
+++ b/remote_io/rio_server.c
@@ -0,0 +1,770 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <ifaddrs.h>
+#include <net/if.h>
+
+#include <assert.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <poll.h>
+
+#include <stdarg.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+
+#include <sys/wait.h>
+#include <signal.h>
+
+#include <remote_io.h>
+#include <server.h>
+#include <message.h>
+#include <popcorn.h>
+
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+
+#define PCN_SERVER_INIT 1
+#define PCN_SERVER_READY 2
+
+static uint16_t alloc_server_port (void);
+
+#define RIO_BUF_SZ 512
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+/* vnsprintf prevents this rio_printf from being used inside ld-linux.  */
+void
+rio_printf (const char *restrict str, ...)
+{
+  char buf[RIO_BUF_SZ];
+  va_list ap;
+  char msg[] = "> pcn_server: ";
+
+  if (pd->rio_debug == 0)
+    return;
+
+  va_start (ap, str);
+  vsnprintf (buf, RIO_BUF_SZ, str, ap);
+  va_end (ap);
+
+  if (pcn_mode == 1)
+    lio_write (STDOUT_FILENO, msg, strlen (msg));
+
+  lio_write (STDOUT_FILENO, buf, strlen (buf));
+}
+
+void
+dump_pcn_data (void)
+{
+  rio_dbg_printf ("%s: pcn_entry = %lx, arg = %lx, argc = %u, argv = %lx, envp = %lx\n",
+		  __FUNCTION__, pd->pcn_entry, pd->arg, pd->argc, pd->argv,
+		  pd->envp);
+  rio_dbg_printf ("%s: filename = %s, thread_pointer = %lx, tls_statc_block = %lx\n",
+		  __FUNCTION__, pd->filename, pd->thread_pointer, pd->tls_static_block);
+  rio_dbg_printf ("%s: tls_init = %u, phnum = %u, pcn_data_size = %u, num_maps = %u\n",
+		  __FUNCTION__, pd->tls_init, pd->phnum, pd->pcn_data_size, pd->num_maps);
+  rio_dbg_printf ("%s: pcn_remote_io_active = %u, pcn_server_ip = %lx, pcn_server_port = %lx\n",
+		  __FUNCTION__, pd->pcn_remote_io_active, pd->pcn_server_ip, pd->pcn_server_port);
+  rio_dbg_printf ("%s: pcn_server_sockfd = %u, pcn_client_sockfd = %u, pcn_local_ip = %lx\n",
+		  __FUNCTION__, pd->pcn_server_sockfd, pd->pcn_server_port,
+		  pd->pcn_local_ip);
+  rio_dbg_printf ("%s: rio_migrate_pending = %u, rio_child_pid = %u, rio_debug = %u, pcn_break = %u\n",
+		  __FUNCTION__, pd->rio_migrate_pending, pd->rio_child_pid,
+		  pd->rio_debug, pd->pcn_break);
+}
+
+int
+rio_disable (void)
+{
+  int t = pd->pcn_remote_io_active;
+
+  pd->pcn_remote_io_active = 0;
+
+  return t;
+}
+
+void
+rio_restore (int t)
+{
+  pd->pcn_remote_io_active = t;
+}
+
+void
+pcn_server_init (void)
+{
+  if (getenv ("RIO_DEBUG"))
+    pd->rio_debug = 1;
+  else
+    pd->rio_debug = 0;
+
+  if (getenv ("PCN_RIO_LOCAL"))
+    {
+      pd->pcn_remote_io_active = 0;
+      pd->pcn_server_sockfd = -1;
+      return;
+    }
+
+  pd->pcn_remote_io_active = PCN_SERVER_INIT;
+  pd->pcn_local_ip = htonl (0x7f000001); /* 127.0.0.1  */
+  pd->pcn_server_port = alloc_server_port ();
+  pd->pcn_server_sockfd = pcn_server_connect (0);
+  rio_dbg_printf ("pcn_server_sockfd = %u\n", pd->pcn_server_sockfd);
+
+  if (pd->rio_debug)
+    {
+      char ext[INET_ADDRSTRLEN];
+
+      inet_ntop (AF_INET, &pd->pcn_server_ip, ext, INET_ADDRSTRLEN);
+      rio_printf ("%s: pcn_server_ip = %s, pcn_server_port = %d, pcn_server_sockfd = %d\n",
+		  __FUNCTION__, ext, pd->pcn_server_port, pd->pcn_server_sockfd);
+    }
+}
+
+static void
+do_sigchld (int signo)
+{
+  int status, pid;
+
+  // FWD
+  pid = wait (&status);
+  assert (pid == pd->rio_child_pid);
+  //pd->rio_child_pid = -100;
+}
+
+/*
+ * At present, this function returns the first non-local IPv4 address
+ * on the machine calling it.  This may cause problems if the machine
+ * is multihomed.
+ */
+uint32_t
+pcn_get_ip (void)
+{
+  struct ifaddrs *myaddrs, *ifa;
+  void *in_addr;
+  uint32_t ip = 0;
+  int t;
+
+  pd->pcn_local_ip = htonl (0x7f000001); /* 127.0.0.1  */
+
+  t = rio_disable ();
+  if(getifaddrs(&myaddrs) != 0)
+    {
+      perror("getifaddrs");
+      lio_exit (1);
+    }
+  rio_restore (t);
+
+  for (ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)
+    {
+      struct sockaddr_in *s4;
+
+      if (ifa->ifa_addr == NULL)
+	continue;
+      if (!(ifa->ifa_flags & IFF_UP))
+	continue;
+
+      if (ifa->ifa_addr->sa_family != AF_INET)
+	continue;
+
+      s4 = (struct sockaddr_in *)ifa->ifa_addr;
+      in_addr = &s4->sin_addr;
+      ip = *(long *) in_addr;
+
+      if (ip != pd->pcn_local_ip)
+	break;
+    }
+
+  freeifaddrs(myaddrs);
+
+  return ip;
+}
+
+static uint16_t
+alloc_server_port (void)
+{
+  int sockfd = lio_socket (AF_INET, SOCK_STREAM, 0);
+  struct addrinfo hints, *ai;
+  struct sockaddr_in sin;
+  socklen_t len = sizeof (sin);
+  char buf[INET_ADDRSTRLEN];
+  int res;
+
+  inet_ntop (AF_INET, &pd->pcn_server_ip, buf, sizeof (buf));
+
+  memset (&hints, 0, sizeof hints);
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  if ((res = getaddrinfo (buf, NULL, &hints, &ai)) != 0)
+    lio_error ("%s: %s\n", __FUNCTION__, gai_strerror (res));
+
+  assert (ai != NULL);
+
+  if (lio_bind (sockfd, ai->ai_addr, ai->ai_addrlen) < 0)
+    lio_error ("%s: failed to allocate IP port\n", __FUNCTION__);
+
+  if (getsockname(sockfd, (struct sockaddr *)&sin, &len) == -1)
+    {
+      rio_disable ();
+      perror("getsockname");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  lio_close (sockfd);
+  freeaddrinfo (ai);
+
+  return sin.sin_port;
+}
+
+static int
+connect_to (uint32_t ip, uint16_t port)
+{
+  int sockfd, res, t;
+  struct addrinfo hints, *ai;
+  char s_addr[INET_ADDRSTRLEN], s_port[INET_ADDRSTRLEN];
+
+  memset (&hints, 0, sizeof hints);
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+
+  inet_ntop (AF_INET, &ip, s_addr, INET_ADDRSTRLEN);
+  snprintf (s_port, INET_ADDRSTRLEN, "%d", port);
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0) {
+    rio_printf ("getaddrinfo: %s\n", gai_strerror (res));
+    lio_exit (EXIT_FAILURE);
+  }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  if (pd->rio_debug)
+    rio_printf ("connecting to %s:%s\n", s_addr, s_port);
+
+  sockfd = lio_socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      rio_disable ();
+      perror ("socket");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  t = rio_disable ();
+  if (connect (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      perror ("connection failed");
+      rio_printf ("   -> %s:%s\n", s_addr, s_port);
+      lio_exit (EXIT_FAILURE);
+    }
+  rio_restore (t);
+
+  return sockfd;
+}
+
+static void
+do_control (struct pcn_msg_hdr *hdr, int fd)
+{
+  if (pd->pcn_local_ip != pd->pcn_server_ip) {
+    lio_write (pd->pcn_server_ip, hdr, sizeof (struct pcn_msg_hdr));
+    return;
+  }
+
+  switch (hdr->msg_kind) {
+  case PCN_CTL_MIGRATE:
+    rio_printf ("server: received migration request\n");
+    pd->rio_migrate_pending = 1;
+    break;
+
+  default:
+    ;
+  }
+}
+
+static void
+do_syscall (struct pcn_msg_hdr *hdr, int fd)
+{
+  if (0 && pd->rio_debug) {
+    char s_addr[INET_ADDRSTRLEN], l_addr[INET_ADDRSTRLEN];
+
+    inet_ntop (AF_INET, &pd->pcn_server_ip, s_addr, INET_ADDRSTRLEN);
+    inet_ntop (AF_INET, &pd->pcn_local_ip, l_addr, INET_ADDRSTRLEN);
+
+    rio_printf ("%s: %s -> %s\n", __FUNCTION__, s_addr, l_addr);
+  }
+
+  switch (hdr->msg_kind) {
+  case PCN_SYS_OPEN:
+    rio_get_open (hdr, fd);
+    break;
+
+  case PCN_SYS_CLOSE:
+    rio_get_close (hdr, fd);
+    break;
+
+  case PCN_SYS_WRITE:
+    rio_get_write (hdr, fd);
+    break;
+
+  case PCN_SYS_READ:
+    rio_get_read (hdr, fd);
+    break;
+
+  case PCN_SYS_FXSTATAT:
+    rio_get_fxstatat (hdr, fd);
+    break;
+
+  case PCN_SYS_MMAP:
+    rio_get_mmap (hdr, fd);
+    break;
+
+  case PCN_SYS_MUNMAP:
+    rio_get_munmap (hdr, fd);
+    break;
+
+  case PCN_SYS_EPOLL_CREATE:
+    rio_get_epoll_create (hdr, fd);
+    break;
+
+  case PCN_SYS_EPOLL_CTL:
+    rio_get_epoll_ctl (hdr, fd);
+    break;
+
+  case PCN_SYS_EPOLL_WAIT:
+    rio_get_epoll_wait (hdr, fd);
+    break;
+
+  case PCN_SYS_FALLOCATE:
+    rio_get_fallocate (hdr, fd);
+    break;
+
+  case PCN_SYS_RT_SIGACTION:
+    rio_get_sigaction (hdr, fd);
+    break;
+
+  case PCN_SYS_FCNTL:
+    rio_get_fcntl (hdr, fd);
+    break;
+
+  case PCN_SYS_GETCWD:
+    rio_get_getcwd (hdr, fd);
+    break;
+
+  case PCN_SYS_PIPE:
+    rio_get_pipe (hdr, fd);
+    break;
+
+  case PCN_SYS_SOCKET:
+    rio_get_socket (hdr, fd);
+    break;
+
+  case PCN_SYS_GETSOCKOPT:
+    rio_get_getsockopt (hdr, fd);
+    break;
+
+  case PCN_SYS_SETSOCKOPT:
+    rio_get_setsockopt (hdr, fd);
+    break;
+
+  case PCN_SYS_BIND:
+    rio_get_bind (hdr, fd);
+    break;
+
+  case PCN_SYS_LISTEN:
+    rio_get_listen (hdr, fd);
+    break;
+
+  case PCN_SYS_ACCEPT:
+    rio_get_accept (hdr, fd);
+    break;
+
+  case PCN_SYS_CONNECT:
+    rio_get_connect (hdr, fd);
+    break;
+
+  case PCN_SYS_POLL:
+  case PCN_SYS_PPOLL:
+    rio_get_poll (hdr, fd);
+    break;
+
+  default:
+    ;
+  }
+}
+
+/* Returns 1 if a client has been dropped.  */
+static int
+process_message (int fd)
+{
+  struct pcn_msg_hdr hdr;
+  int res;
+
+  res = lio_read (fd, &hdr, sizeof (hdr));
+
+  if (res == 0) {
+    if (!pd->rio_migrate_pending) {
+      rio_printf ("client hung up... terminating\n");
+      lio_exit (EXIT_SUCCESS);
+    }
+
+    rio_printf ("client hung up\n");
+
+    return 1;
+  }
+
+  if (res < sizeof (hdr))
+    lio_error ("something went wrong - malformed message (%u)\n", fd);
+
+  switch (hdr.msg_type) {
+  case PCN_TYPE_CONTROL:
+    do_control (&hdr, fd);
+    break;
+
+  case PCN_TYPE_SYSCALL:
+    do_syscall (&hdr, fd);
+    break;
+
+  default:
+    lio_error ("unexpected message type: %u\n", hdr.msg_type);
+    ;
+  }
+
+  return 0;
+}
+
+static void
+remote_io_server (int listen_fd)
+{
+  /* There are at most three socket descriptors to keep track of:
+   *   1: The listener socket
+   *   2: The socket to the primary server
+   *   3: The socket to the client
+   *
+   * The listener socket is planced in pfds[0]. If a connection is
+   * required to the primary server, it will be in pfds[1]. Otherwise
+   * the socket to the client will be placed in pfds[1] or pfds[2]
+   * depending on the existance of the primary server connection.
+   */
+  struct pollfd pfds[3];
+  int fd_count = 1;
+  int t;
+
+  pd->pcn_local_ip = pcn_get_ip ();
+
+  //rio_printf ("starting server:%hd\n", pcn_server_port);
+
+  pfds[0].fd = listen_fd;
+  pfds[0].events = POLLIN;
+
+  if (pd->pcn_local_ip != pd->pcn_server_ip)
+    {
+      pd->pcn_server_sockfd = connect_to (pd->pcn_server_ip, pd->pcn_server_port);
+      pfds[1].fd = pd->pcn_server_sockfd;
+      pfds[1].events = POLLIN;
+      fd_count = 2;
+    }
+
+  while (1) {
+    int poll_count;
+    struct sockaddr_storage remoteaddr;
+    socklen_t addrlen;
+    int i;
+
+    t = rio_disable ();
+    poll_count = poll (pfds, fd_count, -1);
+    rio_restore (t);
+
+    if (poll_count == -1 && pd->rio_child_pid == -100)
+      pd->rio_child_pid = -1;
+    else if (poll_count == -1)
+      {
+	/* A signal may have been forwarded, so retry.  */
+	if (errno == EINTR)
+	  continue;
+
+	rio_disable ();
+	perror ("poll");
+	lio_error ("%s: poll failure\n", __FUNCTION__);
+      }
+
+    if (0 && pd->rio_debug)
+      rio_printf ("%s: connections = %d\n", __FUNCTION__, fd_count);
+
+    for (i = 0; i < fd_count; i++) {
+      if (pfds[i].revents & POLLIN) {
+	int res;
+
+	if (pfds[i].fd != listen_fd) {
+	  res = process_message (pfds[i].fd);
+
+	  if (res == 1) {
+	    assert (pfds[i].fd == pd->pcn_client_sockfd);
+
+	    fd_count--;
+	    pd->pcn_client_sockfd = -1;
+	    pfds[fd_count].fd = pd->pcn_client_sockfd;
+	  }
+
+	  continue;
+	}
+
+	addrlen = sizeof (remoteaddr);
+
+	pd->pcn_client_sockfd = lio_accept (listen_fd, (struct sockaddr *)&remoteaddr,
+					    &addrlen);
+
+	if (pd->pcn_client_sockfd < 0)
+	  {
+	    rio_disable ();
+	    perror ("failed to accept client");
+	    lio_exit (EXIT_FAILURE);
+	  }
+	else {
+	  char buf[INET_ADDRSTRLEN];
+	  struct sockaddr_in *sin = (struct sockaddr_in *)&remoteaddr;
+
+	  if (1 || pd->rio_debug) {
+	    inet_ntop (remoteaddr.ss_family, &sin->sin_addr, buf,
+		       INET_ADDRSTRLEN);
+	    rio_printf ("%s: accepted client %s\n", __FUNCTION__, buf);
+	  }
+
+	  pfds[fd_count].fd = pd->pcn_client_sockfd;
+	  pfds[fd_count].events = POLLIN;
+	  pfds[fd_count].revents = 0;
+	  fd_count++;
+	  pd->rio_migrate_pending = 0;
+	}
+      } else if (pfds[i].revents & POLLHUP) {
+	assert (pfds[i].fd == pd->pcn_client_sockfd);
+	// terminate server if client necessary
+	// FIXME: this is detected by receiving 0 bytes
+
+	if (pd->rio_debug)
+	  rio_printf ("client disconnected... shutting down\n");
+
+	lio_exit (EXIT_SUCCESS);
+      }
+    }
+  }
+
+  if (pd->pcn_server_ip != pd->pcn_local_ip)
+    ; // coordinate shutdown
+  lio_exit (EXIT_SUCCESS);
+}
+
+/*
+ * Connect to the I/O server.
+ *
+ * A Popcorn application may be launched on machine A and
+ * checkpoint/restored onto a machine B. Note that machines A and B
+ * may be the same machine, e.g. Application launched on A, migrates
+ * over to B, then migrates back to A.
+ *
+ * A Popcorn application has at most two servers, a server running on
+ * the local host and the primary server running on the machine that
+ * originally launched the Popcorn application. The secondary server
+ * on a remote machine is necessary to handle signal forwarding
+ * without introducing additional threads into the Popcorn
+ * application. Communication between the Popcorn application and a
+ * server running on the same machine is conducted via local network.
+ *
+ * A new server is spawned in two cases:
+ *   1) When the Popcorn application is first launched on Machine A.
+ *   2) When the Popcorn application has migrated to Machine B != A.
+ *
+ * This function is responsible for setting up a server if necessary.
+ * It returns a socket descriptor to the local server.
+ */
+int
+pcn_server_connect (uint32_t ip)
+{
+  uint32_t myip = pcn_get_ip ();
+  int sockfd = -1;
+  struct addrinfo hints, *ai;
+  //struct sockaddr_in sin;
+  //socklen_t len = sizeof (sin);
+  uint16_t port = pd->pcn_server_port;
+  int res;
+  char buf[INET_ADDRSTRLEN], *s_addr = NULL, *s_port = NULL;
+
+  //dump_pcn_data ();
+  rio_printf ("entering %s\n", __FUNCTION__);
+  //rio_printf ("%s: myip = %lx\n", __FUNCTION__, myip);
+
+  /* TODO: handle 'ip' for remote servers".  */
+  if (pd->pcn_remote_io_active == PCN_SERVER_READY)
+    return connect_to (pd->pcn_server_ip, port);
+
+  if (myip != pd->pcn_server_ip)
+    {
+      /* Disable the secondary server after migration.  */
+      pd->pcn_remote_io_active = PCN_SERVER_READY;
+
+      memset (&hints, 0, sizeof (hints));
+      hints.ai_family = AF_INET;
+      hints.ai_socktype = SOCK_STREAM;
+      hints.ai_flags = AI_PASSIVE;
+
+      snprintf (buf, INET_ADDRSTRLEN, "%d", pd->pcn_server_port);
+      s_port = buf;
+
+      if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0) {
+	rio_printf ("getaddrinfo: %s\n", gai_strerror (res));
+	lio_exit (EXIT_FAILURE);
+      }
+
+      assert (ai != NULL && ai->ai_family == AF_INET);
+
+      sockfd = lio_socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+      if (sockfd < 0)
+	{
+	  rio_disable ();
+	  perror ("socket");
+	  lio_exit (EXIT_FAILURE);
+	}
+
+      if (lio_bind (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+	{
+	  rio_disable ();
+	  lio_close (sockfd);
+	  perror ("bind");
+	  lio_exit (EXIT_FAILURE);
+	}
+
+      if (lio_listen (sockfd, 2) == -1)
+	{
+	  rio_disable ();
+	  perror ("listen");
+	  lio_exit (EXIT_FAILURE);
+	}
+
+      if (pd->pcn_server_ip == 0)
+	{
+	  pd->pcn_server_ip = myip;
+	  pd->pcn_server_port = port;
+	}
+
+      freeaddrinfo (ai);
+
+      pd->rio_child_pid = fork ();
+
+      if (pd->rio_child_pid != 0) {
+	struct sigaction sa;
+
+	pcn_mode = 1;
+
+	/* Don't want to foward system calls on the server.  */
+	pd->pcn_remote_io_active = 0;
+
+	sigemptyset(&sa.sa_mask);
+	sa.sa_flags = 0;
+	sa.sa_handler = do_sigchld;
+
+	// FWD
+	sigaction(SIGCHLD, &sa, NULL);
+
+	/* Run the application on the fork'ed process so that CRIU
+	   does not attempt to suspend the server. Eventually, this
+	   might need to use a standalone server.  */
+
+	remote_io_server (sockfd);   /* Never return.  */
+      }
+
+      lio_close (sockfd);
+
+      /* Close STDIN so that the server can use it.  */
+      lio_close (STDIN_FILENO);
+    }
+
+  /* Return a socket to the server running on the local machine.  */
+  return connect_to (pd->pcn_local_ip, port);
+  //return connect_to (pcn_server_ip, port);
+}
+
+/* Launch a server without forking a new process for testing purposes.  */
+void
+pcn_start_server (void)
+{
+  uint32_t myip = pcn_get_ip ();
+  int sockfd = -1;
+  struct addrinfo hints, *ai;
+  uint16_t port = pd->pcn_server_port;
+  int res;
+  char buf[INET_ADDRSTRLEN], *s_addr = NULL, *s_port = NULL;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  snprintf (buf, INET_ADDRSTRLEN, "%d", pd->pcn_server_port);
+  s_port = buf;
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0) {
+    rio_printf ("getaddrinfo: %s\n", gai_strerror (res));
+    exit (EXIT_FAILURE);
+  }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = lio_socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  if (lio_bind (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      rio_disable ();
+      lio_close (sockfd);
+      perror ("bind");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  if (pd->pcn_server_ip == 0)
+    {
+      pd->pcn_server_ip = myip;
+      pd->pcn_server_port = port;
+    }
+
+  if (lio_listen (sockfd, 2) == -1)
+    {
+      rio_disable ();
+      perror ("listen");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  freeaddrinfo (ai);
+
+  remote_io_server (sockfd);
+}
+
+void
+pcn_migrate (void)
+{
+  struct pcn_msg_hdr hdr;
+
+  hdr.msg_type = PCN_TYPE_CONTROL;
+  hdr.msg_kind = PCN_CTL_MIGRATE;
+  hdr.msg_id = rio_msg_id ();
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (hdr);
+
+  pcn_send (pd->pcn_server_sockfd, &hdr);
+
+  lio_close (pd->pcn_server_sockfd);
+
+  pd->pcn_server_sockfd = -1;
+
+  rio_dbg_printf ("%s: success!\n", __FUNCTION__);
+}
diff --git a/remote_io/rio_sigaction.c b/remote_io/rio_sigaction.c
new file mode 100644
index 0000000000..8959c3c347
--- /dev/null
+++ b/remote_io/rio_sigaction.c
@@ -0,0 +1,105 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/epoll.h>
+#include <popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+static void
+rio_signal_forwarder (int sig, siginfo_t *si, void *arg)
+{
+  struct sockaddr addr;
+  struct sockaddr_in *client;
+  socklen_t addrlen = sizeof (addr);
+  uint32_t myip = pcn_get_ip ();
+  uint32_t lip = 0x100007f; /* 127.0.0.1  */
+  uint32_t cip;
+
+  getpeername (pd->pcn_client_sockfd, &addr, &addrlen);
+  client = (struct sockaddr_in *)&addr;
+
+  cip = *(long *)&(client->sin_addr);
+
+  dump_pcn_data ();
+
+  rio_dbg_printf ("%s: forwarding signal '%u' to pid '%u' with IP '%x' (myip = %x)\n",
+		  __FUNCTION__, sig, pd->rio_child_pid, cip, myip);
+
+  if (cip == myip || cip == lip)
+    lio_kill (pd->rio_child_pid, sig);
+  else
+    {
+      int sockfd;
+      struct pcn_msg_signal msg;
+
+      msg.pid = pd->rio_child_pid;
+      msg.sig = sig;
+      msg.type = PCN_SIG_KILL;
+
+      sockfd = lio_socket (PF_INET, SOCK_STREAM, 0);
+      if (sockfd < 0)
+	{
+	  rio_disable ();
+	  perror ("socket");
+	  exit (EXIT_FAILURE);
+	}
+	
+      client->sin_port = htons (POPCORN_KILLD_PORT);
+
+      if (connect (sockfd, &addr, addrlen) == -1)
+	{
+	  rio_disable ();
+	  perror ("connection failed");
+	  exit (EXIT_FAILURE);
+	}
+
+      lio_write (sockfd, &msg, sizeof (msg));
+
+      lio_close (sockfd);
+    }
+}
+
+static void
+register_signal (int sig)
+{
+  struct sigaction sa;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = rio_signal_forwarder;
+  sa.sa_flags = SA_SIGINFO;
+
+  /* Don't call lio_rt_sigaction directly, because glibc
+     needs to set sa_restorer.  */
+  sigaction (sig, &sa, NULL);
+}
+
+int
+rio_get_sigaction (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_signal msg;
+  struct pcn_msg_res res;
+
+  lio_get_msg (fd, &msg, sizeof (msg));
+
+  register_signal (msg.sig);
+
+  dump_pcn_data ();
+
+  rio_printf ("%s[%u]: signal = %d, pid = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg.sig, msg.pid);
+
+  res.id = hdr->msg_id;
+  res.rio_errno = 0;
+  res.res = 0;
+
+  pcn_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return res.res;
+}
diff --git a/remote_io/rio_socket.c b/remote_io/rio_socket.c
new file mode 100644
index 0000000000..3389cefb9b
--- /dev/null
+++ b/remote_io/rio_socket.c
@@ -0,0 +1,109 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <popcorn.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_socket (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_socket msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  res = lio_get_msg (fd, &msg, sizeof (msg));
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive socket message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  ack.res = lio_socket (msg.domain, msg.type, msg.protocol);
+  ack.rio_errno = errno;
+
+  if (ack.res >= 0)
+    rio_fd_open_special (ack.res, RIO_FD_SOCKET);
+
+  rio_dbg_printf ("%s[%u]: domain = %x, type = %x, protocol = %x -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg.domain, msg.type,
+		  msg.protocol, ack.res);
+
+  lio_send_msg (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_setsockopt (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_sockopt *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = lio_get_msg (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive sockopt message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  ack.res = lio_setsockopt (msg->sockfd, msg->level, msg->optname,
+			    msg->optval, msg->optlen);
+  ack.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->level,
+		  msg->optname, ((int *)(msg->optval))[0], msg->optlen,
+		  ack.res);
+
+  lio_send_msg (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_getsockopt (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_sockopt *msg;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = lio_get_msg (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive sockopt message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  res = lio_getsockopt (msg->sockfd, msg->level, msg->optname,
+			msg->optval, &msg->optlen);
+
+  msg->sockfd = res;
+  msg->level = errno;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->level,
+		  msg->optname, ((int *)(msg->optval))[0], msg->optlen,
+		  res);
+
+  lio_send_msg (fd, msg, hdr->msg_size);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_vma.c b/remote_io/rio_vma.c
new file mode 100644
index 0000000000..101b0839ac
--- /dev/null
+++ b/remote_io/rio_vma.c
@@ -0,0 +1,432 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "server.h"
+#include "popcorn.h"
+#include "message.h"
+
+#define __USE_GNU 1
+#include <search.h>
+
+void *rio_fd_root = NULL;
+void *rio_fd_closed = NULL;
+void *rio_mmap_root = NULL;
+
+static int
+fdinfo_cmp_fn (const void *l, const void *r)
+{
+  const struct fdinfo *ll = l;
+  const struct fdinfo *rr = r;
+
+  return ll->fd - rr->fd;
+}
+
+static int
+mmapinfo_cmp_fn (const void *l, const void *r)
+{
+  const struct mmapinfo *ll = l;
+  const struct mmapinfo *rr = r;
+
+  return (long)ll->addr - (long)rr->addr;
+}
+
+struct fdinfo *
+rio_fd_open (int fd, int flags, mode_t mode, char *name)
+{
+  /* TODO: check if the file has been previously mapped.
+	   But that's probably unlikely?  */
+  struct fdinfo *fdp = (struct fdinfo *) malloc (sizeof (struct fdinfo));
+  struct fdinfo **t;
+
+  fdp->fd = fd;
+  fdp->maps = 0;
+  fdp->flags = flags;
+  fdp->mode = mode;
+  fdp->status = 0;
+  fdp->name = strdup (name);
+  fdp->lname = NULL;
+  fdp->type = RIO_FD_FILE;
+
+  t = tsearch (fdp, &rio_fd_root, fdinfo_cmp_fn);
+  if (t == NULL)
+    {
+      rio_dbg_printf ("%s: failed to access rio_fd_root\n", __FUNCTION__);
+      exit (EXIT_FAILURE);
+    }
+
+  //  rio_dbg_printf ("%s: fd = %u, flags = %u, mode = %u, name = %s\n",
+  //		  __FUNCTION__, (*t)->fd, (*t)->flags, (*t)->mode, (*t)->name);
+
+  return fdp;
+}
+
+struct fdinfo *
+rio_fd_open_special (int fd, int type)
+{
+  struct fdinfo *fdp = (struct fdinfo *) malloc (sizeof (struct fdinfo));
+  struct fdinfo **t;
+
+  fdp->fd = fd;
+  fdp->maps = 0;
+  fdp->flags = 0;
+  fdp->mode = 0;
+  fdp->status = 0;
+  fdp->name = NULL;
+  fdp->lname = NULL;
+  fdp->type = type;
+
+  t = tsearch (fdp, &rio_fd_root, fdinfo_cmp_fn);
+  if (t == NULL)
+    {
+      rio_dbg_printf ("%s: failed to access rio_fd_root\n", __FUNCTION__);
+      exit (EXIT_FAILURE);
+    }
+
+  //  rio_dbg_printf ("%s: fd = %u, flags = %u, mode = %u, name = %s\n",
+  //		  __FUNCTION__, (*t)->fd, (*t)->flags, (*t)->mode, (*t)->name);
+
+  return fdp;
+}
+
+struct fdinfo *
+rio_fd_find (int fd)
+{
+  struct fdinfo t, **res;
+
+  t.fd = fd;
+  res = tfind (&t, &rio_fd_root, fdinfo_cmp_fn);
+
+/*
+  if (res != NULL)
+    rio_dbg_printf ("%s: fd = %u, name = %s\n", __FUNCTION__, fd, (*res)->name);
+  else
+    rio_dbg_printf ("%s: fd = %u, missing\n", __FUNCTION__, fd);
+*/
+
+  return res == NULL ? NULL : *res;
+}
+
+void
+rio_fd_rm (struct fdinfo *fd)
+{
+  //rio_dbg_printf ("%s: fd = %u, name = %s\n", __FUNCTION__, fd->fd, fd->name);
+  tdelete (fd, &rio_fd_root, fdinfo_cmp_fn);
+}
+
+void
+rio_fd_add_closed (struct fdinfo *pfd)
+{
+  struct fdinfo *t;
+
+  t = tsearch (pfd, &rio_fd_closed, fdinfo_cmp_fn);
+  if (t == NULL)
+    {
+      rio_dbg_printf ("%s: failed to access rio_fd_root\n", __FUNCTION__);
+      exit (EXIT_FAILURE);
+    }
+}
+
+void
+rio_fd_rm_closed (struct fdinfo *pfd)
+{
+  if (pfd == NULL)
+    lio_error ("%s: pfd is NULL\n", __FUNCTION__);
+
+  tdelete (pfd, &rio_fd_closed, fdinfo_cmp_fn);
+}
+
+struct mmapinfo *
+rio_mmap_add (struct fdinfo *pfd, void *addr, int len, int prot, int flags)
+{
+  struct mmapinfo *mp = malloc (sizeof (struct mmapinfo));
+  struct mmapinfo **t;
+
+  mp->pfd = pfd;
+  mp->addr = addr;
+  mp->len = len;
+  mp->prot = prot;
+  mp->flags = flags;
+
+  t = tsearch (mp, &rio_mmap_root, mmapinfo_cmp_fn);
+
+  rio_dbg_printf ("%s: inserting map @ %lx\n", __FUNCTION__, addr);
+
+  assert (*t == mp);
+
+  return NULL;
+}
+
+struct mmapinfo *
+rio_mmap_find (void *addr)
+{
+  struct mmapinfo t;
+
+  t.addr = addr;
+
+  return *(struct mmapinfo **)tsearch (&t, &rio_mmap_root, mmapinfo_cmp_fn);
+}
+
+void
+rio_mmap_rm (struct mmapinfo *map)
+{
+  tdelete (map, &rio_mmap_root, mmapinfo_cmp_fn);
+}
+
+/* File I/O Operations.  */
+
+/* This function cannot be linked with ld-linux, because it contains
+   too may libc dependencies.  */
+static const char *
+rio_temp_file_name (const char *fname)
+{
+  const char *base, *t;
+  char *res;
+
+  for (base = t = fname; *t != '\0'; t++)
+    if (*t == '/')
+      {
+	base = t+1;
+      }
+
+  /* Eventually the filename will need to be somewhat randomized.  */
+  //asprintf (&pfd->lname, "%s/%s.%d", PCN_TMP_DIR, fname, rand());
+  asprintf (&res, "%s/%s", PCN_TMP_DIR, base);
+
+  return res;
+}
+
+/* Open a file locally on the client.  */
+
+static int
+rio_copy_file_local (int sockfd, int mid, struct fdinfo *pfd)
+{
+  struct pcn_msg_io_open iop = {0};
+  struct iovec payload[2];
+  const char *t;
+  struct stat st;
+  int res;
+
+  if (pfd->lname != NULL)
+    return pfd->fd;
+
+  rio_init_tmpdir ();
+
+  pfd->lname = rio_temp_file_name (pfd->name);
+
+  /* Check if a cached copy of the file already exists,
+     and remove it if present.  */
+
+  rio_maybe_zap_file (pfd->lname);
+
+  /* Create a hardlink of the file.  */
+  res = lio_link (pfd->name, pfd->lname);
+
+  rio_dbg_printf ("%s[%u]: linking %s -> %s (%d)\n",
+		  __FUNCTION__, mid, pfd->name, pfd->lname, res);
+
+  // Now open the file
+
+  iop.open.dirfd = pfd->fd;
+  iop.open.flags = pfd->flags;
+  iop.open.mode = pfd->mode;
+  iop.hdr.msg_size = sizeof (struct pcn_msg_open) + strlen (pfd->lname) + 1;
+  iop.hdr.msg_id = mid;
+  iop.hdr.msg_kind = PCN_SYS_OPEN;
+  iop.hdr.msg_type = PCN_TYPE_RES;
+
+  rio_printf ("%s[%u]: res = { dirfd = %d, flags = %d, mode = %d }\n",
+	      __FUNCTION__, mid, iop.open.dirfd, iop.open.flags, iop.open.mode);
+
+  payload[0].iov_base = &iop;
+  payload[0].iov_len = sizeof (iop);
+  payload[1].iov_base = pfd->lname;
+  payload[1].iov_len = strlen (pfd->lname) + 1;
+
+  res = lio_writev (sockfd, payload, 2);
+  rio_printf ("%s[%u]: sent %u bytes for struct iop\n",
+	      __FUNCTION__, mid, res);
+
+  return pfd->fd;
+}
+
+static int
+rio_copy_file_remote (int fd, int mid, struct fdinfo *pfd)
+{
+  struct pcn_msg_io_open iop = {0};
+  struct pcn_msg_io_data iod = {0};
+  struct pcn_msg_hdr ack;
+  struct iovec payload[2];
+  struct stat st;
+  int res, sent;
+  off_t offset = 0;
+
+  if (pfd->lname)
+    return pfd->fd;
+
+  pfd->lname = rio_temp_file_name (pfd->name);
+
+  /* Instruct the client to expect to receive a file.  */
+  iop.hdr.msg_kind = PCN_SYS_OPEN;
+  iop.hdr.msg_type = PCN_TYPE_RES;
+  iop.hdr.msg_id = mid;
+  iop.hdr.msg_size = sizeof (struct pcn_msg_open) + lio_strlen (pfd->lname) + 1;
+
+  iop.open.dirfd = -pfd->fd;
+  iop.open.flags = pfd->flags;
+  iop.open.mode = pfd->mode;
+
+  payload[0].iov_base = &iop;
+  payload[0].iov_len = sizeof (iop);
+  payload[1].iov_base = pfd->lname;
+  payload[1].iov_len = lio_strlen (pfd->lname) + 1;
+
+/*
+  rio_dbg_printf ("%s: iop.hdr.msg_kind = %u\n", __FUNCTION__, iop.hdr.msg_kind);
+  rio_dbg_printf ("%s: iop.hdr.msg_type = %u\n", __FUNCTION__, iop.hdr.msg_type);
+  rio_dbg_printf ("%s: iop.hdr.msg_id = %u\n", __FUNCTION__, iop.hdr.msg_id);
+  rio_dbg_printf ("%s: iop.hdr.msg_size = %u\n", __FUNCTION__, iop.hdr.msg_size);
+*/
+
+  rio_dbg_printf ("%s[%u]: open = { dirfd = %u, flags = %u, mode = %u, pathname = %s, size = %u }\n",
+		  __FUNCTION__, mid, iop.open.dirfd, iop.open.flags, iop.open.mode,
+		  pfd->lname, st.st_size);
+
+  res = lio_writev (fd, payload, 2);
+
+  lio_get_msg (fd, &ack, sizeof (ack));
+
+  /* Send the file over the wire.  */
+  lio_fstat (pfd->fd, &st);
+
+  iod.hdr.msg_kind = PCN_SYS_READ;
+  iod.hdr.msg_type = PCN_TYPE_RES;
+  iod.hdr.msg_id = mid;
+  iod.hdr.msg_size = sizeof (struct pcn_msg_read);
+  iod.data.fd = pfd->fd;
+  iod.data.cnt = st.st_size;
+
+  lio_write (fd, &iod, sizeof (iod));
+
+  sent = 0;
+
+  while (sent < st.st_size)
+    {
+      res = lio_sendfile (fd, pfd->fd, &offset, st.st_size - sent);
+
+      if (res < 0)
+	lio_error ("failed to send file\n");
+
+      sent += res;
+    }
+
+  rio_dbg_printf ("%s[%u]: sent file '%s', size = '%u' bytes\n",
+		  __FUNCTION__, mid, pfd->lname, sent);
+
+  ack.msg_id = mid;
+  ack.msg_type = PCN_TYPE_CONTROL;
+  ack.msg_kind = PCN_CTL_ACK;
+  ack.msg_async = PCN_SEND_NORET;
+  ack.msg_size = sizeof (ack);
+
+  pcn_send (fd, &ack);
+
+  return pfd->fd;
+}
+
+/* Create a local copy of a file residing on the host to the remote.  */
+int
+rio_file_copy (int fd, int mid, struct fdinfo *pfd)
+{
+  struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+//  if (pd->pcn_server_ip == pd->pcn_local_ip)
+//    return rio_copy_file_local (fd, mid, pfd);
+//  else
+    return rio_copy_file_remote (fd, mid, pfd);
+}
+
+int
+rio_file_sync_remote (int sockfd, int mid, struct fdinfo *pfd)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_hdr fin;
+  struct iovec args;
+  struct stat st;
+  void *addr;
+  int fd, recv, res;
+
+  hdr.msg_kind = PCN_TYPE_CONTROL;
+  hdr.msg_type = PCN_CTL_SYNC;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = strlen (pfd->lname) + 1;
+
+  args.iov_base = pfd->lname;
+  args.iov_len = hdr.msg_size;
+
+  pcn_send_iov (sockfd, &hdr, &args, 1);
+
+  /* Open the local file, if necessary.  */
+  if (pfd->fd > 0)
+    fd = pfd->fd;
+  else
+    {
+      fd = lio_open (pfd->name, O_CREAT | O_RDWR, pfd->mode);
+      if (fd < 0)
+	lio_error ("%s: failed to open file '%s'\n", __FUNCTION__, pfd->name);
+    }
+
+  lio_fstat (fd, &st);
+  rio_dbg_printf ("%s[%u]: syncing remote file '%s', size = %u bytes\n",
+		  __FUNCTION__, mid, pfd->name, st.st_size);
+
+  addr = lio_mmap (NULL, st.st_size, PROT_WRITE, MAP_SHARED, fd, 0);
+  if (addr == (void *)-1)
+    lio_error ("%s: failed to mmap '%s'\n", __FUNCTION__, pfd->name);
+
+  recv = 0;
+  while (recv < st.st_size)
+    {
+      res = lio_read (sockfd, addr + recv, st.st_size - recv);
+
+      if (res < 0)
+	lio_error ("%s[%u]: failed to receive file, res = %u\n",
+		   __FUNCTION__, mid, res);
+
+      recv += res;
+      rio_dbg_printf ("%s[%u]: received %u bytes (%u)\n",
+		      __FUNCTION__, mid, recv, res);
+    }
+
+  lio_munmap (addr, st.st_size);
+
+  if (pfd->fd < 0)
+    lio_close (fd);
+
+  fin.msg_id = mid;
+  fin.msg_type = PCN_TYPE_CONTROL;
+  fin.msg_kind = PCN_CTL_ACK;
+  fin.msg_async = PCN_SEND_NORET;
+  fin.msg_size = sizeof (fin);
+
+  //pcn_send (sockfd, &fin);
+
+  return st.st_size;
+}
+
+/* Synchronize a copy of file represented by PFD.  Eventually,
+  this could be optimized by only copying the part of the file
+  that has been modifed.  */
+int
+rio_file_sync (int sockfd, int mid, struct fdinfo *pfd)
+{
+  return rio_file_sync_remote (sockfd, mid, pfd);
+}
diff --git a/remote_io/rio_write.c b/remote_io/rio_write.c
new file mode 100644
index 0000000000..be4428e6ff
--- /dev/null
+++ b/remote_io/rio_write.c
@@ -0,0 +1,184 @@
+/* writev system call forwarding.
+ *
+ * Eventually, this needs to be agnostic to the C library...
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <remote_io.h>
+#include <message.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+#include <popcorn.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+#include <ldsodefs.h>
+
+static struct dl_pcn_data *pd = (void *) DL_PCN_STATE;
+
+struct pcn_write_msg {
+  int fd;
+  int size;
+  char buf[0];
+};
+
+void
+rio_get_write (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_write_msg *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+
+  //rio_printf ("%s\n", __FUNCTION__);
+
+  res.res = lio_get_msg (fd, msg, hdr->msg_size);
+
+  if (pd->pcn_local_ip != pd->pcn_server_ip) {
+    struct iovec iov[1];
+
+    iov[0].iov_base = msg->buf;
+    iov[0].iov_len = msg->size;
+
+    //syscall (SYS_writev, pcn_server_ip, iov, 2);
+    res.res = pcn_writev (msg->fd, iov, 1);
+  } else {
+    //GLRO(dl_debug_printf) ("%s: fd = %u\n", __FUNCTION__, msg->fd);
+    res.res = lio_write (msg->fd, msg->buf, msg->size);
+    //write (msg->fd, msg->buf, msg->size);
+  }
+
+  free (msg);
+
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+
+  rio_printf ("%s[%u]: fd = %u, count = %u, received %d bytes -- res = %d, erno = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg->fd, msg->size, res, res.res, res.rio_errno);
+
+  pcn_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+//  hdr->msg_type = PCN_TYPE_CONTROL;
+//  hdr->msg_kind = PCN_CTL_ACK;
+//
+//  write (fd, hdr, sizeof (struct pcn_msg_hdr));
+}
+
+ssize_t pcn_write (int fd, const void *buf, size_t count)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  struct pcn_write_msg msg;
+  int res;
+  int mid = rio_msg_id ();
+
+  /* Don't forward the write message unless the file
+     descriptor is available on the server.
+
+     TODO: add support or remote file I/O on the server. */
+//  if (fd > 2)
+//    return syscall (SYS_write, fd, buf, count);
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_write (fd, buf, count);
+
+  msg.fd = fd;
+  msg.size = count;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  payload[1].iov_base = (void *)buf;
+  payload[1].iov_len = count;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_WRITE;
+  hdr.msg_id = mid;
+  hdr.msg_async = 0;
+  hdr.msg_size = sizeof (msg) + count;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, count = %u -- res = %u\n",
+		  __FUNCTION__, mid, fd, count, res);
+
+//  printf ("size: hdr = %zu, msg = %zu (%d), payload = %d\n",
+//	  sizeof (hdr), sizeof (msg), msg.size, size);
+//
+//  printf ("transmitted %d bytes\n", res);
+
+  //res = read (pcn_server_sockfd, &hdr, sizeof hdr);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
+
+
+ssize_t pcn_writev (int fd, const struct iovec *iov, int iovcnt)
+{
+  int i, size = 0;
+//  int off = 0;
+//  uint8_t *buf;
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[iovcnt + 1];
+  struct pcn_write_msg msg;
+  int res;
+  int mid = rio_msg_id ();
+  int payload_sz = sizeof (msg);
+
+  /* Check if the server is down.  */
+  if (!pd->pcn_remote_io_active)
+    return lio_writev (fd, iov, iovcnt);
+
+  for (i = 0; i < iovcnt; i++)
+    size += iov[i].iov_len;
+
+//  buf = malloc (size);
+//
+//  for (i = 0; i < iovcnt; i++) {
+//    memcpy (buf + off, iov[i].iov_base, iov[i].iov_len);
+//    off += iov[i].iov_len;
+//  }
+
+  msg.fd = fd;
+  msg.size = size;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  for (i = 1; i < iovcnt+1; i++) {
+    payload[i].iov_base = iov[i-1].iov_base;
+    payload[i].iov_len = iov[i-1].iov_len;
+    payload_sz += iov[i-1].iov_len;
+  }
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_WRITE;
+  hdr.msg_id = mid;
+  hdr.msg_async = 0;
+  hdr.msg_size = payload_sz;
+
+  res = pcn_send_iov (pd->pcn_server_sockfd, &hdr, payload, iovcnt+1);
+
+//  printf ("size: hdr = %zu, msg = %zu (%d), payload = %d\n",
+//	  sizeof (hdr), sizeof (msg), msg.size, size);
+
+  //rio_printf ("%s: transmitted %d bytes\n", __FUNCTION__, res);
+
+  //res = read (pcn_server_sockfd, &hdr, sizeof hdr);
+
+  //lio_assert_empty_socket (pd->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/server.h b/remote_io/server.h
new file mode 100644
index 0000000000..a11fd3db9a
--- /dev/null
+++ b/remote_io/server.h
@@ -0,0 +1,111 @@
+#ifndef SERVER_H
+#define SERVER_H
+
+#include <stdint.h>
+
+struct pcn_msg_hdr;
+
+/* TCP Port (KILLD) for popcorn_killd.  */
+#define POPCORN_KILLD_PORT 54553
+
+// See /proc/self/limits for the actual limit
+#define RIO_MAX_OPENED_FILES 1024
+
+#define RIO_FD_OPENED  (1 << 0)
+#define RIO_FD_DIRTY (1 << 1)
+
+/* Name of the directory for stashing local copy of mmap'ed filed.  */
+#define PCN_TMP_DIR ".pcn"
+
+#define RIO_FD_FILE 1
+#define RIO_FD_SOCKET 2
+#define RIO_FD_EPOLL 3
+#define RIO_FD_ACCEPT 3
+
+/* Might need also need to keep track of the parent process so that
+   if the application client forks, the rio_server can jump to its parent
+   fdinfo map and search for the FD there.  A negative FD indicates that
+   a file has been closed, but may still be mapped.  */
+struct fdinfo {
+  int fd;
+  mode_t mode;
+  int maps;
+  int flags;
+  unsigned int status;
+  unsigned int type;
+  char *name; /* Name of the original file.  */
+  char *lname; /* Name of the cached file.  */
+};
+
+struct mmapinfo {
+  struct fdinfo *pfd;
+  void *addr;
+  long len;
+  int prot;
+  int flags;
+};
+
+struct pcn_msg_open;
+
+extern struct fdinfo *rio_fd;
+extern struct mmapinfo *rio_mmap;
+
+// Need to add cleanup functions (rio_fd_destroy/rio_mmap_destroy)
+extern struct fdinfo *rio_fd_open (int fd, int flags, mode_t mode, char *name);
+extern struct fdinfo *rio_fd_open_special (int fd, int type);
+extern struct fdinfo *rio_fd_find (int fd);
+extern void rio_fd_rm (struct fdinfo *fd);
+
+/* List of closed file descriptors to support mmap writebacks.  */
+extern void rio_fd_add_closed (struct fdinfo *fd);
+extern void rio_fd_rm_closed (struct fdinfo *pfd);
+
+extern struct mmapinfo *rio_mmap_add (struct fdinfo *pfd, void *addr, int len, int prot, int flags);
+extern struct mmapinfo *rio_mmap_find (void *addr);
+extern void rio_mmap_rm (struct mmapinfo *map);
+
+extern int rio_file_create (int fd);
+extern int rio_file_rm (int fd);
+
+extern int rio_file_copy (int sockfd, int mid, struct fdinfo *pfd);
+extern int rio_file_sync (int sockfd, int mid, struct fdinfo *pfd);
+
+extern uint32_t pcn_get_ip (void);
+extern int rio_get_read (struct pcn_msg_hdr *hdr, int fd);
+extern void rio_get_write (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_open (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_close (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_fxstatat (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_fallocate (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_mmap (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_munmap (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_epoll_create (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_epoll_ctl (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_epoll_wait (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_poll (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_sigaction (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_fcntl (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_getcwd (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_socket (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_bind (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_getsockopt (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_setsockopt (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_listen (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_pipe (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_accept (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_connect (struct pcn_msg_hdr *hdr, int fd);
+
+extern int rio_get_file (struct pcn_msg_open *msg, int fd);
+extern int rio_send_file (struct pcn_msg_hdr *hdr);
+extern void rio_init_tmpdir (void);
+extern void rio_maybe_zap_file (const char *fname);
+
+extern int rio_msg_id (void);
+
+extern int __do_fxstatat(int vers, int fd, const char *file, struct stat *st,
+			 int flag);
+
+extern int rio_disable (void);
+extern void rio_restore (int);
+
+#endif
diff --git a/remote_io/test-1.c b/remote_io/test-1.c
new file mode 100644
index 0000000000..b1e67c0314
--- /dev/null
+++ b/remote_io/test-1.c
@@ -0,0 +1,87 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64-popcorn-linux-gnu/sysroot/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64-popcorn-linux-gnu/sysroot/lib/ t.c
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+struct mmap_entries {
+  unsigned long start, size;
+};
+
+extern void _dl_rio_print_dso ();
+extern struct mmap_entries *_dl_rio_get_mmap_entries ();
+
+char msg[] = "munmap complete: ";
+char msg_fail[] = "failed\n";
+char msg_succ[] = "succeeded\n";
+
+int
+do_munmap (unsigned long addr, unsigned long len)
+{
+  int ret;
+
+  asm volatile ("syscall"
+		: "=a" (ret)
+		: "0"(SYS_munmap), "D"(addr), "S"(len));
+
+  return ret;
+}
+
+int
+do_write (int fd, unsigned long addr, unsigned long len)
+{
+  int ret;
+
+  asm volatile ("syscall"
+		: "=a" (ret)
+		: "0"(SYS_write), "D"(fd), "S"(addr), "d"(len)
+		: "rcx", "r11", "memory");
+
+  return ret;
+}
+
+int
+main ()
+{
+  struct mmap_entries *me;
+  unsigned long size;
+  int i, ret, len[3];
+  int ps = sysconf(_SC_PAGE_SIZE);
+
+  printf ("pid = %d\n", getpid ());
+
+  _dl_rio_print_dso ();
+
+  me = _dl_rio_get_mmap_entries ();
+
+  len[0] = strlen (msg);
+  len[1] = strlen (msg_fail);
+  len[2] = strlen (msg_succ);
+
+  for (i = 0; me[i].size != 0; i++)
+    {
+      //ret = syscall (SYS_munmap, me[i].start, me[i].size);
+      //ret = mprotect (&me[i].start, me[i].size, PROT_READ);
+
+      do_munmap (me[i].start, me[1].size);
+      do_write (1, msg, len[0]);
+
+      if (ret)
+	do_write (1, msg_fail, len[1]);
+      else
+	do_write (1, msg_succ, len[2]);
+
+//      if (ret)
+//	{
+//	  perror ("munmap");
+//	  printf ("  %lx - %d\n", me[i].start, me[i].size);
+//	}
+    }
+
+  while (i != 0)
+    ;
+
+  return 0;
+}
diff --git a/remote_io/test-fcntl.c b/remote_io/test-fcntl.c
new file mode 100644
index 0000000000..c6bfb98c78
--- /dev/null
+++ b/remote_io/test-fcntl.c
@@ -0,0 +1,17 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-fcntl.c -o tf.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-fcntl.c -o tf.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+
+int
+main ()
+{
+  printf ("stdin: %x\n", fcntl (0, F_GETFL, 0));
+  printf ("stdout: %x\n", fcntl (1, F_GETFL, 0));
+  printf ("stderr: %x\n", fcntl (2, F_GETFL, 0));
+
+  return 0;
+}
diff --git a/remote_io/test-getcwd.c b/remote_io/test-getcwd.c
new file mode 100644
index 0000000000..aca67d63ce
--- /dev/null
+++ b/remote_io/test-getcwd.c
@@ -0,0 +1,19 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-getcwd.c -o tg.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-getcwd.c -o tg.a64.exe -g
+
+#include <stdio.h>
+#include <unistd.h>
+#include <linux/limits.h>
+
+int
+main ()
+{
+  char pwd[PATH_MAX];
+
+  getcwd (pwd, PATH_MAX);
+  
+  printf ("pwd = %s\n", pwd);
+
+  return 0;
+}
diff --git a/remote_io/test-io.c b/remote_io/test-io.c
new file mode 100644
index 0000000000..426baec2d8
--- /dev/null
+++ b/remote_io/test-io.c
@@ -0,0 +1,41 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ epoll.c -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ epoll.c -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/epoll.h>
+
+int
+main ()
+{
+  int res;
+  int epfd;
+  struct epoll_event event;
+
+  event.events = EPOLLIN;
+  event.data.u32 = 0;
+  
+  epfd = epoll_create (1);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  printf ("enter a number: ");
+  fflush (stdout);
+
+  if (epoll_wait (epfd, &event, 1, 1000) == 0)
+    printf ("missing number\n");
+  else
+    {
+      scanf ("%d", &res);
+      printf ("entered: %d\n", res);
+    }
+  
+  return 0;
+}
diff --git a/remote_io/test-libepoll-test.c b/remote_io/test-libepoll-test.c
new file mode 100644
index 0000000000..511f4cd2e8
--- /dev/null
+++ b/remote_io/test-libepoll-test.c
@@ -0,0 +1,58 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ -Wl,-rpath,$(pwd) -L. -lepoll -o etest.x86.exe test-libepoll.c
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ -L. -lepoll -o etest.x86.exe test-epoll.c
+
+#include <stdio.h>
+#include <stdio_ext.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+
+char
+getval ()
+{
+  char c = -1;
+  int epfd;
+  struct epoll_event event;
+
+  __fpurge (stdin);
+
+  event.events = EPOLLIN;
+  event.data.u32 = 0;
+  
+  epfd = epoll_create (1);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  printf ("enter a number: ");
+  fflush (stdout);
+
+  if (epoll_wait (epfd, &event, 1, 1000))
+    {
+      scanf ("%c", &c);
+      printf ("user entered '%c'\n", c);
+    }
+  else
+    printf ("local epoll timed out\n");
+  
+  return c;
+}
+
+extern int getnum (void);
+
+int
+main ()
+{
+  int num = getnum ();
+
+  if (num < 0)
+    printf ("epoll timer expired\n");
+  else
+    printf ("user entered %d\n", num);
+
+  getval ();
+  
+  return 0;
+}
+
diff --git a/remote_io/test-libepoll.c b/remote_io/test-libepoll.c
new file mode 100644
index 0000000000..b03b3714de
--- /dev/null
+++ b/remote_io/test-libepoll.c
@@ -0,0 +1,34 @@
+// gcc -shared -fpic libepoll.c -o libepoll.so
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/epoll.h>
+
+int
+getnum ()
+{
+  int res = -1;
+  int epfd;
+  struct epoll_event event;
+
+  event.events = EPOLLIN;
+  event.data.u32 = 0;
+  
+  epfd = epoll_create (1);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  printf ("enter a number: ");
+  fflush (stdout);
+
+  if (epoll_wait (epfd, &event, 1, 1000))
+    scanf ("%d", &res);
+  
+  return res;
+}
diff --git a/remote_io/test-mmap.c b/remote_io/test-mmap.c
new file mode 100644
index 0000000000..33768de799
--- /dev/null
+++ b/remote_io/test-mmap.c
@@ -0,0 +1,30 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ mmap-test.c -g -o mmap.x86.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ mmap-test.c -g -o mmap.a64.exe
+
+#define _GNU_SOURCE
+
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+
+int
+main ()
+{
+  const char msg[] = "abcdefghijklmnopqrstuvwxyz\n";
+  int fd = open ("test.123", O_CREAT|O_TRUNC|O_RDWR, 0644);
+  char *addr;
+
+  fallocate (fd, FALLOC_FL_ZERO_RANGE, 0, strlen (msg));
+  
+  addr = mmap (NULL, strlen (msg), PROT_WRITE, MAP_SHARED, fd, 0);
+
+  strcpy (addr, msg);
+
+  //close (fd);
+  munmap (addr, strlen (msg));
+  close (fd);
+
+ return 0;
+}
diff --git a/remote_io/test-pipe.c b/remote_io/test-pipe.c
new file mode 100644
index 0000000000..44807407a9
--- /dev/null
+++ b/remote_io/test-pipe.c
@@ -0,0 +1,26 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-pipe.c -o tp.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-pipe.c -o tp.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+int
+main ()
+{
+  int pfds[2], res;
+  char out[7], *in = "hello\n"; // length 7
+
+  res = pipe (pfds);
+  if (res < 0)
+    exit (EXIT_FAILURE);
+
+  write (pfds[1], in, 7);
+  read (pfds[0], out, 7);
+
+  write (STDOUT_FILENO, out, 7);
+  
+  return 0;
+}
diff --git a/remote_io/test-sigint-2.c b/remote_io/test-sigint-2.c
new file mode 100644
index 0000000000..7b00b15aff
--- /dev/null
+++ b/remote_io/test-sigint-2.c
@@ -0,0 +1,42 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-sigint-2.c -o ts-2.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-sigint-2.c -o ts-2.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <remote_io.h>
+
+void
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  exit (EXIT_SUCCESS);
+}
+
+int
+main ()
+{
+  struct sigaction sa;
+  int d;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  pcn_unload_signals ();
+  printf ("unloaded signals\n");
+  
+  printf ("[%d] sigint test\n", getpid ());
+  scanf ("%d", &d);
+
+  pcn_restore_signals ();
+  printf ("restored signals\n");
+
+  scanf ("%d", &d);  
+  
+  return 0;
+}
diff --git a/remote_io/test-sigint.c b/remote_io/test-sigint.c
new file mode 100644
index 0000000000..005447e4e6
--- /dev/null
+++ b/remote_io/test-sigint.c
@@ -0,0 +1,33 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-sigint.c -o ts.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-sigint.c -o ts.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+
+void
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  exit (EXIT_SUCCESS);
+}
+
+int
+main ()
+{
+  struct sigaction sa;
+  int d;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  printf ("[%d] sigint test\n", getpid ());
+  scanf ("%d", &d);
+
+  return 0;
+}
diff --git a/remote_io/test-socket-server.c b/remote_io/test-socket-server.c
new file mode 100644
index 0000000000..c47ead493d
--- /dev/null
+++ b/remote_io/test-socket-server.c
@@ -0,0 +1,73 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-socket-server.c -g -o tss.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-socket-server.c -g -o tss.a64.exe
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <unistd.h>
+
+#include <string.h>
+
+#define PORT 3124
+
+int
+main (int argc, char *argv[])
+{
+  int sockfd, newsockfd, len;
+  char buffer[256];
+  struct sockaddr_in saddr, caddr;
+  int  n;
+
+  sockfd = socket (AF_INET, SOCK_STREAM, 0);
+
+  if (sockfd < 0)
+    {
+      perror("ERROR opening socket");
+      exit(1);
+    }
+
+  bzero ((char *) &saddr, sizeof (saddr));
+
+  saddr.sin_family = AF_INET;
+  saddr.sin_addr.s_addr = INADDR_ANY;
+  saddr.sin_port = htons(PORT);
+
+  if (bind(sockfd, (struct sockaddr *) &saddr, sizeof (saddr)) < 0)
+    {
+      perror("ERROR on binding");
+      exit(1);
+    }
+
+  listen (sockfd, 5);
+  len = sizeof (caddr);
+
+  newsockfd = accept (sockfd, (struct sockaddr *)&caddr, &len);
+
+  if (newsockfd < 0)
+    {
+      perror("ERROR on accept");
+      exit(1);
+    }
+
+  bzero (buffer,256);
+  n = read (newsockfd, buffer, 255);
+
+  if (n < 0)
+    {
+      perror("ERROR reading from socket");
+      exit(1);
+    }
+
+  printf ("received> %s\n", buffer);
+
+  if (n < 0)
+    {
+      perror("ERROR writing to socket");
+      exit(1);
+    }
+
+  return 0;
+}
diff --git a/sysdeps/aarch64/dl-machine.h b/sysdeps/aarch64/dl-machine.h
index 8ffa0d1c51..bde4f28107 100644
--- a/sysdeps/aarch64/dl-machine.h
+++ b/sysdeps/aarch64/dl-machine.h
@@ -126,6 +126,8 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 .type _dl_start_user, %function						\n\
 _start:									\n\
 	mov	" PTR "0, " PTR_SP "					\n\
+	// Preserve the frame pointer for reloading			\n\
+	mov	x28, x29						\n\
 	bl	_dl_start						\n\
 	// returns user entry point in x0				\n\
 	mov	x21, x0							\n\
@@ -177,6 +179,8 @@ _dl_start_user:								\n\
 	// load the finalizer function					\n\
 	adrp	x0, _dl_fini						\n\
 	add	" PTR "0, " PTR "0, #:lo12:_dl_fini			\n\
+	// Restore the frame pointer					\n\
+	mov	x29, x28						\n\
 	// jump to the user_s entry point				\n\
 	br      x21							\n\
 ");
diff --git a/sysdeps/aarch64/nptl/pthreaddef.h b/sysdeps/aarch64/nptl/pthreaddef.h
index 892b869fc2..8fb905dd0a 100644
--- a/sysdeps/aarch64/nptl/pthreaddef.h
+++ b/sysdeps/aarch64/nptl/pthreaddef.h
@@ -25,8 +25,8 @@
 /* Minimal stack size after allocating thread descriptor and guard size.  */
 #define MINIMAL_REST_STACK 2048
 
-/* Alignment requirement for TCB.  */
-#define TCB_ALIGNMENT 16
+/* Alignment requirement for TCB.  Bumped up to 64 for x86-64 compatibility.  */
+#define TCB_ALIGNMENT 64
 
 /* Location of current stack frame.  */
 #define CURRENT_STACK_FRAME	__builtin_frame_address (0)
diff --git a/sysdeps/aarch64/nptl/tls.h b/sysdeps/aarch64/nptl/tls.h
index e5627f777e..7b4a2c4813 100644
--- a/sysdeps/aarch64/nptl/tls.h
+++ b/sysdeps/aarch64/nptl/tls.h
@@ -64,6 +64,9 @@ typedef struct
 /* Alignment requirements for the TCB.  */
 # define TLS_TCB_ALIGN		__alignof__ (struct pthread)
 
+/* Popcorn Linux Padding.  */
+# define TLS_TCB_PCN_PAD	0x40
+
 /* Install the dtv pointer.  The pointer passed is to the element with
    index -1 which contain the length.  */
 # define INSTALL_DTV(tcbp, dtvp) \
@@ -80,6 +83,7 @@ typedef struct
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
    operation can cause a failure 'errno' must not be touched.  */
+/* Might need to set tcbp->private = tcbp for x86-64.  */
 # define TLS_INIT_TP(tcbp) \
   ({ __asm __volatile ("msr tpidr_el0, %0" : : "r" (tcbp)); NULL; })
 
@@ -94,6 +98,9 @@ typedef struct
 # define THREAD_SELF \
  ((struct pthread *)__builtin_thread_pointer () - 1)
 
+# define GET_TP \
+  ({ void *tp; __asm __volatile ("mrs %0, tpidr_el0" : "=r" (tp)); tp;})
+
 /* Magic for libthread_db to know how to do THREAD_SELF.  */
 # define DB_THREAD_SELF \
   CONST_THREAD_AREA (64, sizeof (struct pthread))
diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
index 5fbde369c3..e967db485a 100644
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -59,10 +59,11 @@ include $(firstword $(wildcard $(sysdirs:=/sysctl.mk)))
 sysdep_routines += adjtimex clone umount umount2 readahead \
 		   setfsuid setfsgid epoll_pwait signalfd \
 		   eventfd eventfd_read eventfd_write prlimit \
-		   personality epoll_wait tee vmsplice splice \
+		   personality tee vmsplice splice \
 		   open_by_handle_at mlock2 pkey_mprotect pkey_set pkey_get \
 		   prctl \
-		   process_vm_readv process_vm_writev
+		   process_vm_readv process_vm_writev \
+		   epoll_create epoll_ctl epoll_wait
 
 CFLAGS-gethostid.c = -fexceptions
 CFLAGS-tee.c = -fexceptions -fasynchronous-unwind-tables
diff --git a/sysdeps/unix/sysv/linux/Versions b/sysdeps/unix/sysv/linux/Versions
index d385085c61..be53a63adc 100644
--- a/sysdeps/unix/sysv/linux/Versions
+++ b/sysdeps/unix/sysv/linux/Versions
@@ -177,6 +177,9 @@ libc {
   GLIBC_2.30 {
     getdents64; gettid; tgkill;
   }
+  GLIBC_2.31 {
+    epoll_create; epoll_ctl; epoll_wait;
+  }
   GLIBC_PRIVATE {
     # functions used in other libraries
     __syscall_rt_sigqueueinfo;
@@ -187,5 +190,6 @@ libc {
     __sigtimedwait;
     # functions used by nscd
     __netlink_assert_response;
+    __do_fxstatat;
   }
 }
diff --git a/sysdeps/unix/sysv/linux/__libc_start_main_popcorn.c b/sysdeps/unix/sysv/linux/__libc_start_main_popcorn.c
new file mode 100644
index 0000000000..2b12fa7010
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/__libc_start_main_popcorn.c
@@ -0,0 +1,20 @@
+/* Build instructions:
+
+clang -O0 -fno-common -popcorn-libc -mllvm -optimize-regalloc \
+     -target aarch64-linux-gnu -S __libc_start_main_popcorn.c -fno-addrsig
+
+clang -O0 -fno-common -popcorn-libc -mllvm -optimize-regalloc \
+     -target x86_64-linux-gnu -S __libc_start_main_popcorn.c -fno-addrsig
+*/
+
+/* Wrapper function of __libc_start_main.  */
+
+#include <stdlib.h>
+
+int __libc_start_main_popcorn (int (*main) (int, char **, char **),
+			       int argc, char **argv, char **environ)
+{
+  exit (main (argc, argv, environ));
+
+  return 0;
+}
diff --git a/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c b/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c
index 0e3c7f76df..37c649aa27 100644
--- a/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c
+++ b/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c
@@ -16,5 +16,5 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define USE_IFUNC_GETTIMEOFDAY
+/* #define USE_IFUNC_GETTIMEOFDAY */
 #include <sysdeps/unix/sysv/linux/gettimeofday.c>
diff --git a/sysdeps/unix/sysv/linux/aarch64/kernel-features.h b/sysdeps/unix/sysv/linux/aarch64/kernel-features.h
index 5f301bed6c..61c8930d06 100644
--- a/sysdeps/unix/sysv/linux/aarch64/kernel-features.h
+++ b/sysdeps/unix/sysv/linux/aarch64/kernel-features.h
@@ -21,3 +21,13 @@
 
 #undef __ASSUME_CLONE_DEFAULT
 #define __ASSUME_CLONE_BACKWARDS 1
+
+# define __ASSUME_SOCKET_SYSCALL             1
+# define __ASSUME_SOCKETPAIR_SYSCALL         1
+# define __ASSUME_BIND_SYSCALL               1
+# define __ASSUME_LISTEN_SYSCALL             1
+# define __ASSUME_GETSOCKOPT_SYSCALL         1
+# define __ASSUME_SETSOCKOPT_SYSCALL         1
+# define __ASSUME_GETSOCKNAME_SYSCALL        1
+# define __ASSUME_GETPEERNAME_SYSCALL        1
+# define __ASSUME_SHUTDOWN_SYSCALL           1
diff --git a/sysdeps/unix/sysv/linux/accept.c b/sysdeps/unix/sysv/linux/accept.c
index f6021a75e7..aef98eadcf 100644
--- a/sysdeps/unix/sysv/linux/accept.c
+++ b/sysdeps/unix/sysv/linux/accept.c
@@ -18,10 +18,14 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <remote_io/remote_io.h>
 
 int
 __libc_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_accept (fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_ACCEPT_SYSCALL
   return SYSCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
 #elif defined __ASSUME_ACCEPT4_SYSCALL
@@ -29,6 +33,7 @@ __libc_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 #else
   return SOCKETCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
 #endif
+#endif
 }
 weak_alias (__libc_accept, accept)
 libc_hidden_def (accept)
diff --git a/sysdeps/unix/sysv/linux/bind.c b/sysdeps/unix/sysv/linux/bind.c
index da2ed19a33..f5e37d900a 100644
--- a/sysdeps/unix/sysv/linux/bind.c
+++ b/sysdeps/unix/sysv/linux/bind.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_bind (fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_BIND_SYSCALL
   return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, len);
 #else
   return SOCKETCALL (bind, fd, addr.__sockaddr__, len, 0, 0, 0);
 #endif
+#endif
 }
 weak_alias (__bind, bind)
diff --git a/sysdeps/unix/sysv/linux/close.c b/sysdeps/unix/sysv/linux/close.c
index 602ab558e6..ca7448a050 100644
--- a/sysdeps/unix/sysv/linux/close.c
+++ b/sysdeps/unix/sysv/linux/close.c
@@ -19,12 +19,17 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 /* Close the file descriptor FD.  */
 int
 __close (int fd)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_close (fd);
+#else
   return SYSCALL_CANCEL (close, fd);
+#endif
 }
 libc_hidden_def (__close)
 strong_alias (__close, __libc_close)
diff --git a/sysdeps/unix/sysv/linux/close_nocancel.c b/sysdeps/unix/sysv/linux/close_nocancel.c
index 23ebcd0df5..249fc243b7 100644
--- a/sysdeps/unix/sysv/linux/close_nocancel.c
+++ b/sysdeps/unix/sysv/linux/close_nocancel.c
@@ -19,10 +19,15 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 int
 __close_nocancel (int fd)
 {
+#if IS_IN(libc) && defined SHARED
+  return pcn_close (fd);
+#else
   return INLINE_SYSCALL_CALL (close, fd);
+#endif
 }
 libc_hidden_def (__close_nocancel)
diff --git a/sysdeps/unix/sysv/linux/connect.c b/sysdeps/unix/sysv/linux/connect.c
index 0e970b41ed..ffc4eaaa3f 100644
--- a/sysdeps/unix/sysv/linux/connect.c
+++ b/sysdeps/unix/sysv/linux/connect.c
@@ -18,15 +18,20 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <remote_io/remote_io.h>
 
 int
 __libc_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_connect (fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_CONNECT_SYSCALL
   return SYSCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
 #else
   return SOCKETCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
 #endif
+#endif
 }
 weak_alias (__libc_connect, connect)
 weak_alias (__libc_connect, __connect)
diff --git a/sysdeps/unix/sysv/linux/dl-sysdep.h b/sysdeps/unix/sysv/linux/dl-sysdep.h
index 8ed45503e7..de8182719e 100644
--- a/sysdeps/unix/sysv/linux/dl-sysdep.h
+++ b/sysdeps/unix/sysv/linux/dl-sysdep.h
@@ -23,7 +23,7 @@
    machines, we should look at it for unwind information even if
    we aren't making direct use of it.  So enable this across the board.  */
 
-#define NEED_DL_SYSINFO_DSO	1
+#define NEED_DL_SYSINFO_DSO	0
 
 
 #ifndef __ASSEMBLER__
diff --git a/sysdeps/unix/sysv/linux/generic/epoll_create.c b/sysdeps/unix/sysv/linux/epoll_create.c
similarity index 86%
rename from sysdeps/unix/sysv/linux/generic/epoll_create.c
rename to sysdeps/unix/sysv/linux/epoll_create.c
index e3eac4a7ac..cdc84aa943 100644
--- a/sysdeps/unix/sysv/linux/generic/epoll_create.c
+++ b/sysdeps/unix/sysv/linux/epoll_create.c
@@ -21,8 +21,8 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/epoll.h>
-
-libc_hidden_proto (epoll_create)
+#include <remote_io/remote_io.h>
+#include <remote_io/local_io.h>
 
 int
 epoll_create (int size)
@@ -33,6 +33,10 @@ epoll_create (int size)
       return -1;
     }
 
-  return INLINE_SYSCALL (epoll_create1, 1, 0);
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_create (size);
+#else
+  return __do_epoll_create ();
+#endif
 }
 libc_hidden_def (epoll_create)
diff --git a/sysdeps/unix/sysv/linux/epoll_ctl.c b/sysdeps/unix/sysv/linux/epoll_ctl.c
new file mode 100644
index 0000000000..6fd39d6bc9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/epoll_ctl.c
@@ -0,0 +1,44 @@
+/* Linux epoll_ctl implementation.
+   Copyright (C) 2017-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/epoll.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <remote_io/remote_io.h>
+
+/* Match PCN_EPOLL_NEW on x86-64.  */
+#define PCN_EPOLL_DEFAULT 1
+
+int
+__do_epoll_ctl (int ver, int epfd, int op, int fd, struct epoll_event *event)
+{
+  return INLINE_SYSCALL (epoll_ctl, 4, epfd, op, fd, event);
+}
+
+int
+epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_ctl (PCN_EPOLL_DEFAULT, epfd, op, fd, event);
+#else
+  return __do_epoll_ctl (PCN_EPOLL_DEFAULT, epfd, op, fd, event);
+#endif
+}
+libc_hidden_def (epoll_ctl)
\ No newline at end of file
diff --git a/sysdeps/unix/sysv/linux/epoll_wait.c b/sysdeps/unix/sysv/linux/epoll_wait.c
index 4e343b9344..5665989cc9 100644
--- a/sysdeps/unix/sysv/linux/epoll_wait.c
+++ b/sysdeps/unix/sysv/linux/epoll_wait.c
@@ -22,13 +22,30 @@
 #include <sys/epoll.h>
 
 #include <sysdep-cancel.h>
+#include <remote_io.h>
+
+/* Match PCN_EPOLL_NEW on x86-64.  */
+#define PCN_EPOLL_DEFAULT 1
 
 int
-epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout)
+__do_epoll_wait (int ver, int epfd, struct epoll_event *events,
+		 int maxevents, int timeout)
 {
-#ifdef __NR_epoll_wait
+  #ifdef __NR_epoll_wait
   return SYSCALL_CANCEL (epoll_wait, epfd, events, maxevents, timeout);
 #else
   return epoll_pwait (epfd, events, maxevents, timeout, NULL);
 #endif
 }
+
+int
+epoll_wait (int epfd, struct epoll_event *events, int maxevents,
+	      int timeout)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_wait (PCN_EPOLL_DEFAULT, epfd, events, maxevents, timeout);
+#else
+  return __do_epoll_wait (PCN_EPOLL_DEFAULT, epfd, events, maxevents, timeout);
+#endif
+}
+libc_hidden_def (epoll_wait)
diff --git a/sysdeps/unix/sysv/linux/fallocate.c b/sysdeps/unix/sysv/linux/fallocate.c
index e40d0c4a23..e33de2c7ea 100644
--- a/sysdeps/unix/sysv/linux/fallocate.c
+++ b/sysdeps/unix/sysv/linux/fallocate.c
@@ -18,13 +18,18 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 #ifndef __OFF_T_MATCHES_OFF64_T
 /* Reserve storage for the data of the file associated with FD.  */
 int
 fallocate (int fd, int mode, __off_t offset, __off_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_fallocate (fd, mode, offset, len);
+#else
   return SYSCALL_CANCEL (fallocate, fd, mode,
 			 SYSCALL_LL (offset), SYSCALL_LL (len));
+#endif
 }
 #endif
diff --git a/sysdeps/unix/sysv/linux/fallocate64.c b/sysdeps/unix/sysv/linux/fallocate64.c
index b2d2fab797..601a4310e3 100644
--- a/sysdeps/unix/sysv/linux/fallocate64.c
+++ b/sysdeps/unix/sysv/linux/fallocate64.c
@@ -18,14 +18,19 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 
 /* Reserve storage for the data of the file associated with FD.  */
 int
 fallocate64 (int fd, int mode, __off64_t offset, __off64_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_fallocate (fd, mode, offset, len);
+#else
   return SYSCALL_CANCEL (fallocate, fd, mode,
 			 SYSCALL_LL64 (offset), SYSCALL_LL64 (len));
+#endif
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/fcntl_nocancel.c b/sysdeps/unix/sysv/linux/fcntl_nocancel.c
index bafc1cff5f..c3652a678b 100644
--- a/sysdeps/unix/sysv/linux/fcntl_nocancel.c
+++ b/sysdeps/unix/sysv/linux/fcntl_nocancel.c
@@ -21,6 +21,7 @@
 #include <errno.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 #ifndef __NR_fcntl64
 # define __NR_fcntl64 __NR_fcntl
@@ -61,5 +62,10 @@ __fcntl64_nocancel_adjusted (int fd, int cmd, void *arg)
         (INTERNAL_SYSCALL_ERRNO (res, err));
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  if (cmd == F_GETFL || cmd == F_SETFL || F_GETFD)
+    return pcn_fcntl (fd, cmd, (void *) arg);
+#endif
+
   return INLINE_SYSCALL_CALL (fcntl64, fd, cmd, (void *) arg);
 }
diff --git a/sysdeps/unix/sysv/linux/fxstatat.c b/sysdeps/unix/sysv/linux/fxstatat.c
index 524d5a6df6..d633f160da 100644
--- a/sysdeps/unix/sysv/linux/fxstatat.c
+++ b/sysdeps/unix/sysv/linux/fxstatat.c
@@ -29,12 +29,13 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <remote_io.h>
+#include <remote_io/server.h>
 
 #include <xstatconv.h>
 
-/* Get information about the file NAME in BUF.  */
 int
-__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+__do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
 {
   int result;
   INTERNAL_SYSCALL_DECL (err);
@@ -57,6 +58,22 @@ __fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
     return INLINE_SYSCALL_ERROR_RETURN_VALUE (INTERNAL_SYSCALL_ERRNO (result,
 								      err));
 }
+libc_hidden_def (__do_fxstatat)
+
+/* Get information about the file NAME in BUF.  */
+int
+__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  int result;
+  INTERNAL_SYSCALL_DECL (err);
+
+#if IS_IN(libc) && defined SHARED
+  result = pcn_fxstatat (vers, fd, file, &kst, flag);
+#else
+  result = __do_fxstatat (vers, fd, file, st, flag);
+#endif
+  return result;
+}
 libc_hidden_def (__fxstatat)
 #if XSTAT_IS_XSTAT64
 # undef __fxstatat64
diff --git a/sysdeps/unix/sysv/linux/generic/Makefile b/sysdeps/unix/sysv/linux/generic/Makefile
index 124f83a0ab..cd01726b15 100644
--- a/sysdeps/unix/sysv/linux/generic/Makefile
+++ b/sysdeps/unix/sysv/linux/generic/Makefile
@@ -1,3 +1,3 @@
 ifeq ($(subdir),misc)
-sysdep_routines += epoll_create inotify_init stat-check
+sysdep_routines += inotify_init stat-check
 endif
diff --git a/sysdeps/unix/sysv/linux/generic/pipe.c b/sysdeps/unix/sysv/linux/generic/pipe.c
index 5d4a95f3e7..35ed20eb83 100644
--- a/sysdeps/unix/sysv/linux/generic/pipe.c
+++ b/sysdeps/unix/sysv/linux/generic/pipe.c
@@ -19,6 +19,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <stddef.h>
+#include <remote_io/remote_io.h>
 
 /* Create a one-way communication channel (__pipe).
    If successful, two file descriptors are stored in PIPEDES;
@@ -27,7 +28,11 @@
 int
 __pipe (int __pipedes[2])
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pipe (__pipedes, 0);
+#else
   return INLINE_SYSCALL (pipe2, 2, __pipedes, 0);
+#endif
 }
 libc_hidden_def (__pipe)
 weak_alias (__pipe, pipe)
diff --git a/sysdeps/unix/sysv/linux/generic/syscalls.list b/sysdeps/unix/sysv/linux/generic/syscalls.list
index ed8b216d47..664df694ce 100644
--- a/sysdeps/unix/sysv/linux/generic/syscalls.list
+++ b/sysdeps/unix/sysv/linux/generic/syscalls.list
@@ -1,12 +1,7 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
 # Socket APIs
-socket		-	socket		i:iii	__socket	socket
 socketpair	-	socketpair	i:iiif	__socketpair	socketpair
-bind		-	bind		i:ipi	__bind		bind
-listen		-	listen		i:ii	__listen	listen
 getsockname	-	getsockname	i:ipp	__getsockname	getsockname
 getpeername	-	getpeername	i:ipp	__getpeername	getpeername
-setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
-getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
 shutdown	-	shutdown	i:ii	__shutdown	shutdown
diff --git a/sysdeps/unix/sysv/linux/getcwd.c b/sysdeps/unix/sysv/linux/getcwd.c
index fabc4bb8cc..64532dfce0 100644
--- a/sysdeps/unix/sysv/linux/getcwd.c
+++ b/sysdeps/unix/sysv/linux/getcwd.c
@@ -26,6 +26,7 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 
 /* If we compile the file for use in ld.so we don't need the feature
@@ -75,7 +76,12 @@ __getcwd (char *buf, size_t size)
 
   int retval;
 
+#if !IS_IN(rtld) && defined SHARED
+  retval = pcn_getcwd (path, alloc_size);
+#else
   retval = INLINE_SYSCALL (getcwd, 2, path, alloc_size);
+#endif
+
   if (retval > 0 && path[0] == '/')
     {
 #ifndef NO_ALLOCATION
diff --git a/sysdeps/unix/sysv/linux/getsockopt.c b/sysdeps/unix/sysv/linux/getsockopt.c
index 11939660c1..844824839a 100644
--- a/sysdeps/unix/sysv/linux/getsockopt.c
+++ b/sysdeps/unix/sysv/linux/getsockopt.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __getsockopt (int fd, int level, int optname, void *optval, socklen_t *len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_getsockopt (fd, level, optname, optval, len);
+#else
 #ifdef __ASSUME_GETSOCKOPT_SYSCALL
   return INLINE_SYSCALL (getsockopt, 5, fd, level, optname, optval, len);
 #else
   return SOCKETCALL (getsockopt, fd, level, optname, optval, len);
 #endif
+#endif
 }
 weak_alias (__getsockopt, getsockopt)
diff --git a/sysdeps/unix/sysv/linux/listen.c b/sysdeps/unix/sysv/linux/listen.c
index 124c2fed74..4775e502d1 100644
--- a/sysdeps/unix/sysv/linux/listen.c
+++ b/sysdeps/unix/sysv/linux/listen.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 listen (int fd, int backlog)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_listen (fd, backlog);
+#else
 #ifdef __ASSUME_LISTEN_SYSCALL
   return INLINE_SYSCALL (listen, 2, fd, backlog);
 #else
   return SOCKETCALL (listen, fd, backlog);
 #endif
+#endif
 }
 weak_alias (listen, __listen);
diff --git a/sysdeps/unix/sysv/linux/mmap.c b/sysdeps/unix/sysv/linux/mmap.c
index 22f276bb14..a101a36239 100644
--- a/sysdeps/unix/sysv/linux/mmap.c
+++ b/sysdeps/unix/sysv/linux/mmap.c
@@ -21,6 +21,7 @@
 #include <sys/mman.h>
 #include <sysdep.h>
 #include <stdint.h>
+#include <remote_io/remote_io.h>
 
 #ifndef __OFF_T_MATCHES_OFF64_T
 # include <mmap_internal.h>
@@ -39,12 +40,22 @@ __mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset)
     return (void *) INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
 
 #ifdef __NR_mmap2
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd,
+  		   offset / (uint32_t) MMAP2_PAGE_UNIT);
+#else
   return (void *) MMAP_CALL (mmap2, addr, len, prot, flags, fd,
 			     offset / (uint32_t) MMAP2_PAGE_UNIT);
+#endif
+#else
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd,
+		   MMAP_ADJUST_OFFSET (offset));
 #else
   return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd,
 			     MMAP_ADJUST_OFFSET (offset));
 #endif
+#endif
 }
 weak_alias (__mmap, mmap)
 libc_hidden_def (__mmap)
diff --git a/sysdeps/unix/sysv/linux/mmap64.c b/sysdeps/unix/sysv/linux/mmap64.c
index 8074deb466..5363f950e6 100644
--- a/sysdeps/unix/sysv/linux/mmap64.c
+++ b/sysdeps/unix/sysv/linux/mmap64.c
@@ -22,6 +22,7 @@
 #include <sys/mman.h>
 #include <sysdep.h>
 #include <mmap_internal.h>
+#include <remote_io/remote_io.h>
 
 #ifdef __NR_mmap2
 /* To avoid silent truncation of offset when using mmap2, do not accept
@@ -53,11 +54,20 @@ __mmap64 (void *addr, size_t len, int prot, int flags, int fd, off64_t offset)
 
   MMAP_PREPARE (addr, len, prot, flags, fd, offset);
 #ifdef __NR_mmap2
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd,
+		   (off_t) (offset / MMAP2_PAGE_UNIT));
+#else
   return (void *) MMAP_CALL (mmap2, addr, len, prot, flags, fd,
 			     (off_t) (offset / MMAP2_PAGE_UNIT));
+#endif
+#else
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd, offset);
 #else
   return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd, offset);
 #endif
+#endif
 }
 weak_alias (__mmap64, mmap64)
 libc_hidden_def (__mmap64)
diff --git a/sysdeps/unix/sysv/linux/munmap.c b/sysdeps/unix/sysv/linux/munmap.c
new file mode 100644
index 0000000000..f74bc6c6ca
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/munmap.c
@@ -0,0 +1,37 @@
+/* mmap - map files or devices into memory.  Linux version.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sysdep.h>
+#include <stdint.h>
+#include <remote_io/remote_io.h>
+
+int
+__munmap (void *addr, size_t len)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_munmap (addr, len);
+#else
+  return (int) INLINE_SYSCALL_CALL (munmap, addr, len);
+#endif
+}
+
+weak_alias (__munmap, munmap)
+libc_hidden_def (__munmap)
diff --git a/sysdeps/unix/sysv/linux/open64.c b/sysdeps/unix/sysv/linux/open64.c
index f2d0c55810..8c7694e04d 100644
--- a/sysdeps/unix/sysv/linux/open64.c
+++ b/sysdeps/unix/sysv/linux/open64.c
@@ -20,6 +20,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdarg.h>
+#include <remote_io/remote_io.h>
 
 #include <sysdep-cancel.h>
 
@@ -45,8 +46,14 @@ __libc_open64 (const char *file, int oflag, ...)
       va_end (arg);
     }
 
+#if !IS_IN(rtld) && defined SHARED
+//  rio_dbg_printf ("%s: dirfd = %x, pathname = %s, flags = %x, mode = %x\n",
+//		  __FUNCTION__, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+  return pcn_openat (AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+#else
   return SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,
 			 mode);
+#endif
 }
 
 strong_alias (__libc_open64, __open64)
diff --git a/sysdeps/unix/sysv/linux/open64_nocancel.c b/sysdeps/unix/sysv/linux/open64_nocancel.c
index 6f4580a455..6248609c0a 100644
--- a/sysdeps/unix/sysv/linux/open64_nocancel.c
+++ b/sysdeps/unix/sysv/linux/open64_nocancel.c
@@ -20,6 +20,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdarg.h>
+#include <remote_io/remote_io.h>
 
 #include <not-cancel.h>
 
@@ -42,8 +43,13 @@ __open64_nocancel (const char *file, int oflag, ...)
       va_end (arg);
     }
 
+#if !IS_IN(rtld) && defined SHARED
+//  rio_dbg_printf ("%s: %x, %s, %x, %x\n", __FUNCTION__, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+  return pcn_openat (AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+#else
   return INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,
 			      mode);
+#endif
 }
 
 hidden_def (__open64_nocancel)
diff --git a/sysdeps/unix/sysv/linux/openat64_nocancel.c b/sysdeps/unix/sysv/linux/openat64_nocancel.c
index 80fe66210d..a63648d61c 100644
--- a/sysdeps/unix/sysv/linux/openat64_nocancel.c
+++ b/sysdeps/unix/sysv/linux/openat64_nocancel.c
@@ -1,3 +1,5 @@
+// This file needs to by updated to use pcn_open.  */
+
 /* Linux openat syscall implementation, LFS, non-cancellable.
    Copyright (C) 2018-2020 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/sysdeps/unix/sysv/linux/poll.c b/sysdeps/unix/sysv/linux/poll.c
index 1c41ade1b7..db1e018e32 100644
--- a/sysdeps/unix/sysv/linux/poll.c
+++ b/sysdeps/unix/sysv/linux/poll.c
@@ -21,12 +21,17 @@
 
 #include <sysdep-cancel.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __poll (struct pollfd *fds, nfds_t nfds, int timeout)
 {
 #ifdef __NR_poll
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_poll  (fds, nfds, timeout);
+#else
   return SYSCALL_CANCEL (poll, fds, nfds, timeout);
+#endif
 #else
   struct timespec timeout_ts;
   struct timespec *timeout_ts_p = NULL;
@@ -38,8 +43,12 @@ __poll (struct pollfd *fds, nfds_t nfds, int timeout)
       timeout_ts_p = &timeout_ts;
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_ppoll (fds, nfds, timeout_ts_p, NULL);
+#else
   return SYSCALL_CANCEL (ppoll, fds, nfds, timeout_ts_p, NULL, 0);
 #endif
+#endif
 }
 libc_hidden_def (__poll)
 weak_alias (__poll, poll)
diff --git a/sysdeps/unix/sysv/linux/ppoll.c b/sysdeps/unix/sysv/linux/ppoll.c
index 3fcd19efb4..970f0bb33b 100644
--- a/sysdeps/unix/sysv/linux/ppoll.c
+++ b/sysdeps/unix/sysv/linux/ppoll.c
@@ -22,7 +22,7 @@
 #include <sys/poll.h>
 #include <sysdep-cancel.h>
 #include <kernel-features.h>
-
+#include <remote_io/remote_io.h>
 
 int
 __ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
@@ -41,7 +41,11 @@ __ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
 # ifndef __NR_ppoll_time64
 #  define __NR_ppoll_time64 __NR_ppoll
 # endif
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_ppoll (fds, nfds, timeout, sigmask);
+#else
   return SYSCALL_CANCEL (ppoll_time64, fds, nfds, timeout, sigmask, _NSIG / 8);
+#endif
 #else
 # ifdef __NR_ppoll_time64
   int ret = SYSCALL_CANCEL (ppoll_time64, fds, nfds, timeout, sigmask,
@@ -61,9 +65,13 @@ __ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
       ts32 = valid_timespec64_to_timespec (*timeout);
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_ppoll (fds, nfds, timeout ? &ts32 : NULL, sigmask);
+#else
   return SYSCALL_CANCEL (ppoll, fds, nfds, timeout ? &ts32 : NULL, sigmask,
                          _NSIG / 8);
 #endif
+#endif
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/read.c b/sysdeps/unix/sysv/linux/read.c
index 64f558a587..f6fc16f693 100644
--- a/sysdeps/unix/sysv/linux/read.c
+++ b/sysdeps/unix/sysv/linux/read.c
@@ -18,12 +18,13 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 /* Read NBYTES into BUF from FD.  Return the number read or -1.  */
 ssize_t
 __libc_read (int fd, void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (read, fd, buf, nbytes);
+  return pcn_read (fd, buf, nbytes);
 }
 libc_hidden_def (__libc_read)
 
diff --git a/sysdeps/unix/sysv/linux/read_nocancel.c b/sysdeps/unix/sysv/linux/read_nocancel.c
index f9d8a3b563..b7839cc224 100644
--- a/sysdeps/unix/sysv/linux/read_nocancel.c
+++ b/sysdeps/unix/sysv/linux/read_nocancel.c
@@ -19,10 +19,15 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 ssize_t
 __read_nocancel (int fd, void *buf, size_t nbytes)
 {
+#if IS_IN(libc) && defined SHARED
+  return pcn_read (fd, buf, nbytes);
+#else
   return INLINE_SYSCALL_CALL (read, fd, buf, nbytes);
+#endif
 }
 hidden_def (__read_nocancel)
diff --git a/sysdeps/unix/sysv/linux/setsockopt.c b/sysdeps/unix/sysv/linux/setsockopt.c
index 20c0868783..081a357246 100644
--- a/sysdeps/unix/sysv/linux/setsockopt.c
+++ b/sysdeps/unix/sysv/linux/setsockopt.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 setsockopt (int fd, int level, int optname, const void *optval, socklen_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_setsockopt (fd, level, optname, optval, len);
+#else
 #ifdef __ASSUME_SETSOCKOPT_SYSCALL
   return INLINE_SYSCALL (setsockopt, 5, fd, level, optname, optval, len);
 #else
   return SOCKETCALL (setsockopt, fd, level, optname, optval, len);
 #endif
+#endif
 }
 weak_alias (setsockopt, __setsockopt)
diff --git a/sysdeps/unix/sysv/linux/sigaction.c b/sysdeps/unix/sysv/linux/sigaction.c
index 4e6d11a6ae..8975fb757c 100644
--- a/sysdeps/unix/sysv/linux/sigaction.c
+++ b/sysdeps/unix/sysv/linux/sigaction.c
@@ -26,6 +26,8 @@
    architecture requires for compat mode and/or due old ABI.  */
 #include <kernel_sigaction.h>
 
+#include <remote_io/remote_io.h>
+
 #ifndef SA_RESTORER
 # define SET_SA_RESTORER(kact, act)
 # define RESET_SA_RESTORER(act, kact)
@@ -55,9 +57,15 @@ __libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
 
   /* XXX The size argument hopefully will have to be changed to the
      real size of the user-level sigset_t.  */
+#if !IS_IN(rtld) && defined SHARED
+  result = pcn_sigaction (sig,
+			  act ? &kact : NULL,
+			  oact ? &koact : NULL, STUB (act, _NSIG / 8));
+#else
   result = INLINE_SYSCALL_CALL (rt_sigaction, sig,
 				act ? &kact : NULL,
 				oact ? &koact : NULL, STUB (act, _NSIG / 8));
+#endif
 
   if (oact && result >= 0)
     {
diff --git a/sysdeps/unix/sysv/linux/socket.c b/sysdeps/unix/sysv/linux/socket.c
index efa0e34467..75389e8066 100644
--- a/sysdeps/unix/sysv/linux/socket.c
+++ b/sysdeps/unix/sysv/linux/socket.c
@@ -22,15 +22,20 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __socket (int fd, int type, int domain)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_socket (fd, type, domain);
+#else
 #ifdef __ASSUME_SOCKET_SYSCALL
   return INLINE_SYSCALL (socket, 3, fd, type, domain);
 #else
   return SOCKETCALL (socket, fd, type, domain);
 #endif
+#endif
 }
 libc_hidden_def (__socket)
 weak_alias (__socket, socket)
diff --git a/sysdeps/unix/sysv/linux/syscalls.list b/sysdeps/unix/sysv/linux/syscalls.list
index 52e6dafc86..f633acaff9 100644
--- a/sysdeps/unix/sysv/linux/syscalls.list
+++ b/sysdeps/unix/sysv/linux/syscalls.list
@@ -7,9 +7,7 @@ capset		EXTRA	capset		i:pp	capset
 clock_adjtime	EXTRA	clock_adjtime	i:ip	__clock_adjtime		clock_adjtime
 create_module	EXTRA	create_module	3	__compat_create_module	create_module@GLIBC_2.0:GLIBC_2.23
 delete_module	EXTRA	delete_module	3	delete_module
-epoll_create	EXTRA	epoll_create	i:i	epoll_create
 epoll_create1	EXTRA	epoll_create1	i:i	epoll_create1
-epoll_ctl	EXTRA	epoll_ctl	i:iiip	epoll_ctl
 eventfd		EXTRA	eventfd2	i:ii	eventfd
 execve		-	execve		i:spp	__execve	execve
 flock		-	flock		i:ii	__flock		flock
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c b/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
index 24bfe847d7..c4cac5ed94 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
@@ -26,13 +26,19 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <fcntl.h>
+#include <remote_io.h>
 
 /* Get information about the file FD in BUF.  */
 int
 __fxstat (int vers, int fd, struct stat *buf)
 {
   if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
+#if IS_IN(libc) && defined SHARED
+    return pcn_fxstatat (_STAT_VER_LINUX, fd, "", buf, AT_EMPTY_PATH);
+#else
     return INLINE_SYSCALL (fstat, 2, fd, buf);
+#endif
 
   __set_errno (EINVAL);
   return -1;
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c b/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c
index b8f5ab562e..5fc6350c71 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c
@@ -28,7 +28,8 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
-
+#include <remote_io/remote_io.h>
+#include <remote_io/server.h>
 
 /* Get information about the file NAME relative to FD in ST.  */
 int
@@ -40,7 +41,11 @@ __fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
       return -1;
     }
 
+#if IS_IN(libc) && defined SHARED
+  return pcn_fxstatat (vers, fd, file, st, flag);
+#else
   return INLINE_SYSCALL (newfstatat, 4, fd, file, st, flag);
+#endif
 }
 libc_hidden_def (__fxstatat)
 #undef __fxstatat64
diff --git a/sysdeps/unix/sysv/linux/write.c b/sysdeps/unix/sysv/linux/write.c
index 7848f7de27..ae4420d74a 100644
--- a/sysdeps/unix/sysv/linux/write.c
+++ b/sysdeps/unix/sysv/linux/write.c
@@ -18,12 +18,18 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <popcorn.h>
+#include <remote_io/remote_io.h>
 
 /* Write NBYTES of BUF to FD.  Return the number written, or -1.  */
 ssize_t
 __libc_write (int fd, const void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (write, fd, buf, nbytes);
+
+  //rio_printf ("%s: fd = %d, bytes = %d\n", __FUNCTION__, fd, nbytes);
+
+  return pcn_write (fd, buf, nbytes);
+  //return SYSCALL_CANCEL (write, fd, buf, nbytes);
 }
 libc_hidden_def (__libc_write)
 
diff --git a/sysdeps/unix/sysv/linux/x86/bits/epoll.h b/sysdeps/unix/sysv/linux/x86/bits/epoll.h
index 0b34b3d623..6107197674 100644
--- a/sysdeps/unix/sysv/linux/x86/bits/epoll.h
+++ b/sysdeps/unix/sysv/linux/x86/bits/epoll.h
@@ -26,4 +26,6 @@ enum
 #define EPOLL_CLOEXEC EPOLL_CLOEXEC
   };
 
+#ifndef __x86_64__
 #define __EPOLL_PACKED __attribute__ ((__packed__))
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86/bits/stat.h b/sysdeps/unix/sysv/linux/x86/bits/stat.h
index 25dec69dda..d367667246 100644
--- a/sysdeps/unix/sysv/linux/x86/bits/stat.h
+++ b/sysdeps/unix/sysv/linux/x86/bits/stat.h
@@ -41,9 +41,69 @@
 # define _MKNOD_VER_LINUX	0
 #endif
 
-#define _STAT_VER		_STAT_VER_LINUX
+#define _STAT_VER_PCN		4
+#define _STAT_VER		_STAT_VER_PCN
+
+/* Generic struct stat from linux/generic/bits/stat.h.  */
+
+#if defined __USE_FILE_OFFSET64
+# define __field64(type, type64, name) type64 name
+#elif __WORDSIZE == 64 || defined __INO_T_MATCHES_INO64_T
+# if defined __INO_T_MATCHES_INO64_T && !defined __OFF_T_MATCHES_OFF64_T
+#  error "ino_t and off_t must both be the same type"
+# endif
+# define __field64(type, type64, name) type name
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
+# define __field64(type, type64, name) \
+  type name __attribute__((__aligned__ (__alignof__ (type64)))); int __##name##_pad
+#else
+# define __field64(type, type64, name) \
+  int __##name##_pad __attribute__((__aligned__ (__alignof__ (type64)))); type name
+#endif
 
 struct stat
+  {
+    __dev_t st_dev;		/* Device.  */
+    __field64(__ino_t, __ino64_t, st_ino);  /* File serial number. */
+    __mode_t st_mode;		/* File mode.  */
+    unsigned int st_nlink;	/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __dev_t __pad1;
+    __field64(__off_t, __off64_t, st_size);  /* Size of file, in bytes. */
+    unsigned int st_blksize;	/* Optimal block size for I/O.  */
+    int __pad2;
+    __field64(__blkcnt_t, __blkcnt64_t, st_blocks);  /* 512-byte blocks */
+#ifdef __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+    int __glibc_reserved[2];
+  };
+
+#undef __field64
+
+
+/* Legacy struct stat for non-Popcorn applications.  */
+struct stat_legacy
   {
     __dev_t st_dev;		/* Device.  */
 #ifndef __x86_64__
@@ -115,8 +175,46 @@ struct stat
   };
 
 #ifdef __USE_LARGEFILE64
-/* Note stat64 has the same shape as stat for x86-64.  */
 struct stat64
+  {
+    __dev_t st_dev;		/* Device.  */
+    __ino64_t st_ino;		/* File serial number. */
+    __mode_t st_mode;		/* File mode.  */
+    unsigned int st_nlink;		/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __dev_t __pad1;
+    __off64_t st_size;		/* Size of file, in bytes. */
+    unsigned int st_blksize;	/* Optimal block size for I/O.  */
+    int __pad2;
+    __blkcnt64_t st_blocks;	/* 512-byte blocks */
+#ifdef __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+    int __glibc_reserved[2];
+  };
+
+/* Note stat64 has the same shape as stat for x86-64.  */
+struct stat64_legacy
   {
     __dev_t st_dev;		/* Device.  */
 # ifdef __x86_64__
diff --git a/sysdeps/unix/sysv/linux/x86/gettimeofday.c b/sysdeps/unix/sysv/linux/x86/gettimeofday.c
index 1b7aa880a2..361f09ff8a 100644
--- a/sysdeps/unix/sysv/linux/x86/gettimeofday.c
+++ b/sysdeps/unix/sysv/linux/x86/gettimeofday.c
@@ -16,5 +16,5 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define USE_IFUNC_GETTIMEOFDAY
+/* #define USE_IFUNC_GETTIMEOFDAY */
 #include <sysdeps/unix/sysv/linux/gettimeofday.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/Versions b/sysdeps/unix/sysv/linux/x86_64/Versions
index 2a7ed280fd..eb0251a8a6 100644
--- a/sysdeps/unix/sysv/linux/x86_64/Versions
+++ b/sysdeps/unix/sysv/linux/x86_64/Versions
@@ -6,6 +6,10 @@ libc {
 
     modify_ldt;
   }
+  GLIBC_2.31.1 {
+    epoll_ctl;
+    epoll_wait;
+  }
 }
 
 librt {
diff --git a/sysdeps/unix/sysv/linux/x86_64/do_fxstatat.c b/sysdeps/unix/sysv/linux/x86_64/do_fxstatat.c
new file mode 100644
index 0000000000..ac6c4ef0b1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/do_fxstatat.c
@@ -0,0 +1,79 @@
+/* Copyright (C) 2005-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Ho hum, if fxstatat == fxstatat64 we must get rid of the prototype or gcc
+   will complain since they don't strictly match.  */
+#define __fxstatat64 __fxstatat64_disable
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <remote_io/remote_io.h>
+#include <remote_io/server.h>
+
+#include <xstatconv.h>
+
+void
+x86_stat_xconv (struct stat *st, struct stat_legacy *sl)
+{
+  st->st_dev = sl->st_dev;
+  st->st_ino = sl->st_ino;
+  st->st_mode = sl->st_mode;
+  st->st_nlink = sl->st_nlink;
+  st->st_uid = sl->st_uid;
+  st->st_gid = sl->st_gid;
+  st->st_rdev = sl->st_rdev;
+  st->st_size = sl->st_size;
+  st->st_blksize = sl->st_blksize;
+  st->st_blocks = sl->st_blocks;
+  memcpy (&st->st_atim, &sl->st_atim, sizeof (struct timespec));
+  memcpy (&st->st_mtim, &sl->st_ctim, sizeof (struct timespec));
+  memcpy (&st->st_ctim, &sl->st_mtim, sizeof (struct timespec));
+}
+
+int
+__do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  int result;
+  INTERNAL_SYSCALL_DECL (err);
+  struct stat_legacy kst;
+
+  if (vers == _STAT_VER_LINUX)
+    result = INTERNAL_SYSCALL (newfstatat, err, 4, fd, file, st, flag);
+  else
+    result = INTERNAL_SYSCALL (newfstatat, err, 4, fd, file, &kst, flag);
+
+  if (!__builtin_expect (INTERNAL_SYSCALL_ERROR_P (result, err), 1))
+    {
+      if (vers == _STAT_VER_PCN)
+	x86_stat_xconv (st, &kst);
+
+      return 0;
+    }
+  else
+    return INLINE_SYSCALL_ERROR_RETURN_VALUE (INTERNAL_SYSCALL_ERRNO (result,
+								      err));
+}
+libc_hidden_def (__do_fxstatat)
+
diff --git a/sysdeps/unix/sysv/linux/x86_64/epoll_ctl.c b/sysdeps/unix/sysv/linux/x86_64/epoll_ctl.c
new file mode 100644
index 0000000000..8df4b427c8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/epoll_ctl.c
@@ -0,0 +1,89 @@
+/* Linux epoll_ctl implementation.
+   Copyright (C) 2017-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/epoll.h>
+#include <shlib-compat.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <remote_io/remote_io.h>
+
+#define PCN_EPOLL_OLD 0
+#define PCN_EPOLL_NEW 1
+
+struct linux_epoll_event
+{
+  uint32_t events;      /* Epoll events */
+  epoll_data_t data;    /* User data variable */
+} __attribute__ ((packed));
+
+int __new_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event);
+int __old_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event);
+
+libc_hidden_proto (__new_epoll_ctl)
+libc_hidden_proto (__old_epoll_ctl)
+
+int
+__do_epoll_ctl (int ver, int epfd, int op, int fd, struct epoll_event *event)
+{
+  int res;
+  struct linux_epoll_event lee;
+
+  if (ver == PCN_EPOLL_OLD)
+    return INLINE_SYSCALL (epoll_ctl, 4, epfd, op, fd, event);
+
+  lee.events = event->events;
+  lee.data.u64 = event->data.u64;
+
+  res = INLINE_SYSCALL (epoll_ctl, 4, epfd, op, fd, &lee);
+
+  return res;
+}
+
+int
+__new_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_ctl (PCN_EPOLL_NEW, epfd, op, fd, event);
+#else
+  return __do_epoll_ctl (PCN_EPOLL_NEW, epfd, op, fd, event);
+#endif
+}
+libc_hidden_def (__new_epoll_ctl)
+//libc_hidden_ver (__new_epoll_ctl, epoll_ctl)
+
+versioned_symbol (libc, __new_epoll_ctl, epoll_ctl, GLIBC_2_31_1);
+//strong_alias (__new_epoll_ctl, epoll_ctl)
+//default_symbol_version (__new_epoll_ctl, epoll_ctl, GLIBC_2_31_1);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_2, GLIBC_2_31_1)
+
+int
+attribute_compat_text_section
+__old_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_ctl (PCN_EPOLL_OLD, epfd, op, fd, event);
+#else
+  return __do_epoll_ctl (PCN_EPOLL_OLD, epfd, op, fd, event);
+#endif
+}
+libc_hidden_def (__old_epoll_ctl)
+compat_symbol (libc, __old_epoll_ctl, epoll_ctl, GLIBC_2_3_2);
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/epoll_wait.c b/sysdeps/unix/sysv/linux/x86_64/epoll_wait.c
new file mode 100644
index 0000000000..745158f1db
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/epoll_wait.c
@@ -0,0 +1,100 @@
+/* Linux epoll_wait syscall implementation.
+   Copyright (C) 2017-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/epoll.h>
+
+#include <shlib-compat.h>
+#include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
+
+#define PCN_EPOLL_OLD 0
+#define PCN_EPOLL_NEW 1
+
+struct linux_epoll_event
+{
+  uint32_t events;      /* Epoll events */
+  epoll_data_t data;    /* User data variable */
+} __attribute__ ((packed));
+
+int __new_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout);
+int __old_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout);
+
+libc_hidden_proto (__new_epoll_wait)
+libc_hidden_proto (__old_epoll_wait)
+
+int
+__do_epoll_wait (int ver, int epfd, struct epoll_event *events,
+		 int maxevents, int timeout)
+{
+  if (ver == PCN_EPOLL_OLD)
+#ifdef __NR_epoll_wait
+    return SYSCALL_CANCEL (epoll_wait, epfd, events, maxevents, timeout);
+#else
+    return epoll_pwait (epfd, events, maxevents, timeout, NULL);
+#endif
+
+  int res, i;
+  struct linux_epoll_event lee[maxevents];
+
+#ifdef __NR_epoll_wait
+  res = SYSCALL_CANCEL (epoll_wait, epfd, lee, maxevents, timeout);
+#else
+  res = epoll_pwait (epfd, lee, maxevents, timeout, NULL);
+#endif
+
+  if (res <= 0)
+    return res;
+
+  for (i = 0; i < res; i++)
+    {
+      events[i].events = lee[i].events;
+      events[i].data.u64 = lee[i].data.u64;
+    }
+
+  return res;
+}
+
+int
+__new_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_wait (PCN_EPOLL_NEW, epfd, events, maxevents, timeout);
+#else
+  return __do_epoll_wait (PCN_EPOLL_NEW, epfd, events, maxevents, timeout);
+#endif
+}
+libc_hidden_def (__new_epoll_wait)
+versioned_symbol (libc, __new_epoll_wait, epoll_wait, GLIBC_2_31_1);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_2, GLIBC_2_31)
+int
+attribute_compat_text_section
+__old_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_wait (PCN_EPOLL_OLD, epfd, events, maxevents, timeout);
+#else
+  return __do_epoll_wait (PCN_EPOLL_OLD, epfd, events, maxevents, timeout);
+#endif
+}
+libc_hidden_def (__old_epoll_wait);
+compat_symbol (libc, __old_epoll_wait, epoll_wait, GLIBC_2_3_2);
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/fxstat.c b/sysdeps/unix/sysv/linux/x86_64/fxstat.c
new file mode 100644
index 0000000000..01c6c2830f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/fxstat.c
@@ -0,0 +1,67 @@
+/* fxstat using old-style Unix fstat system call.
+   Copyright (C) 1991-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Ho hum, if xstat == xstat64 we must get rid of the prototype or gcc
+   will complain since they don't strictly match.  */
+#define __fxstat64 __fxstat64_disable
+
+#include <errno.h>
+#include <stddef.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <xstatconv.h>
+
+extern void x86_stat_xconv (struct stat *st, struct stat_legacy *sl);
+
+/* Get information about the file FD in BUF.  */
+int
+__fxstat (int vers, int fd, struct stat *buf)
+{
+  struct stat_legacy sl;
+  int res;
+
+#if IS_IN(libc) && defined SHARED
+  return pcn_fxstatat (vers, fd, "", buf, AT_EMPTY_PATH);
+#else
+  if (vers == _STAT_VER_KERNEL)
+    return INLINE_SYSCALL (fstat, 2, fd, buf);
+
+  res = INLINE_SYSCALL (fstat, 2, fd, &sl);
+
+  if (res)
+    return res;
+
+  x86_stat_xconv (buf, &sl);
+
+  return 0;
+#endif
+}
+
+hidden_def (__fxstat)
+weak_alias (__fxstat, _fxstat);
+
+#undef __fxstat64
+strong_alias (__fxstat, __fxstat64);
+hidden_ver (__fxstat, __fxstat64)
+
diff --git a/sysdeps/unix/sysv/linux/x86_64/kernel-features.h b/sysdeps/unix/sysv/linux/x86_64/kernel-features.h
index 80ff5684a7..8185c060af 100644
--- a/sysdeps/unix/sysv/linux/x86_64/kernel-features.h
+++ b/sysdeps/unix/sysv/linux/x86_64/kernel-features.h
@@ -23,4 +23,14 @@
 # define __ASSUME_WORDSIZE64_ILP32	1
 #endif
 
+# define __ASSUME_SOCKET_SYSCALL             1
+# define __ASSUME_SOCKETPAIR_SYSCALL         1
+# define __ASSUME_BIND_SYSCALL               1
+# define __ASSUME_LISTEN_SYSCALL             1
+# define __ASSUME_GETSOCKOPT_SYSCALL         1
+# define __ASSUME_SETSOCKOPT_SYSCALL         1
+# define __ASSUME_GETSOCKNAME_SYSCALL        1
+# define __ASSUME_GETPEERNAME_SYSCALL        1
+# define __ASSUME_SHUTDOWN_SYSCALL           1
+
 #include_next <kernel-features.h>
diff --git a/sysdeps/unix/sysv/linux/x86_64/pipe.c b/sysdeps/unix/sysv/linux/x86_64/pipe.c
new file mode 100644
index 0000000000..005f58debc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/pipe.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <remote_io/remote_io.h>
+
+/* Create a one-way communication channel (__pipe).
+   If successful, two file descriptors are stored in PIPEDES;
+   bytes written on PIPEDES[1] can be read from PIPEDES[0].
+   Returns 0 if successful, -1 if not.  */
+int
+__pipe (int __pipedes[2])
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pipe (__pipedes, 0);
+#else
+  return INLINE_SYSCALL (pipe, 1, __pipedes);
+#endif
+}
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
diff --git a/sysdeps/unix/sysv/linux/x86_64/syscalls.list b/sysdeps/unix/sysv/linux/x86_64/syscalls.list
index d46524eff3..ff9e9f267a 100644
--- a/sysdeps/unix/sysv/linux/x86_64/syscalls.list
+++ b/sysdeps/unix/sysv/linux/x86_64/syscalls.list
@@ -6,12 +6,7 @@ syscall_clock_gettime	EXTRA	clock_gettime	Ei:ip		__syscall_clock_gettime
 
 
 # proper socket implementations:
-bind		-	bind		i:ipi	__bind		bind
 getpeername	-	getpeername	i:ipp	__getpeername	getpeername
 getsockname	-	getsockname	i:ipp	__getsockname	getsockname
-getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
-listen		-	listen		i:ii	__listen	listen
-setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
 shutdown	-	shutdown	i:ii	__shutdown	shutdown
-socket		-	socket		i:iii	__socket	socket
 socketpair	-	socketpair	i:iiif	__socketpair	socketpair
diff --git a/sysdeps/unix/sysv/linux/x86_64/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
index c7f740a1df..015cc95b4b 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
@@ -420,9 +420,10 @@
 
 #endif	/* __ASSEMBLER__ */
 
-
 /* Pointer mangling support.  */
-#if IS_IN (rtld)
+#if (IS_IN (rtld) \
+     || (!defined SHARED && (IS_IN (libc) \
+			     || IS_IN (libpthread))))
 /* We cannot use the thread descriptor because in ld.so we use setjmp
    earlier than the descriptor is initialized.  */
 # ifdef __ASSEMBLER__
@@ -431,32 +432,34 @@
 #  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			     \
 				xor __pointer_chk_guard_local(%rip), reg
 # else
-#  define PTR_MANGLE(reg)	asm ("xor __pointer_chk_guard_local(%%rip), %0\n" \
-				     "rol $2*" LP_SIZE "+1, %0"			  \
-				     : "=r" (reg) : "0" (reg))
-#  define PTR_DEMANGLE(reg)	asm ("ror $2*" LP_SIZE "+1, %0\n"		  \
-				     "xor __pointer_chk_guard_local(%%rip), %0"   \
-				     : "=r" (reg) : "0" (reg))
+extern uintptr_t __pointer_chk_guard_local attribute_relro attribute_hidden;
+#  define PTR_MANGLE(reg)						     \
+	asm ("xor __pointer_chk_guard_local(%%rip), %0\n"		     \
+	     "rol $2*" LP_SIZE "+1, %0"					     \
+	     : "=r" (reg) : "0" (reg))
+#  define PTR_DEMANGLE(reg)	\
+	asm ("ror $2*" LP_SIZE "+1, %0\n"				     \
+	     "xor __pointer_chk_guard_local(%%rip), %0"			     \
+	     : "=r" (reg) : "0" (reg))
 # endif
 #else
 # ifdef __ASSEMBLER__
-#  define PTR_MANGLE(reg)	xor %fs:POINTER_GUARD, reg;		      \
+#  define PTR_MANGLE(reg)	xor __pointer_chk_guard@GOTPCREL(%rip), reg; \
 				rol $2*LP_SIZE+1, reg
-#  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			      \
-				xor %fs:POINTER_GUARD, reg
+#  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			     \
+				xor __pointer_chk_guard@GOTPCREL(%rip), reg
 # else
-#  define PTR_MANGLE(var)	asm ("xor %%fs:%c2, %0\n"		      \
-				     "rol $2*" LP_SIZE "+1, %0"		      \
-				     : "=r" (var)			      \
-				     : "0" (var),			      \
-				       "i" (offsetof (tcbhead_t,	      \
-						      pointer_guard)))
-#  define PTR_DEMANGLE(var)	asm ("ror $2*" LP_SIZE "+1, %0\n"	      \
-				     "xor %%fs:%c2, %0"			      \
-				     : "=r" (var)			      \
-				     : "0" (var),			      \
-				       "i" (offsetof (tcbhead_t,	      \
-						      pointer_guard)))
+//extern uintptr_t __pointer_chk_guard attribute_relro;
+#  define PTR_MANGLE(var)						     \
+	asm ("xor __pointer_chk_guard@GOTPCREL(%%rip), %0\n"		     \
+	     "rol $2*" LP_SIZE "+1, %0"					     \
+	     : "=r" (var)						     \
+	     : "0" (var))
+#  define PTR_DEMANGLE(var)						     \
+	asm ("ror $2*" LP_SIZE "+1, %0\n"				     \
+	     "xor __pointer_chk_guard@GOTPCREL(%%rip), %0"		     \
+	     : "=r" (var)						     \
+	     : "0" (var))
 # endif
 #endif
 
diff --git a/sysdeps/x86/atomic-machine.h b/sysdeps/x86/atomic-machine.h
index bb49648374..c2b4bb361e 100644
--- a/sysdeps/x86/atomic-machine.h
+++ b/sysdeps/x86/atomic-machine.h
@@ -88,7 +88,7 @@ typedef uintmax_t uatomic_max_t;
 		       "0:\tcmpxchgb %b2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
 		       : BR_CONSTRAINT (newval), "m" (*mem), "0" (oldval),    \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
+			 "i" (offsetof (struct pthread, header.multiple_threads)));	      \
      ret; })
 
 #define __arch_c_compare_and_exchange_val_16_acq(mem, newval, oldval) \
@@ -99,7 +99,7 @@ typedef uintmax_t uatomic_max_t;
 		       "0:\tcmpxchgw %w2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
 		       : BR_CONSTRAINT (newval), "m" (*mem), "0" (oldval),    \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
+			 "i" (offsetof (struct pthread, header.multiple_threads)));	      \
      ret; })
 
 #define __arch_c_compare_and_exchange_val_32_acq(mem, newval, oldval) \
@@ -110,7 +110,7 @@ typedef uintmax_t uatomic_max_t;
 		       "0:\tcmpxchgl %2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
 		       : BR_CONSTRAINT (newval), "m" (*mem), "0" (oldval),    \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));       \
+			 "i" (offsetof (struct pthread, header.multiple_threads)));       \
      ret; })
 
 #ifdef __x86_64__
@@ -124,7 +124,7 @@ typedef uintmax_t uatomic_max_t;
 		       : "q" ((atomic64_t) cast_to_integer (newval)),	      \
 			 "m" (*mem),					      \
 			 "0" ((atomic64_t) cast_to_integer (oldval)),	      \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
+		       "i" (offsetof (struct pthread, header.multiple_threads)));		\
      ret; })
 # define do_exchange_and_add_val_64_acq(pfx, mem, value) 0
 # define do_add_val_64_acq(pfx, mem, value) do { } while (0)
@@ -210,23 +210,23 @@ typedef uintmax_t uatomic_max_t;
        __asm __volatile (lock "xaddb %b0, %1"				      \
 			 : "=q" (__result), "=m" (*mem)			      \
 			 : "0" (__addval), "m" (*mem),			      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else if (sizeof (*mem) == 2)					      \
        __asm __volatile (lock "xaddw %w0, %1"				      \
 			 : "=r" (__result), "=m" (*mem)			      \
 			 : "0" (__addval), "m" (*mem),			      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else if (sizeof (*mem) == 4)					      \
        __asm __volatile (lock "xaddl %0, %1"				      \
 			 : "=r" (__result), "=m" (*mem)			      \
 			 : "0" (__addval), "m" (*mem),			      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else if (__HAVE_64B_ATOMICS)					      \
        __asm __volatile (lock "xaddq %q0, %1"				      \
 			 : "=r" (__result), "=m" (*mem)			      \
 			 : "0" ((atomic64_t) cast_to_integer (__addval)),     \
 			   "m" (*mem),					      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else								      \
        __result = do_exchange_and_add_val_64_acq (pfx, (mem), __addval);      \
      __result; })
@@ -252,23 +252,23 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "addb %b1, %0"				      \
 			: "=m" (*mem)					      \
 			: IBR_CONSTRAINT (value), "m" (*mem),		      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "addw %w1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (value), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "addl %1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (value), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "addq %q1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" ((atomic64_t) cast_to_integer (value)),	      \
 			  "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       do_add_val_64_acq (apfx, (mem), (value));				      \
   } while (0)
@@ -337,22 +337,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "incb %b0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "incw %w0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "incl %0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "incq %q0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       do_add_val_64_acq (pfx, mem, 1);					      \
   } while (0)
@@ -395,22 +395,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "decb %b0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "decw %w0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "decl %0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "decq %q0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       do_add_val_64_acq (pfx, mem, -1);					      \
   } while (0)
@@ -501,22 +501,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "andb %b1, %0"				      \
 			: "=m" (*mem)					      \
 			: IBR_CONSTRAINT (mask), "m" (*mem),		      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "andw %w1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "andl %1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "andq %q1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       __atomic_link_error ();						      \
   } while (0)
@@ -535,22 +535,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "orb %b1, %0"				      \
 			: "=m" (*mem)					      \
 			: IBR_CONSTRAINT (mask), "m" (*mem),		      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "orw %w1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "orl %1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "orq %q1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       __atomic_link_error ();						      \
   } while (0)
diff --git a/sysdeps/x86_64/dl-machine.h b/sysdeps/x86_64/dl-machine.h
index 74029871d8..0d9c9e28e0 100644
--- a/sysdeps/x86_64/dl-machine.h
+++ b/sysdeps/x86_64/dl-machine.h
@@ -44,6 +44,7 @@ elf_machine_dynamic (void)
 {
   /* This produces an IP-relative reloc which is resolved at link time. */
   extern const ElfW(Addr) _GLOBAL_OFFSET_TABLE_[] attribute_hidden;
+  //_dl_debug_printf ("_GLOBAL_OFFSET_TABLE = %lx\n", _GLOBAL_OFFSET_TABLE_ [0]);
   return _GLOBAL_OFFSET_TABLE_[0];
 }
 
@@ -56,6 +57,7 @@ elf_machine_load_address (void)
      by an IP-relative reference, and the link-time address found in the
      special unrelocated first GOT entry.  */
   extern ElfW(Dyn) _DYNAMIC[] attribute_hidden;
+  //_dl_debug_printf ("_DYNAMIC = %lx\n", &_DYNAMIC);
   return (ElfW(Addr)) &_DYNAMIC - elf_machine_dynamic ();
 }
 
@@ -145,6 +147,8 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 .globl _dl_start_user\n\
 _start:\n\
 	movq %rsp, %rdi\n\
+	# Save %rbp is case ld-linux is being reloaded.\n\
+	movq %rbp, %r15\n\
 	call _dl_start\n\
 _dl_start_user:\n\
 	# Save the user entry point address in %r12.\n\
@@ -181,6 +185,8 @@ _dl_start_user:\n\
 	leaq _dl_fini(%rip), %rdx\n\
 	# And make sure %rsp points to argc stored on the stack.\n\
 	movq %r13, %rsp\n\
+	# Restore %rbp\n\
+	movq %r15, %rbp\n\
 	# Jump to the user's entry point.\n\
 	jmp *%r12\n\
 .previous\n\
@@ -440,9 +446,14 @@ and creates an unsatisfiable circular dependency.\n",
 #  endif
 	      /* We know the offset of the object the symbol is contained in.
 		 It is a negative value which will be added to the
-		 thread pointer.  */
+		 thread pointer. It is a positive value to static TLS
+		 layout 3.  */
 	      value = (sym->st_value + reloc->r_addend
-		       - sym_map->l_tls_offset);
+		       + sym_map->l_tls_offset);
+
+//	      _dl_debug_printf ("%s: value = %lx, st_value = %lx, r_addend = %lx, l_tls_offset = %lx\n",
+//				__FUNCTION__, value, sym->st_value, reloc->r_addend,
+//				sym_map->l_tls_offset);
 #  ifdef __ILP32__
 	      /* The symbol and addend values are 32 bits but the GOT
 		 entry is 64 bits wide and the whole 64-bit entry is used
diff --git a/sysdeps/x86_64/nptl/tcb-offsets.sym b/sysdeps/x86_64/nptl/tcb-offsets.sym
index ae8034743b..144a381394 100644
--- a/sysdeps/x86_64/nptl/tcb-offsets.sym
+++ b/sysdeps/x86_64/nptl/tcb-offsets.sym
@@ -9,12 +9,13 @@ CLEANUP_JMP_BUF		offsetof (struct pthread, cleanup_jmp_buf)
 CLEANUP			offsetof (struct pthread, cleanup)
 CLEANUP_PREV		offsetof (struct _pthread_cleanup_buffer, __prev)
 MUTEX_FUTEX		offsetof (pthread_mutex_t, __data.__lock)
-MULTIPLE_THREADS_OFFSET	offsetof (tcbhead_t, multiple_threads)
-POINTER_GUARD		offsetof (tcbhead_t, pointer_guard)
-VGETCPU_CACHE_OFFSET	offsetof (tcbhead_t, vgetcpu_cache)
-FEATURE_1_OFFSET	offsetof (tcbhead_t, feature_1)
-SSP_BASE_OFFSET		offsetof (tcbhead_t, ssp_base)
+MULTIPLE_THREADS_OFFSET	offsetof (struct pthread, header.multiple_threads)
+POINTER_GUARD		offsetof (struct pthread, header.pointer_guard)
+VGETCPU_CACHE_OFFSET	offsetof (struct pthread, header.vgetcpu_cache)
+FEATURE_1_OFFSET	offsetof (struct pthread, header.feature_1)
+SSP_BASE_OFFSET		0x28
 
+-- SSP_BASE_OFFSET is derived from the native glibc build
 -- Not strictly offsets, but these values are also used in the TCB.
 TCB_CANCELSTATE_BITMASK	 CANCELSTATE_BITMASK
 TCB_CANCELTYPE_BITMASK	 CANCELTYPE_BITMASK
diff --git a/sysdeps/x86_64/nptl/tls.h b/sysdeps/x86_64/nptl/tls.h
index e7c1416eec..d9d7205047 100644
--- a/sysdeps/x86_64/nptl/tls.h
+++ b/sysdeps/x86_64/nptl/tls.h
@@ -29,67 +29,16 @@
 # include <libc-pointer-arith.h> /* For cast_to_integer.  */
 # include <kernel-features.h>
 # include <dl-dtv.h>
-
-/* Replacement type for __m128 since this file is included by ld.so,
-   which is compiled with -mno-sse.  It must not change the alignment
-   of rtld_savespace_sse.  */
-typedef struct
-{
-  int i[4];
-} __128bits;
-
-
-typedef struct
-{
-  void *tcb;		/* Pointer to the TCB.  Not necessarily the
-			   thread descriptor used by libpthread.  */
-  dtv_t *dtv;
-  void *self;		/* Pointer to the thread descriptor.  */
-  int multiple_threads;
-  int gscope_flag;
-  uintptr_t sysinfo;
-  uintptr_t stack_guard;
-  uintptr_t pointer_guard;
-  unsigned long int vgetcpu_cache[2];
-  /* Bit 0: X86_FEATURE_1_IBT.
-     Bit 1: X86_FEATURE_1_SHSTK.
-   */
-  unsigned int feature_1;
-  int __glibc_unused1;
-  /* Reservation of some values for the TM ABI.  */
-  void *__private_tm[4];
-  /* GCC split stack support.  */
-  void *__private_ss;
-  /* The lowest address of shadow stack,  */
-  unsigned long long int ssp_base;
-  /* Must be kept even if it is no longer used by glibc since programs,
-     like AddressSanitizer, depend on the size of tcbhead_t.  */
-  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));
-
-  void *__padding[8];
-} tcbhead_t;
-
-# ifdef __ILP32__
-/* morestack.S in libgcc uses offset 0x40 to access __private_ss,   */
-_Static_assert (offsetof (tcbhead_t, __private_ss) == 0x40,
-		"offset of __private_ss != 0x40");
-/* NB: ssp_base used to be "long int __glibc_reserved2", which was
-   changed from 32 bits to 64 bits.  Make sure that the offset of the
-   next field, __glibc_unused2, is unchanged.  */
-_Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x60,
-		"offset of __glibc_unused2 != 0x60");
-# else
-/* morestack.S in libgcc uses offset 0x70 to access __private_ss,   */
-_Static_assert (offsetof (tcbhead_t, __private_ss) == 0x70,
-		"offset of __private_ss != 0x70");
-_Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
-		"offset of __glibc_unused2 != 0x80");
-# endif
+# include <nptl/descr.h>
+# include <elf/dl-popcorn.h>
 
 #else /* __ASSEMBLER__ */
 # include <tcb-offsets.h>
 #endif
 
+#ifndef PCN_HETEROGENEOUS
+#define PCN_HETEROGENEOUS
+#endif
 
 /* Alignment requirement for the stack.  */
 #define STACK_ALIGN	16
@@ -107,43 +56,51 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # endif
 #endif
 
-/* This is the size of the initial TCB.  Can't be just sizeof (tcbhead_t),
-   because NPTL getpid, __libc_alloca_cutoff etc. need (almost) the whole
-   struct pthread even when not linked with -lpthread.  */
-# define TLS_INIT_TCB_SIZE sizeof (struct pthread)
+/* The TCB can have any size and the memory following the address the
+   thread pointer points to is unspecified.  Allocate the TCB there.  */
+# define TLS_TCB_AT_TP	0
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  void *private;
+  dtv_t *dtv;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
 
 /* Alignment requirements for the initial TCB.  */
-# define TLS_INIT_TCB_ALIGN __alignof__ (struct pthread)
+# define TLS_INIT_TCB_ALIGN	__alignof__ (struct pthread)
 
 /* This is the size of the TCB.  */
-# define TLS_TCB_SIZE sizeof (struct pthread)
+# define TLS_TCB_SIZE		sizeof (tcbhead_t)
 
-/* Alignment requirements for the TCB.  */
-# define TLS_TCB_ALIGN __alignof__ (struct pthread)
-
-/* The TCB can have any size and the memory following the address the
-   thread pointer points to is unspecified.  Allocate the TCB there.  */
-# define TLS_TCB_AT_TP	1
-# define TLS_DTV_AT_TP	0
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE	sizeof (struct pthread)
 
-/* Get the thread descriptor definition.  */
-# include <nptl/descr.h>
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
 
+/* Popcorn Linux Padding.  Necessary to maintain compatiblity shared
+   libraries that expect SSP_BASE_OFFSET to be inside tcbhead_t.  */
+# define TLS_TCB_PCN_PAD	0x40
 
 /* Install the dtv pointer.  The pointer passed is to the element with
    index -1 which contain the length.  */
-# define INSTALL_DTV(descr, dtvp) \
-  ((tcbhead_t *) (descr))->dtv = (dtvp) + 1
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
 
 /* Install new dtv for current thread.  */
-# define INSTALL_NEW_DTV(dtvp) \
-  ({ struct pthread *__pd;						      \
-     THREAD_SETMEM (__pd, header.dtv, (dtvp)); })
+# define INSTALL_NEW_DTV(dtv) \
+  ({tcbhead_t *tcb = GET_TP; tcb->dtv = dtv;})
 
 /* Return dtv of given thread descriptor.  */
-# define GET_DTV(descr) \
-  (((tcbhead_t *) (descr))->dtv)
-
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
 
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
@@ -152,13 +109,10 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
    We have to make the syscall for both uses of the macro since the
    address might be (and probably is) different.  */
 # define TLS_INIT_TP(thrdescr) \
-  ({ void *_thrdescr = (thrdescr);					      \
-     tcbhead_t *_head = _thrdescr;					      \
+  ({ tcbhead_t *_thrdescr = (thrdescr);					      \
      int _result;							      \
 									      \
-     _head->tcb = _thrdescr;						      \
-     /* For now the thread descriptor is at the same address.  */	      \
-     _head->self = _thrdescr;						      \
+     _thrdescr->private = (thrdescr);					      \
 									      \
      /* It is a simple syscall to set the %fs value for the thread.  */	      \
      asm volatile ("syscall"						      \
@@ -171,14 +125,14 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
     _result ? "cannot set %fs base address for thread-local storage" : 0;     \
   })
 
-# define TLS_DEFINE_INIT_TP(tp, pd) void *tp = (pd)
-
+/* Value passed to 'clone' for initialization of the thread register.  */
+# define TLS_DEFINE_INIT_TP(tp, pd) void *tp = (pd) + 1
 
 /* Return the address of the dtv for the current thread.  */
-# define THREAD_DTV() \
-  ({ struct pthread *__pd;						      \
-     THREAD_GETMEM (__pd, header.dtv); })
-
+# define THREAD_DTV()							     \
+  ({ dtv_t *__dtv;							     \
+     asm volatile ("mov %%fs:8, %0" : "=r" (__dtv));			     \
+     __dtv; })
 
 /* Return the thread descriptor for the current thread.
 
@@ -187,66 +141,40 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 	pthread_descr self = thread_self();
    do not get optimized away.  */
 # define THREAD_SELF \
-  ({ struct pthread *__self;						      \
-     asm ("mov %%fs:%c1,%0" : "=r" (__self)				      \
-	  : "i" (offsetof (struct pthread, header.self)));	 	      \
-     __self;})
+  ({ struct pthread *__self;						     \
+     asm volatile ("mov %%fs:0, %0": "=r" (__self));			     \
+     __self - 1; })
+
+# define GET_TP \
+  ({ void *tp;								      \
+     int _result;							      \
+									      \
+     /* It is a simple syscall to set the %fs value for the thread.  */	      \
+     asm volatile ("syscall"						      \
+		   : "=a" (_result)					      \
+		   : "0" ((unsigned long int) __NR_arch_prctl),		      \
+		     "D" ((unsigned long int) ARCH_GET_FS),		      \
+		     "S" (&tp)						      \
+		   : "memory", "cc", "r11", "cx");			      \
+									      \
+    _result ? "cannot set %fs base address for thread-local storage" : 0;     \
+    tp;									      \
+  })
+
 
 /* Magic for libthread_db to know how to do THREAD_SELF.  */
 # define DB_THREAD_SELF_INCLUDE  <sys/reg.h> /* For the FS constant.  */
 # define DB_THREAD_SELF CONST_THREAD_AREA (64, FS)
 
-/* Read member of the thread descriptor directly.  */
+/* Access to data in the thread descriptor is easy.  */
 # define THREAD_GETMEM(descr, member) \
-  ({ __typeof (descr->member) __value;					      \
-     if (sizeof (__value) == 1)						      \
-       asm volatile ("movb %%fs:%P2,%b0"				      \
-		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member)));     \
-     else if (sizeof (__value) == 4)					      \
-       asm volatile ("movl %%fs:%P1,%0"					      \
-		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member)));	      \
-     else								      \
-       {								      \
-	 if (sizeof (__value) != 8)					      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %%fs:%P1,%q0"				      \
-		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member)));	      \
-       }								      \
-     __value; })
-
-
-/* Same as THREAD_GETMEM, but the member offset can be non-constant.  */
+  descr->member
 # define THREAD_GETMEM_NC(descr, member, idx) \
-  ({ __typeof (descr->member[0]) __value;				      \
-     if (sizeof (__value) == 1)						      \
-       asm volatile ("movb %%fs:%P2(%q3),%b0"				      \
-		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member[0])),   \
-		       "r" (idx));					      \
-     else if (sizeof (__value) == 4)					      \
-       asm volatile ("movl %%fs:%P1(,%q2,4),%0"				      \
-		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member[0])), "r" (idx));\
-     else								      \
-       {								      \
-	 if (sizeof (__value) != 8)					      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %%fs:%P1(,%q2,8),%q0"			      \
-		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member[0])),	      \
-			 "r" (idx));					      \
-       }								      \
-     __value; })
-
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
 
 /* Loading addresses of objects on x86-64 needs to be treated special
    when generating PIC code.  */
@@ -256,56 +184,8 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # define IMM_MODE "ir"
 #endif
 
-
-/* Set member of the thread descriptor directly.  */
-# define THREAD_SETMEM(descr, member, value) \
-  ({ if (sizeof (descr->member) == 1)					      \
-       asm volatile ("movb %b0,%%fs:%P1" :				      \
-		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member)));	      \
-     else if (sizeof (descr->member) == 4)				      \
-       asm volatile ("movl %0,%%fs:%P1" :				      \
-		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member)));	      \
-     else								      \
-       {								      \
-	 if (sizeof (descr->member) != 8)				      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %q0,%%fs:%P1" :				      \
-		       : IMM_MODE ((uint64_t) cast_to_integer (value)),	      \
-			 "i" (offsetof (struct pthread, member)));	      \
-       }})
-
-
-/* Same as THREAD_SETMEM, but the member offset can be non-constant.  */
-# define THREAD_SETMEM_NC(descr, member, idx, value) \
-  ({ if (sizeof (descr->member[0]) == 1)				      \
-       asm volatile ("movb %b0,%%fs:%P1(%q2)" :				      \
-		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
-		       "r" (idx));					      \
-     else if (sizeof (descr->member[0]) == 4)				      \
-       asm volatile ("movl %0,%%fs:%P1(,%q2,4)" :			      \
-		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
-		       "r" (idx));					      \
-     else								      \
-       {								      \
-	 if (sizeof (descr->member[0]) != 8)				      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %q0,%%fs:%P1(,%q2,8)" :			      \
-		       : IMM_MODE ((uint64_t) cast_to_integer (value)),	      \
-			 "i" (offsetof (struct pthread, member[0])),	      \
-			 "r" (idx));					      \
-       }})
-
-
+/* Disable STACK_GUARD and POINTER_GUARD for heterogeneous computing.  */
+#ifndef PCN_HETEROGENEOUS
 /* Set the stack guard field in TCB head.  */
 # define THREAD_SET_STACK_GUARD(value) \
     THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)
@@ -320,7 +200,7 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # define THREAD_COPY_POINTER_GUARD(descr) \
   ((descr)->header.pointer_guard					      \
    = THREAD_GETMEM (THREAD_SELF, header.pointer_guard))
-
+#endif
 
 /* Get and set the global scope generation counter in the TCB head.  */
 # define THREAD_GSCOPE_IN_TCB      1
@@ -329,13 +209,11 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # define THREAD_GSCOPE_FLAG_WAIT   2
 # define THREAD_GSCOPE_RESET_FLAG() \
   do									      \
-    { int __res;							      \
-      asm volatile ("xchgl %0, %%fs:%P1"				      \
-		    : "=r" (__res)					      \
-		    : "i" (offsetof (struct pthread, header.gscope_flag)),    \
-		      "0" (THREAD_GSCOPE_FLAG_UNUSED));			      \
-      if (__res == THREAD_GSCOPE_FLAG_WAIT)				      \
-	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);    \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
     }									      \
   while (0)
 # define THREAD_GSCOPE_SET_FLAG() \
