diff --git a/.gitignore b/.gitignore
index 07d4a129e5..c659e59921 100644
--- a/.gitignore
+++ b/.gitignore
@@ -44,3 +44,5 @@ core
 /linuxthreads_db
 /rtkaio
 *.pyc
+
+.vscode
\ No newline at end of file
diff --git a/INSTALL b/INSTALL
index b487e18634..242cb06f91 100644
--- a/INSTALL
+++ b/INSTALL
@@ -184,9 +184,14 @@ if 'CFLAGS' is specified it must enable optimization.  For example:
 '--enable-pt_chown'
      The file 'pt_chown' is a helper binary for 'grantpt' (*note
      Pseudo-Terminals: Allocation.) that is installed setuid root to fix
-     up pseudo-terminal ownership on GNU/Hurd.  It is not required on
-     GNU/Linux, and the GNU C Library will not use the installed
-     'pt_chown' program when configured with '--enable-pt_chown'.
+     up pseudo-terminal ownership.  It is not built by default because
+     systems using the Linux kernel are commonly built with the 'devpts'
+     filesystem enabled and mounted at '/dev/pts', which manages
+     pseudo-terminal ownership automatically.  By using
+     '--enable-pt_chown', you may build 'pt_chown' and install it setuid
+     and owned by 'root'.  The use of 'pt_chown' introduces additional
+     security risks to the system and you should enable it only if you
+     understand and accept those risks.
 
 '--disable-werror'
      By default, the GNU C Library is built with '-Werror'.  If you wish
diff --git a/Makeconfig b/Makeconfig
index f252842979..f41cc0daaf 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -358,12 +358,12 @@ real-static-start-installed-name = $(static-start-installed-name)
 endif
 
 ifeq (yesyes,$(build-shared)$(have-z-combreloc))
-combreloc-LDFLAGS = -Wl,-z,combreloc
+combreloc-LDFLAGS = -Wl,-z,combreloc -Wl,--allow-shlib-undefined
 LDFLAGS.so += $(combreloc-LDFLAGS)
 LDFLAGS-rtld += $(combreloc-LDFLAGS)
 endif
 
-relro-LDFLAGS = -Wl,-z,relro
+relro-LDFLAGS = -Wl,-z,relro -Wl,-z,max-page-size=0x1000
 LDFLAGS.so += $(relro-LDFLAGS)
 LDFLAGS-rtld += $(relro-LDFLAGS)
 
@@ -1272,7 +1272,7 @@ all-subdirs = csu assert ctype locale intl catgets math setjmp signal	    \
 	      grp pwd posix io termios resource misc socket sysvipc gmon    \
 	      gnulib iconv iconvdata wctype manual shadow gshadow po argp   \
 	      localedata timezone rt conform debug mathvec support	    \
-	      dlfcn elf
+	      dlfcn elf remote_io
 
 ifeq ($(build-crypt),yes)
 all-subdirs += crypt
diff --git a/Makerules b/Makerules
index 1e9c18f0d8..eeb1854103 100644
--- a/Makerules
+++ b/Makerules
@@ -538,7 +538,7 @@ lib%.so: lib%_pic.a $(+preinit) $(+postinit) $(link-libc-deps)
 
 define build-shlib-helper
 $(LINK.o) -shared -static-libgcc -Wl,-O1 $(sysdep-LDFLAGS) \
-	  $(if $($(@F)-no-z-defs)$(no-z-defs),,-Wl,-z,defs) $(rtld-LDFLAGS) \
+	  $(if $($(@F)-no-z-defs)$(no-z-defs),,) $(rtld-LDFLAGS) \
 	  $(extra-B-$(@F:lib%.so=%).so) -B$(csu-objpfx) \
 	  $(extra-B-$(@F:lib%.so=%).so) $(load-map-file) \
 	  -Wl,-soname=lib$(libprefix)$(@F:lib%.so=%).so$($(@F)-version) \
@@ -597,7 +597,7 @@ endef
 
 define build-module-helper
 $(LINK.o) -shared -static-libgcc $(sysdep-LDFLAGS) $(rtld-LDFLAGS) \
-	  $(if $($(@F)-no-z-defs)$(no-z-defs),,-Wl,-z,defs) \
+	  $(if $($(@F)-no-z-defs)$(no-z-defs),,) \
 	  -B$(csu-objpfx) $(load-map-file) \
 	  $(LDFLAGS.so) $(LDFLAGS-$(@F:%.so=%).so) \
 	  -L$(subst :, -L,$(rpath-link)) -Wl,-rpath-link=$(rpath-link)
diff --git a/NEWS b/NEWS
index 8a20d3c4e3..8b492d48d1 100644
--- a/NEWS
+++ b/NEWS
@@ -8,7 +8,6 @@ using `glibc' in the "product" field.
 Version 2.31.1
 
 The following bugs are resolved with this release:
-  [14231] stdio-common tests memory requirements
   [19519] iconv(1) with -c option hangs on illegal multi-byte sequences
     (CVE-2016-10228)
   [20019] NULL pointer dereference in libc.so.6 IFUNC due to uninitialized GOT
@@ -24,7 +23,6 @@ The following bugs are resolved with this release:
   [25635] arm: Wrong sysdep order selection for soft-fp
   [25639] localedata: Some names of days and months wrongly spelt in
     Occitan
-  [25691] stdio: Remove memory leak from multibyte convertion
   [25715] system() returns wrong errors when posix_spawn fails
   [25810] x32: Incorrect syscall entries with pointer, off_t and size_t
   [25896] Incorrect prctl
@@ -32,7 +30,6 @@ The following bugs are resolved with this release:
   [25933] Off by one error in __strncmp_avx2
   [25966] Incorrect access of __x86_shared_non_temporal_threshold for x32
   [25976] nss_compat: internal_end*ent may clobber errno, hiding ERANGE
-  [26211] printf integer overflow calculating allocation size
   [26224] iconv hangs when converting some invalid inputs from several IBM
     character sets (CVE-2020-27618)
   [26248] Incorrect argument types for INLINE_SETXID_SYSCALL
@@ -47,10 +44,8 @@ The following bugs are resolved with this release:
   [28524] Conversion from ISO-2022-JP-3 with iconv may emit spurious NULs
   [28755] overflow bug in wcsncmp_avx2 and wcsncmp_evex
   [28768] CVE-2022-23218: Buffer overflow in sunrpc svcunix_create
-  [28769] CVE-2021-3999: Off-by-one buffer overflow/underflow in getcwd()
   [28896] strncmp-avx2-rtm and wcsncmp-avx2-rtm fallback on non-rtm
     variants when avoiding overflow
-  [29530] segfault in printf handling thousands separator
 
 Security related changes:
 
@@ -80,12 +75,6 @@ Security related changes:
   CVE-2020-29562: An assertion failure has been fixed in the iconv function
   when invoked with UCS4 input containing an invalid character.
 
-  CVE-2021-3999: Passing a buffer of size exactly 1 byte to the getcwd
-  function may result in an off-by-one buffer underflow and overflow
-  when the current working directory is longer than PATH_MAX and also
-  corresponds to the / directory through an unprivileged mount
-  namespace.  Reported by Qualys.
-
   CVE-2022-23219: Passing an overlong file name to the clnt_create
   legacy function could result in a stack-based buffer overflow when
   using the "unix" protocol.  Reported by Martin Sebor.
@@ -229,18 +218,6 @@ Changes to build and runtime requirements:
   source tree.  ChangeLog files are located in the ChangeLog.old directory as
   ChangeLog.N where the highest N has the latest entries.
 
-* On Linux, the system administrator needs to configure /dev/pts with
-  the intended access modes for pseudo-terminals.  glibc no longer
-  attemps to adjust permissions of terminal devices.  The previous glibc
-  defaults ("tty" group, user read/write and group write) already
-  corresponded to what most systems used, so that grantpt did not
-  perform any adjustments.
-
-* On Linux, the posix_openpt and getpt functions no longer attempt to
-  use legacy (BSD) pseudo-terminals and assume that if /dev/ptmx exists
-  (and pseudo-terminals are supported), a devpts file system is mounted
-  on /dev/pts.  Current systems already meet these requirements.
-
 Security related changes:
 
   CVE-2019-19126: ld.so failed to ignore the LD_PREFER_MAP_32BIT_EXEC
diff --git a/csu/Versions b/csu/Versions
index 43010c3443..509cdf13e2 100644
--- a/csu/Versions
+++ b/csu/Versions
@@ -8,6 +8,6 @@ libc {
     gnu_get_libc_release; gnu_get_libc_version;
   }
   GLIBC_PRIVATE {
-    errno;
+    errno; __popcorn_stack_base;
   }
 }
diff --git a/csu/libc-start.c b/csu/libc-start.c
index 12468c5a89..0c17fee4f5 100644
--- a/csu/libc-start.c
+++ b/csu/libc-start.c
@@ -122,6 +122,13 @@ STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **
      __attribute__ ((noreturn));
 
 
+/* Store the highest stack address dedicated to function activations. */
+void *__popcorn_stack_base = NULL;
+extern void pcn_server_init (void);
+
+int __libc_start_main_popcorn (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
+			       int, char **, char **) __attribute__((weak));
+
 /* Note: the fini parameter is ignored here for shared library.  It
    is registered with __cxa_atexit.  This had the disadvantage that
    finalizers were called in more than one place.  */
@@ -138,8 +145,12 @@ LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
   /* Result of the 'main' function.  */
   int result;
 
+  __popcorn_stack_base = argv;
   __libc_multiple_libcs = &_dl_starting_up && !_dl_starting_up;
 
+  // Re-enable this after RIO supports mmap.
+  //pcn_server_init ();
+
 #ifndef SHARED
   _dl_relocate_static_pie ();
 
@@ -305,7 +316,15 @@ LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
       THREAD_SETMEM (self, cleanup_jmp_buf, &unwind_buf);
 
       /* Run the program.  */
+#ifdef SHARED
+      pcn_server_init ();
+      if (__libc_start_main_popcorn)
+	result = __libc_start_main_popcorn (main, argc, argv, __environ MAIN_AUXVEC_PARAM);
+      else
+	result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
+#else
       result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
+#endif
     }
   else
     {
diff --git a/elf/Makefile b/elf/Makefile
index f9646f9c8c..a9f180ddb0 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -21,11 +21,11 @@ subdir		:= elf
 
 include ../Makeconfig
 
-headers		= elf.h bits/elfclass.h link.h bits/link.h
+headers		= elf.h bits/elfclass.h link.h bits/link.h popcorn.h
 routines	= $(all-dl-routines) dl-support dl-iteratephdr \
 		  dl-addr dl-addr-obj enbl-secure dl-profstub \
 		  dl-origin dl-libc dl-sym dl-sysdep dl-error \
-		  dl-reloc-static-pie
+		  dl-reloc-static-pie dl-remote-io
 
 # The core dynamic linking functions are in libc for the static and
 # profiled libraries.
diff --git a/elf/Versions b/elf/Versions
index 3b09901f6c..69b52af54a 100644
--- a/elf/Versions
+++ b/elf/Versions
@@ -30,6 +30,11 @@ libc {
     # Internal error handling support.  Interposes the functions in ld.so.
     _dl_signal_exception; _dl_catch_exception;
     _dl_signal_error; _dl_catch_error;
+
+    # Popcorn Linux.
+    _dl_rio_print_dso;
+    _dl_rio_populate_dso_entries;
+    _dl_pcn_migration_entry;
   }
 }
 
@@ -78,5 +83,10 @@ ld {
 
     # Set value of a tunable.
     __tunable_get_val;
+
+    # Popcorn Linux.
+    _dl_rio_print_dso;
+    _dl_rio_populate_dso_entries;
+    _dl_pcn_migration_entry;
   }
 }
diff --git a/elf/dl-init.c b/elf/dl-init.c
index 55d528c7a5..d586ec937d 100644
--- a/elf/dl-init.c
+++ b/elf/dl-init.c
@@ -18,6 +18,7 @@
 
 #include <stddef.h>
 #include <ldsodefs.h>
+#include "dl-popcorn.h"
 
 
 /* Type of the initializer.  */
@@ -81,6 +82,12 @@ _dl_init (struct link_map *main_map, int argc, char **argv, char **env)
   ElfW(Dyn) *preinit_array_size = main_map->l_info[DT_PREINIT_ARRAYSZ];
   unsigned int i;
 
+  argc = pcn_data->argc;
+  argv = pcn_data->argv;
+  env = pcn_data->envp;
+
+  //_dl_debug_printf ("%s: tp = %lx\n", __FUNCTION__, GET_TP);
+
   if (__glibc_unlikely (GL(dl_initfirst) != NULL))
     {
       call_init (GL(dl_initfirst), argc, argv, env);
diff --git a/elf/dl-lookup.c b/elf/dl-lookup.c
index 378f28fa7d..72c7f3b583 100644
--- a/elf/dl-lookup.c
+++ b/elf/dl-lookup.c
@@ -965,6 +965,7 @@ _dl_setup_hash (struct link_map *map)
     {
       Elf32_Word *hash32
 	= (void *) D_PTR (map, l_info[ELF_MACHINE_GNU_HASH_ADDRIDX]);
+      // _dl_debug_printf ("%s: hash32 = %lx, ", __FUNCTION__, hash32);
       map->l_nbuckets = *hash32++;
       Elf32_Word symbias = *hash32++;
       Elf32_Word bitmask_nwords = *hash32++;
diff --git a/elf/dl-map-segments.h b/elf/dl-map-segments.h
index ac9f09ab4c..a445fd04e7 100644
--- a/elf/dl-map-segments.h
+++ b/elf/dl-map-segments.h
@@ -17,6 +17,8 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <dl-load.h>
+#include <sysdep-cancel.h>
+#include "dl-popcorn.h"
 
 /* This implementation assumes (as does the corresponding implementation
    of _dl_unmap_segments, in dl-unmap-segments.h) that shared objects
@@ -33,6 +35,7 @@ _dl_map_segments (struct link_map *l, int fd,
                   struct link_map *loader)
 {
   const struct loadcmd *c = loadcmds;
+  int i;
 
   if (__glibc_likely (type == ET_DYN))
     {
@@ -52,6 +55,21 @@ _dl_map_segments (struct link_map *l, int fd,
                                   c->mapstart & GLRO(dl_use_load_bias))
            - MAP_BASE_ADDR (l));
 
+      /* Reload the library at it's previous address.  */
+      if (pcn_data->num_maps > 0)
+	{
+	  for (i = 0; i < pcn_data->num_maps; i++)
+	    if (strcmp (l->l_name, pcn_data->maps[i].name) == 0) {
+	      mappref = pcn_data->maps[i].start;
+//	      _dl_debug_printf ("previous mapping for %s found at %x\n",
+//				l->l_name, mappref);
+	    }
+	}
+
+//      _dl_debug_printf ("mmap (%x, %u, %u, %u, %u, %u)\n",
+//			mappref, maplength, c->prot, flags, fd,
+//			c->mapoff);
+
       /* Remember which part of the address space this object uses.  */
       l->l_map_start = (ElfW(Addr)) __mmap ((void *) mappref, maplength,
                                             c->prot,
diff --git a/elf/dl-minimal.c b/elf/dl-minimal.c
index 42192f8a7b..ee35e105ef 100644
--- a/elf/dl-minimal.c
+++ b/elf/dl-minimal.c
@@ -67,6 +67,7 @@ malloc (size_t n)
 	 page to reduce number of mmap calls.  */
       caddr_t page;
       size_t nup = (n + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
+      struct link_map *l = &GL (dl_rtld_map);
       if (__glibc_unlikely (nup == 0 && n != 0))
 	return NULL;
       nup += GLRO(dl_pagesize);
@@ -77,6 +78,8 @@ malloc (size_t n)
       if (page != alloc_end)
 	alloc_ptr = page;
       alloc_end = page + nup;
+      l->l_alloc_ptr = (Elf64_Addr) page;
+      l->l_alloc_end = nup;
     }
 
   alloc_last_block = (void *) alloc_ptr;
@@ -294,3 +297,7 @@ __strsep (char **stringp, const char *delim)
 }
 weak_alias (__strsep, strsep)
 strong_alias (__strsep, __strsep_g)
+
+/* lio_malloc */
+#include <remote_io/lio_malloc.c>
+#include <remote_io/lio_string.c>
diff --git a/elf/dl-misc.c b/elf/dl-misc.c
index e6cf247b46..328e140141 100644
--- a/elf/dl-misc.c
+++ b/elf/dl-misc.c
@@ -35,6 +35,10 @@
 #include <dl-writev.h>
 #include <not-cancel.h>
 
+#if defined(__x86_64__) || defined(__aarch64__)
+#define NEED_L
+#endif
+
 /* Read the whole contents of FILE into new mmap'd space with given
    protections.  *SIZEP gets the size of the file.  On error MAP_FAILED
    is returned.  */
@@ -127,7 +131,7 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
 	  char fill = ' ';
 	  int width = -1;
 	  int prec = -1;
-#if LONG_MAX != INT_MAX
+#ifdef NEED_L
 	  int long_mod = 0;
 #endif
 
@@ -158,7 +162,7 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
 	     can use the same code for size_t.  */
 	  if (*fmt == 'l' || *fmt == 'Z')
 	    {
-#if LONG_MAX != INT_MAX
+#ifdef NEED_L
 	      long_mod = 1;
 #endif
 	      ++fmt;
@@ -172,7 +176,7 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
 	      {
 		/* We have to make a difference if long and int have a
 		   different size.  */
-#if LONG_MAX != INT_MAX
+#ifdef NEED_L
 		unsigned long int num = (long_mod
 					 ? va_arg (arg, unsigned long int)
 					 : va_arg (arg, unsigned int));
diff --git a/elf/dl-popcorn.h b/elf/dl-popcorn.h
new file mode 100644
index 0000000000..8d3ae1ac6d
--- /dev/null
+++ b/elf/dl-popcorn.h
@@ -0,0 +1,19 @@
+#ifndef DL_POPCORN_H
+#define DL_POPCORN_H
+
+#include "popcorn.h"
+
+static inline void pcn_break (void)
+{
+  struct dl_pcn_data *data = (void *) DL_PCN_STATE;
+
+#ifdef __x86_64__
+  if (data->pcn_break)
+    asm volatile ("int3;");
+#else
+  if (data->pcn_break)
+    ;
+#endif
+}
+
+#endif
diff --git a/elf/dl-remote-io.c b/elf/dl-remote-io.c
new file mode 100644
index 0000000000..bae92e7e35
--- /dev/null
+++ b/elf/dl-remote-io.c
@@ -0,0 +1,125 @@
+/* Run time dynamic linker interface with the remote_io subsystem.  */
+
+#include <ldsodefs.h>
+#include <link.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "dl-popcorn.h"
+#include <remote_io/local_io.h>
+
+#include <nptl/descr.h>
+#include <tls.h>
+
+unsigned long _dl_pcn_stack_init;
+unsigned long _dl_pcn_migration_entry __attribute__ ((weak));
+
+static unsigned long
+round_down (unsigned long a, unsigned long b)
+{
+  return a / b * b;
+}
+
+unsigned long
+round_up (unsigned long a, unsigned long b)
+{
+  return (a + b - 1) / b * b;
+}
+
+struct link_map *
+dl_rio_get_rtld_global (void)
+{
+  /* The rtld_global object is defined in rtld.c. But it is accessible
+     by the GL macros defined in <sysdeps/generic/ldsodefs.h>.  */
+
+  return &GL (dl_rtld_map);
+}
+
+static void
+dump_file (struct link_map *map)
+{
+  unsigned long start, size;
+  int i;
+
+  printf ("%s (%lx-%lx)\n", map->l_name, map->l_map_start, map->l_map_end);
+
+  for (i = 0; i < map->l_phnum; i++)
+    {
+      if (map->l_phdr[i].p_type != PT_LOAD)
+	continue;
+
+      start = round_down (map->l_phdr[i].p_vaddr + map->l_addr, PCN_PAGE_SIZE);
+      size = map->l_phdr[i].p_memsz;
+      printf ("  %lx -> %lx\n", start, start+size);
+    }
+}
+
+void
+_dl_rio_print_dso (void)
+{
+  struct link_map *l;
+
+  for (l = &GL (dl_rtld_map); l != NULL; l = l->l_prev)
+    {
+      if (l->l_name[0] == '\0')
+	continue;
+      if (strcmp (l->l_name, "linux-vdso.so.1") == 0)
+	continue;
+
+      dump_file (l);
+    }
+}
+
+int
+count_map_entries (struct link_map *map)
+{
+  int cnt = 0;
+
+  for (; map; map = map->l_prev)
+    {
+      if (map->l_name[0] == '\0')
+	continue;
+      if (strcmp (map->l_name, "linux-vdso.so.1") == 0)
+	continue;
+      cnt++;
+    }
+
+  return cnt;
+}
+
+void
+_dl_rio_populate_dso_entries (void)
+{
+  struct link_map *l = &GL (dl_rtld_map), *map;
+  int j;
+
+  //printf ("sizeof (struct pthread) = %u\n", sizeof (struct pthread));
+  //printf ("sizeof (tcbhead_t) = %u\n", sizeof (tcbhead_t));
+
+  if (pcn_data->num_maps != 0)
+    {
+      lio_memset (&pcn_data->maps[0], 0,
+                  PCN_PAGE_SIZE - offsetof (struct dl_pcn_data, maps));
+    }
+
+  for (map = l, j = 0; map; map = map->l_prev)
+    {
+      if (map->l_name[0] == '\0')
+	continue;
+      if (strcmp (map->l_name, "linux-vdso.so.1") == 0)
+	continue;
+
+      pcn_data->maps[j].name = lio_strdup (map->l_name);
+      pcn_data->maps[j].start = map->l_map_start;
+      pcn_data->maps[j].size = map->l_map_end - map->l_map_start;
+
+      j++;
+    }
+
+  pcn_data->maps[j].name = lio_strdup ("dl-malloc");
+  pcn_data->maps[j].start = l->l_alloc_ptr;
+  pcn_data->maps[j].size = l->l_alloc_end;
+  j++;
+
+  pcn_data->num_maps = j;
+}
diff --git a/elf/dl-sysdep.c b/elf/dl-sysdep.c
index 854570821c..55b2d2abce 100644
--- a/elf/dl-sysdep.c
+++ b/elf/dl-sysdep.c
@@ -47,6 +47,8 @@
 #include <dl-tunables.h>
 #include <dl-auxv.h>
 
+#include "popcorn.h"
+
 extern char **_environ attribute_hidden;
 extern char _end[] attribute_hidden;
 
@@ -121,10 +123,16 @@ _dl_sysdep_start (void **start_argptr,
     switch (av->a_type)
       {
       case AT_PHDR:
-	phdr = (void *) av->a_un.a_val;
+	if (pcn_data->phdrs)
+	  phdr = pcn_data->phdrs;
+	else
+	  phdr = (void *) av->a_un.a_val;
 	break;
       case AT_PHNUM:
-	phnum = av->a_un.a_val;
+	if (pcn_data->phdrs)
+	  phnum = pcn_data->phnum;
+	else
+	  phnum = av->a_un.a_val;
 	break;
       case AT_PAGESZ:
 	GLRO(dl_pagesize) = av->a_un.a_val;
diff --git a/elf/dl-tls.c b/elf/dl-tls.c
index fa03234610..9b6a8d8955 100644
--- a/elf/dl-tls.c
+++ b/elf/dl-tls.c
@@ -24,10 +24,16 @@
 #include <unistd.h>
 #include <sys/param.h>
 #include <atomic.h>
+#include <sysdep-cancel.h>
 
 #include <tls.h>
 #include <dl-tls.h>
 #include <ldsodefs.h>
+#include "dl-popcorn.h"
+
+#ifndef TLS_TCB_PCN_PAD
+#define TLS_TCB_PCN_PAD 0x0
+#endif
 
 /* Amount of excess space to allocate in the static TLS area
    to allow dynamic loading of modules defining IE-model TLS data.  */
@@ -222,7 +228,7 @@ _dl_determine_tlsoffset (void)
 			    + TLS_TCB_SIZE);
 #elif TLS_DTV_AT_TP
   /* The TLS blocks start right after the TCB.  */
-  size_t offset = TLS_TCB_SIZE;
+  size_t offset = TLS_TCB_SIZE + TLS_TCB_PCN_PAD;
 
   for (size_t cnt = 0; slotinfo[cnt].map != NULL; ++cnt)
     {
@@ -298,6 +304,9 @@ allocate_dtv (void *result)
   else
     result = NULL;
 
+//  _dl_debug_printf ("%s: dtv = %lx @ %u bytes, tcbp = %lx\n", __FUNCTION__, dtv,
+//		    dtv_length + 2 * sizeof (dtv_t), result);
+
   return result;
 }
 
@@ -327,23 +336,51 @@ tcb_to_pointer_to_free_location (void *tcb)
   return original_pointer_location;
 }
 
+/* This function needs to consider multiple threads eventually.  */
+static void
+*pcn_alloc_static_tls (size_t size)
+{
+  void *data;
+
+  if (pcn_data->tls_static_block != NULL)
+    return pcn_data->tls_static_block;
+
+  size += PCN_PAGE_SIZE - 1;
+  size &= ~(PCN_PAGE_SIZE - 1);
+
+  data = (void *) SYSCALL_CANCEL (mmap, (void *)DL_PCN_STATE + pcn_data->pcn_data_size, size,
+		  PROT_READ | PROT_WRITE,
+		  MAP_PRIVATE | MAP_FIXED_NOREPLACE | MAP_ANONYMOUS, 0, 0);
+  pcn_data->tls_static_block = data;
+  pcn_data->pcn_data_size += size;
+  pcn_data->tls_init = -1;
+
+//  _dl_debug_printf ("%s: allocated %u bytes of TLS @ %lx\n", __FUNCTION__,
+//		    size, data);
+
+  return data;
+}
+
 void *
 _dl_allocate_tls_storage (void)
 {
   void *result;
   size_t size = GL(dl_tls_static_size);
 
+//  _dl_debug_printf ("%s: allocating static TLS block\n", __FUNCTION__);
+
 #if TLS_DTV_AT_TP
   /* Memory layout is:
      [ TLS_PRE_TCB_SIZE ] [ TLS_TCB_SIZE ] [ TLS blocks ]
 			  ^ This should be returned.  */
-  size += TLS_PRE_TCB_SIZE;
+  size += TLS_PRE_TCB_SIZE + TLS_TCB_PCN_PAD;
 #endif
 
   /* Perform the allocation.  Reserve space for the required alignment
      and the pointer to the original allocation.  */
   size_t alignment = GL(dl_tls_static_align);
-  void *allocated = malloc (size + alignment + sizeof (void *));
+  ///void *allocated = malloc (size + alignment + sizeof (void *));
+  void *allocated = pcn_alloc_static_tls (size + alignment + sizeof (void *));
   if (__glibc_unlikely (allocated == NULL))
     return NULL;
 
@@ -371,7 +408,12 @@ _dl_allocate_tls_storage (void)
   /* Clear the TCB data structure and TLS_PRE_TCB_SIZE bytes before
      it.  We can't ask the caller (i.e. libpthread) to do it, because
      we will initialize the DTV et al.  */
-  memset (result - TLS_PRE_TCB_SIZE, '\0', TLS_PRE_TCB_SIZE + TLS_TCB_SIZE);
+  if (pcn_data->tls_init < 0)
+    {
+      //_dl_debug_printf ("%s: initializing static TLS block\n", __FUNCTION__);
+      memset (result - TLS_PRE_TCB_SIZE, '\0', TLS_PRE_TCB_SIZE + TLS_TCB_SIZE);
+      pcn_data->tls_init = 0;
+    }
 #endif
 
   /* Record the value of the original pointer for later
@@ -504,6 +546,25 @@ _dl_allocate_tls_init (void *result)
 	  dtv[map->l_tls_modid].pointer.val = dest;
 
 	  /* Copy the initialization image and clear the BSS part.  */
+
+//	  _dl_debug_printf ("%s: reserving tls for %s\n", __FUNCTION__,
+//			    map->l_name);
+
+	  /* Don't reinitialize TLS data for the main executable after
+	     reloading ld-linux.  */
+	  if (map->l_name[0] == '\0' && pcn_data->tls_init == 0)
+	    {
+//	      _dl_debug_printf ("%s: initializing TLS module 1\n",
+//				__FUNCTION__);
+	      pcn_data->tls_init = 1;
+	    }
+	  else if (map->l_name[0] == '\0' && pcn_data->tls_init > 0)
+	    {
+//	      _dl_debug_printf ("%s: skipping TLS module 1\n",
+//				__FUNCTION__);
+	      continue;
+	    }
+
 	  memset (__mempcpy (dest, map->l_tls_initimage,
 			     map->l_tls_initimage_size), '\0',
 		  map->l_tls_blocksize - map->l_tls_initimage_size);
diff --git a/elf/get-dynamic-info.h b/elf/get-dynamic-info.h
index 4f6a86ef37..92451da488 100644
--- a/elf/get-dynamic-info.h
+++ b/elf/get-dynamic-info.h
@@ -44,6 +44,7 @@ elf_get_dynamic_info (struct link_map *l, ElfW(Dyn) *temp)
 #endif
 
   info = l->l_info;
+  //_dl_debug_printf ("%s: dyn = %lx\n", __FUNCTION__, dyn);
 
   while (dyn->d_tag != DT_NULL)
     {
diff --git a/elf/popcorn.h b/elf/popcorn.h
new file mode 100644
index 0000000000..5d7faa8018
--- /dev/null
+++ b/elf/popcorn.h
@@ -0,0 +1,78 @@
+#ifndef POPCORN_H
+#define POPCORN_H
+
+#define DL_PCN_STATE 0x700000000000
+#define PCN_PAGE_SIZE 0x1000
+#define PCN_HETEROGENEOUS 1
+#define PCN_FILENAME 64
+#define DL_PCN_SIZE (PCN_PAGE_SIZE * 4)
+
+#define PCN_NSIG 64
+
+struct pcn_sig {
+  void *pcn_sa_handler;
+  unsigned long pcn_sa_mask;
+  int pcn_sa_flags;
+};
+
+struct mmap_entries {
+  char *name;
+  unsigned long start, size;
+};
+
+struct dl_pcn_data {
+  unsigned long pcn_entry;
+  int pcn_break;
+  void *arg;
+  int argc;
+  char **argv;
+  char **envp;
+  char *filename;
+  char *pcn_storage;
+  char *pcn_storage_shm;
+  int pcn_storage_shm_len;
+  void *thread_pointer;
+  void *tls_static_block;
+  int tls_init;
+  void *phdrs;
+  int phnum;
+  int pcn_data_size;
+  int num_maps;
+
+  int pcn_remote_io_active;
+  unsigned int pcn_server_ip;
+  unsigned short pcn_server_port;
+  int pcn_server_sockfd;
+  int pcn_client_sockfd;
+  int pcn_listen_sockfd;
+
+  unsigned int pcn_local_ip;
+
+  int rio_migrate_pending;
+  int rio_migrate_disabled;
+  int rio_child_pid;
+  int rio_my_pid;
+  int rio_migrate_cnt;
+  int rio_epollfd;
+
+  int rio_debug;
+  int rio_debug_fd;
+  int rio_msg_idx;
+  int rio_num_maps;
+  void *rio_active_maps;
+  _Atomic int rio_active_calls;
+
+  unsigned long rio_sa_active;
+  struct pcn_sig rio_sa_sigs[PCN_NSIG];
+  unsigned long rio_sigmask;
+  void *rio_sigaction;
+
+  struct mmap_entries maps[];
+};
+
+extern void _dl_rio_print_dso (void);
+extern void _dl_rio_populate_dso_entries (void);
+
+#define pcn_data ((struct dl_pcn_data *) DL_PCN_STATE)
+
+#endif
diff --git a/elf/rtld.c b/elf/rtld.c
index 553cfbd1b7..d992861c9e 100644
--- a/elf/rtld.c
+++ b/elf/rtld.c
@@ -45,6 +45,10 @@
 #include <stap-probe.h>
 #include <stackinfo.h>
 #include <not-cancel.h>
+#include <sysdep-cancel.h>
+#include "dl-popcorn.h"
+#include <remote_io/local_io.h>
+#include <remote_io/server.h>
 
 #include <assert.h>
 
@@ -458,6 +462,46 @@ _dl_start_final (void *arg, struct dl_start_final_info *info)
   return start_addr;
 }
 
+static void
+pcn_plug_rtld_hole (void)
+{
+  const ElfW(Ehdr) *ehdr = (ElfW(Ehdr) *)_begin;
+  const ElfW(Phdr) *phdrs = (ElfW(Phdr) * )(_begin + ehdr->e_phoff);
+  uintptr_t hole, last = -1, cur, align;
+  int i;
+  volatile void *res;
+
+  for (i = 1; i < ehdr->e_phnum; i++)
+    {
+      if (phdrs[i].p_type != PT_LOAD)
+	continue;
+
+      align = phdrs[i].p_align;
+
+      /* Round up last to the nearest page size. */
+      last = phdrs[i-1].p_vaddr + phdrs[i-1].p_memsz + align;
+      last = last / align * align;
+
+      /* Round down cur to the nearest page size.  */
+      cur = phdrs[i].p_vaddr / align * align;
+
+      hole = cur - last;
+
+      if (hole > 0)
+	{
+	  last +=  (uintptr_t)_begin;
+
+	  //_dl_debug_printf ("%s: found a hole of size %lx @ %lx\n",
+	  //                  __FUNCTION__, hole, last);
+
+	  res = __mmap ((void *)last, hole, PROT_NONE,
+			MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
+			-1, 0);
+	  assert ((uintptr_t)res != -1);
+	}
+    }
+}
+
 static ElfW(Addr) __attribute_used__
 _dl_start (void *arg)
 {
@@ -500,8 +544,28 @@ _dl_start (void *arg)
 # endif
 #endif
 
+  /* If this fails, it's because this memory region has already been
+     mapped. */
+  SYSCALL_CANCEL (mmap, (void *)DL_PCN_STATE, DL_PCN_SIZE,
+		  PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED_NOREPLACE | MAP_ANONYMOUS, 0, 0);
+
+  if (pcn_data->arg == NULL)
+    {
+      pcn_data->arg = arg;
+      pcn_data->pcn_data_size = DL_PCN_SIZE;
+      pcn_data->rio_child_pid = -1;
+      pcn_data->rio_debug = 1;
+    }
+  else
+    arg = pcn_data->arg;
+
+  pcn_plug_rtld_hole ();
+
+  //pcn_break ();
+
   /* Figure out the run-time load address of the dynamic linker itself.  */
   bootstrap_map.l_addr = elf_machine_load_address ();
+  //_dl_debug_printf ("bootstrap_map.l_addr = %lx\n", bootstrap_map.l_addr);
 
   /* Read our own dynamic section and fill in the info array.  */
   bootstrap_map.l_ld = (void *) bootstrap_map.l_addr + elf_machine_dynamic ();
@@ -717,6 +781,11 @@ init_tls (void)
   /* No need to check the return value.  If memory allocation failed
      the program would have been terminated.  */
 
+//  _dl_debug_printf ("%s: dl_tls_dtv_slotinfo_list = %lx @ %u bytes\n",
+//		    __FUNCTION__, GL(dl_tls_dtv_slotinfo_list),
+//		    sizeof (struct dtv_slotinfo_list)
+//		    + nelem * sizeof (struct dtv_slotinfo));
+
   struct dtv_slotinfo *slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;
   GL(dl_tls_dtv_slotinfo_list)->len = nelem;
   GL(dl_tls_dtv_slotinfo_list)->next = NULL;
@@ -760,6 +829,13 @@ cannot allocate TLS data structures for initial thread\n");
     _dl_fatal_printf ("cannot set up thread-local storage: %s\n", lossage);
   tls_init_tp_called = true;
 
+  pcn_data->thread_pointer = tcbp;
+
+//  _dl_debug_printf ("%s: tcbp = %lx (%lx), DTV = %lx, TP = %lx\n",
+//		    __FUNCTION__, tcbp, THREAD_DTV(), GET_DTV (tcbp), GET_TP);
+//  _dl_debug_printf ("%s: SINGLE_THREAD_P = %u\n", __FUNCTION__,
+//		    SINGLE_THREAD_P);
+
   return tcbp;
 }
 
@@ -1119,6 +1195,17 @@ dl_main (const ElfW(Phdr) *phdr,
   _dl_starting_up = 1;
 #endif
 
+  if (pcn_data->pcn_entry)
+    *user_entry = pcn_data->pcn_entry;
+
+  /*
+  _dl_debug_printf ("phdr = 0x%x, phnum = %u, user_entry = 0x%x, auxv = 0x%x\n",
+		    phdr, phnum, *user_entry, auxv);
+  _dl_debug_printf ("pcn_data: arg = 0x%x, entry = 0x%x, break = %u\n",
+		    pcn_data->arg, pcn_data->pcn_entry,
+		    pcn_data->pcn_break);
+  */
+
   if (*user_entry == (ElfW(Addr)) ENTRY_POINT)
     {
       /* Ho ho.  We are not the program interpreter!  We are the program
@@ -1503,7 +1590,7 @@ ERROR: '%s': cannot process note segment.\n", _dl_argv[0]);
 		      + GL(dl_rtld_map).l_info[DT_SONAME]->d_un.d_ptr);
       newname.next = NULL;
       newname.dont_free = 1;
-
+      //_dl_debug_printf ("%s: newname = %s\n", __FUNCTION__, newname.name);
       assert (GL(dl_rtld_map).l_libname->next == NULL);
       GL(dl_rtld_map).l_libname->next = &newname;
     }
@@ -1538,10 +1625,10 @@ ERROR: '%s': cannot process note segment.\n", _dl_argv[0]);
   struct link_map **first_preload = &GL(dl_rtld_map).l_next;
   /* Set up the data structures for the system-supplied DSO early,
      so they can influence _dl_init_paths.  */
-  setup_vdso (main_map, &first_preload);
+  //setup_vdso (main_map, &first_preload);
 
   /* With vDSO setup we can initialize the function pointers.  */
-  setup_vdso_pointers ();
+  //setup_vdso_pointers ();
 
 #ifdef DL_SYSDEP_OSCHECK
   DL_SYSDEP_OSCHECK (_dl_fatal_printf);
@@ -2360,6 +2447,52 @@ ERROR: '%s': cannot process note segment.\n", _dl_argv[0]);
   _dl_unload_cache ();
 #endif
 
+  if (pcn_data->argv == NULL)
+    {
+      pcn_data->argc = _dl_argc;
+      pcn_data->argv = _dl_argv;
+      pcn_data->envp = environ;
+
+      pcn_data->filename = lio_strdup (_dl_argv[0]);
+    }
+
+  if (pcn_data->pcn_storage == NULL)
+    {
+      int pwd_len = 0, bufsz = 2048;
+      const char *pcn = "/.pcn";
+      const char *shm = "/shm_";
+      int pcn_l = lio_strlen (pcn) + 1;
+      int shm_l = lio_strlen (shm) + 1;
+      int i;
+
+      pcn_data->pcn_storage = lio_malloc (bufsz);
+      getcwd (pcn_data->pcn_storage, bufsz);
+      pwd_len = lio_strlen (pcn_data->pcn_storage);
+
+      for (i = 0; i < pcn_l; i++)
+        pcn_data->pcn_storage[pwd_len++] = pcn[i];
+
+      pwd_len--;
+
+      pcn_data->pcn_storage_shm = lio_malloc (bufsz);
+      lio_memcpy (pcn_data->pcn_storage_shm, pcn_data->pcn_storage, pwd_len);
+
+      for (i = 0; i < shm_l; i++)
+        pcn_data->pcn_storage_shm[pwd_len++] = shm[i];
+
+      pcn_data->pcn_storage_shm_len = pwd_len - 1;
+
+      //_dl_debug_printf ("%s: pcn_storage_shm = %s, pcn_storage = %s\n", __FUNCTION__, pcn_data->pcn_storage_shm, pcn_data->pcn_storage);
+
+    }
+
+//  {
+//    void *tp = GET_TP;
+//    void *self = THREAD_SELF;
+//    _dl_debug_printf ("%s: tp = %lx, thread_self = %lx, sizeof (pthread) = %u\n",
+//		      __FUNCTION__, tp, self, sizeof (struct pthread));
+//  }
+
   /* Once we return, _dl_sysdep_start will invoke
      the DT_INIT functions and then *USER_ENTRY.  */
 }
diff --git a/include/link.h b/include/link.h
index aea268439c..6391d9af8e 100644
--- a/include/link.h
+++ b/include/link.h
@@ -245,6 +245,9 @@ struct link_map
     /* End of the executable part of the mapping.  */
     ElfW(Addr) l_text_end;
 
+    /* Keep track of mmap allocations.  */
+    ElfW(Addr) l_alloc_ptr, l_alloc_end;
+
     /* Default array for 'l_scope'.  */
     struct r_scope_elem *l_scope_mem[4];
     /* Size of array allocated for 'l_scope'.  */
diff --git a/include/sys/epoll.h b/include/sys/epoll.h
index 86e0a54e62..35da8fdcc5 100644
--- a/include/sys/epoll.h
+++ b/include/sys/epoll.h
@@ -1,6 +1,11 @@
 #ifndef _SYS_EPOLL_H
 #include_next <sys/epoll.h>
 
+libc_hidden_proto (epoll_create1)
+libc_hidden_proto (epoll_create)
+libc_hidden_proto (epoll_ctl)
+libc_hidden_proto (epoll_wait)
+
 # ifndef _ISOMAC
 
 libc_hidden_proto (epoll_pwait)
diff --git a/include/sys/stat.h b/include/sys/stat.h
index b82d452780..a7d0ae9b41 100644
--- a/include/sys/stat.h
+++ b/include/sys/stat.h
@@ -10,10 +10,13 @@ extern int __chmod (const char *__file, __mode_t __mode);
 libc_hidden_proto (__chmod)
 extern int __fchmod (int __fd, __mode_t __mode);
 extern __mode_t __umask (__mode_t __mask);
+libc_hidden_proto (__umask)
 extern int __mkdir (const char *__path, __mode_t __mode);
 libc_hidden_proto (__mkdir)
 extern int __mknod (const char *__path,
 		    __mode_t __mode, __dev_t __dev);
+extern int __do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag);
+
 #if IS_IN (libc) || (IS_IN (rtld) && !defined NO_RTLD_HIDDEN)
 hidden_proto (__fxstat)
 hidden_proto (__fxstat64)
@@ -21,6 +24,7 @@ hidden_proto (__lxstat)
 hidden_proto (__lxstat64)
 hidden_proto (__xstat)
 hidden_proto (__xstat64)
+hidden_proto (__do_fxstatat)
 #endif
 extern __inline__ int __stat (const char *__path, struct stat *__statbuf)
 {
diff --git a/include/sys/statfs.h b/include/sys/statfs.h
index 8a9f5a7b3b..6f3a468238 100644
--- a/include/sys/statfs.h
+++ b/include/sys/statfs.h
@@ -6,8 +6,8 @@
 /* Now define the internal interfaces.  */
 extern int __statfs (const char *__file, struct statfs *__buf);
 libc_hidden_proto (__statfs)
-extern int __fstatfs (int __fildes, struct statfs *__buf)
-     attribute_hidden;
+extern int __fstatfs (int __fildes, struct statfs *__buf);
+libc_hidden_proto (__fstatfs)
 extern int __statfs64 (const char *__file, struct statfs64 *__buf)
      attribute_hidden;
 extern int __fstatfs64 (int __fildes, struct statfs64 *__buf)
diff --git a/include/unistd.h b/include/unistd.h
index f48da2c7a3..d67ad8cff2 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -65,7 +65,8 @@ libc_hidden_proto (__libc_write)
 libc_hidden_proto (write)
 extern int __pipe (int __pipedes[2]);
 libc_hidden_proto (__pipe)
-extern int __pipe2 (int __pipedes[2], int __flags) attribute_hidden;
+  extern int __pipe2 (int __pipedes[2], int __flags);
+libc_hidden_proto (__pipe2)
 extern unsigned int __sleep (unsigned int __seconds) attribute_hidden;
 extern int __chown (const char *__file,
 		    __uid_t __owner, __gid_t __group);
@@ -74,11 +75,13 @@ extern int __fchown (int __fd,
 		     __uid_t __owner, __gid_t __group);
 extern int __lchown (const char *__file, __uid_t __owner,
 		     __gid_t __group);
-extern int __chdir (const char *__path) attribute_hidden;
+extern int __chdir (const char *__path);
+libc_hidden_proto (__chdir)
 extern int __fchdir (int __fd) attribute_hidden;
 extern char *__getcwd (char *__buf, size_t __size);
 libc_hidden_proto (__getcwd)
-extern int __rmdir (const char *__path) attribute_hidden;
+extern int __rmdir (const char *__path);
+libc_hidden_proto (__rmdir)
 extern int __execvpe (const char *file, char *const argv[],
 		      char *const envp[]) attribute_hidden;
 extern int __execvpex (const char *file, char *const argv[],
@@ -101,7 +104,8 @@ libc_hidden_proto (__dup2)
 extern int __dup3 (int __fd, int __fd2, int flags);
 libc_hidden_proto (__dup3)
 extern int __execve (const char *__path, char *const __argv[],
-		     char *const __envp[]) attribute_hidden;
+		     char *const __envp[]);
+libc_hidden_proto (__execve)
 extern long int __pathconf (const char *__path, int __name);
 extern long int __fpathconf (int __fd, int __name);
 extern long int __sysconf (int __name);
@@ -137,10 +141,13 @@ extern int __ttyname_r (int __fd, char *__buf, size_t __buflen)
      attribute_hidden;
 extern int __isatty (int __fd) attribute_hidden;
 extern int __link (const char *__from, const char *__to);
+libc_hidden_proto (__link)
 extern int __symlink (const char *__from, const char *__to);
-extern ssize_t __readlink (const char *__path, char *__buf, size_t __len)
-     attribute_hidden;
-extern int __unlink (const char *__name) attribute_hidden;
+libc_hidden_proto (__symlink)
+extern ssize_t __readlink (const char *__path, char *__buf, size_t __len);
+libc_hidden_proto (__readlink)
+extern int __unlink (const char *__name);
+libc_hidden_proto (__unlink)
 extern int __gethostname (char *__name, size_t __len) attribute_hidden;
 extern int __revoke (const char *__file);
 extern int __profil (unsigned short int *__sample_buffer, size_t __size,
diff --git a/io/Makefile b/io/Makefile
index d9a1da4566..ab5d367e5f 100644
--- a/io/Makefile
+++ b/io/Makefile
@@ -33,7 +33,7 @@ routines :=								\
 	utime								\
 	mkfifo mkfifoat							\
 	stat fstat lstat stat64 fstat64 lstat64 fstatat fstatat64	\
-	xstat fxstat lxstat xstat64 fxstat64 lxstat64 statx		\
+	xstat fxstat lxstat xstat64 fxstat64 lxstat64 statx do_fxstatat \
 	mknod mknodat xmknod xmknodat					\
 	fxstatat fxstatat64						\
 	statfs fstatfs statfs64 fstatfs64				\
@@ -55,7 +55,7 @@ routines :=								\
 	posix_fadvise posix_fadvise64					\
 	posix_fallocate posix_fallocate64				\
 	sendfile sendfile64 copy_file_range 				\
-	utimensat futimens
+	utimensat futimens						\
 
 # These routines will be omitted from the libc shared object.
 # Instead the static object files will be included in a special archive
diff --git a/io/do_fxstatat.c b/io/do_fxstatat.c
new file mode 100644
index 0000000000..3adb6d95b1
--- /dev/null
+++ b/io/do_fxstatat.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 2005-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Ho hum, since fxstatat == fxstatat64 we must get rid of the
+   prototype or gcc will complain since they don't strictly match.  */
+#define __fxstatat64 __fxstatat64_disable
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+int
+__do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  if (vers != _STAT_VER_KERNEL && vers != _STAT_VER_LINUX)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return INLINE_SYSCALL (newfstatat, 4, fd, file, st, flag);
+}
+libc_hidden_weak (__do_fxstatat)
diff --git a/locale/Makefile b/locale/Makefile
index c9694e236e..c55a0537ca 100644
--- a/locale/Makefile
+++ b/locale/Makefile
@@ -102,6 +102,12 @@ CPPFLAGS-locale-programs = -DLOCALE_PATH='$(localepath)' \
 			   -DREPERTOIREMAP_PATH='"$(i18ndir)/repertoiremaps"' \
 			   -DLOCSRCDIR='"$(i18ndir)/locales"'
 
+# Popcorn Linux installs glibc into a sysroot
+sysroot = `$(CC) -print-sysroot`
+rtld-LDFLAGS = $()
+LDFLAGS-locale += -Wl,-rpath,$(sysroot)/lib -Wl,-dynamic-linker,$(sysroot)/lib/ld-2.31.so
+LDFLAGS-localedef += -Wl,-rpath,$(sysroot)/lib -Wl,-dynamic-linker,$(sysroot)/lib/ld-2.31.so
+
 CFLAGS-charmap.c += -Wno-write-strings -Wno-char-subscripts
 CFLAGS-locfile.c += -Wno-write-strings -Wno-char-subscripts
 CFLAGS-charmap-dir.c += -Wno-write-strings
diff --git a/locale/programs/locale.c b/locale/programs/locale.c
index e2e309c2a1..ef80b41d82 100644
--- a/locale/programs/locale.c
+++ b/locale/programs/locale.c
@@ -46,6 +46,8 @@
 #include "../locarchive.h"
 #include <programs/xmalloc.h>
 
+#include <elf/popcorn.h>
+
 #define ARCHIVE_NAME COMPLOCALEDIR "/locale-archive"
 
 /* If set print the name of the category.  */
@@ -187,6 +189,10 @@ main (int argc, char *argv[])
   show_category_name = 0;
   show_keyword_name = 0;
 
+  /* Deactivate the RIO server.  */
+  pcn_data->pcn_remote_io_active = 0;
+  close (pcn_data->pcn_server_sockfd);
+
   /* Set locale.  Do not set LC_ALL because the other categories must
      not be affected (according to POSIX.2).  */
   try_setlocale (LC_CTYPE, "LC_CTYPE");
diff --git a/malloc/malloc.c b/malloc/malloc.c
index f7cd29bc2f..ebccc64192 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -247,6 +247,8 @@
 /* For SINGLE_THREAD_P.  */
 #include <sysdep-cancel.h>
 
+#include <remote_io/local_io.h>
+
 /*
   Debugging:
 
@@ -3024,6 +3026,8 @@ __libc_malloc (size_t bytes)
   mstate ar_ptr;
   void *victim;
 
+  return lio_malloc (bytes);
+
   _Static_assert (PTRDIFF_MAX <= SIZE_MAX / 2,
                   "PTRDIFF_MAX is not more than half of SIZE_MAX");
 
@@ -3088,6 +3092,8 @@ __libc_free (void *mem)
   mstate ar_ptr;
   mchunkptr p;                          /* chunk corresponding to mem */
 
+  return lio_free (mem);
+
   void (*hook) (void *, const void *)
     = atomic_forced_read (__free_hook);
   if (__builtin_expect (hook != NULL, 0))
@@ -3134,6 +3140,8 @@ __libc_realloc (void *oldmem, size_t bytes)
 
   void *newp;             /* chunk to return */
 
+  return lio_realloc (oldmem, bytes);
+
   void *(*hook) (void *, size_t, const void *) =
     atomic_forced_read (__realloc_hook);
   if (__builtin_expect (hook != NULL, 0))
@@ -3373,6 +3381,8 @@ __libc_calloc (size_t n, size_t elem_size)
   INTERNAL_SIZE_T *d;
   ptrdiff_t bytes;
 
+  return lio_calloc (n, elem_size);
+
   if (__glibc_unlikely (__builtin_mul_overflow (n, elem_size, &bytes)))
     {
        __set_errno (ENOMEM);
diff --git a/manual/install.texi b/manual/install.texi
index 153ec99adc..71bf47cac6 100644
--- a/manual/install.texi
+++ b/manual/install.texi
@@ -214,9 +214,14 @@ increased program load times.
 @item --enable-pt_chown
 The file @file{pt_chown} is a helper binary for @code{grantpt}
 (@pxref{Allocation, Pseudo-Terminals}) that is installed setuid root to
-fix up pseudo-terminal ownership on GNU/Hurd.  It is not required on
-GNU/Linux, and @theglibc{} will not use the installed @file{pt_chown}
-program when configured with @option{--enable-pt_chown}.
+fix up pseudo-terminal ownership.  It is not built by default because
+systems using the Linux kernel are commonly built with the @code{devpts}
+filesystem enabled and mounted at @file{/dev/pts}, which manages
+pseudo-terminal ownership automatically.  By using
+@samp{--enable-pt_chown}, you may build @file{pt_chown} and install it
+setuid and owned by @code{root}.  The use of @file{pt_chown} introduces
+additional security risks to the system and you should enable it only if
+you understand and accept those risks.
 
 @item --disable-werror
 By default, @theglibc{} is built with @option{-Werror}.  If you wish
diff --git a/nptl/Makefile b/nptl/Makefile
index 2df4c9098c..35f165c085 100644
--- a/nptl/Makefile
+++ b/nptl/Makefile
@@ -146,7 +146,8 @@ libpthread-routines = nptl-init nptlfreeres vars events version pt-interp \
 		      mtx_trylock mtx_unlock call_once cnd_broadcast \
 		      cnd_destroy cnd_init cnd_signal cnd_timedwait cnd_wait \
 		      tss_create tss_delete tss_get tss_set pthread_mutex_conf \
-		      libpthread-compat
+		      libpthread-compat \
+		      pthread_migrate __set_thread_area arch_crash
 #		      pthread_setuid pthread_seteuid pthread_setreuid \
 #		      pthread_setresuid \
 #		      pthread_setgid pthread_setegid pthread_setregid \
diff --git a/nptl/Versions b/nptl/Versions
index ff6fc06002..0a294a9c9f 100644
--- a/nptl/Versions
+++ b/nptl/Versions
@@ -287,5 +287,8 @@ libpthread {
     __pthread_barrier_init; __pthread_barrier_wait;
     __shm_directory;
     __libpthread_freeres;
+    pthread_set_migrate_args; pthread_get_migrate_args;
+    __set_thread_area;
+    crash_aarch64; crash_powerpc64; crash_riscv64; crash_x86_64;
   }
 }
diff --git a/nptl/__set_thread_area.c b/nptl/__set_thread_area.c
new file mode 100644
index 0000000000..d1b962cd13
--- /dev/null
+++ b/nptl/__set_thread_area.c
@@ -0,0 +1,6 @@
+#include "pthreadP.h"
+
+int __set_thread_area(void *p)
+{
+  return TLS_INIT_TP(p);
+}
diff --git a/nptl/arch_crash.c b/nptl/arch_crash.c
new file mode 100644
index 0000000000..21af9f8a67
--- /dev/null
+++ b/nptl/arch_crash.c
@@ -0,0 +1,64 @@
+#include <stdbool.h>
+
+/* Only crash if we're executing on aarch64 */
+bool crash_aarch64(long a, long b, long c, long d)
+{
+#ifdef __aarch64__
+  __asm__ __volatile__("mov x0, %0;"
+                       "mov x1, %1;"
+                       "mov x2, %2;"
+                       "mov x3, %3;"
+                       "mov x4, xzr; ldr x4, [x4]" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "x0", "x1", "x2", "x3", "x4");
+  return true;
+#else
+  return false;
+#endif
+}
+
+/* Only crash if we're executing on powerpc64 */
+bool crash_powerpc64(long a, long b, long c, long d)
+{
+#ifdef __powerpc64__
+  __asm__ __volatile__("mr 0, %0;"
+                       "mr 1, %1;"
+                       "mr 2, %2;"
+                       "mr 3, %3;"
+                       ".long 0" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "r0", "r1", "r2", "r3");
+  return true;
+#else
+  return false;
+#endif
+}
+
+/* Only crash if we're executing on riscv64 */
+bool crash_riscv64(long a, long b, long c, long d)
+{
+#ifdef __riscv64__
+  __asm__ __volatile__("addi x1, %0, 0;"
+                       "addi x2, %1, 0;"
+                       "addi x3, %2, 0;"
+                       "addi x4, %3, 0;" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "x1", "x2", "x3", "x4");
+  return true;
+#else
+  return false;
+#endif
+}
+
+/* Only crash if we're executing on x86-64 */
+bool crash_x86_64(long a, long b, long c, long d)
+{
+#ifdef __x86_64__
+  __asm__ __volatile__("mov %0, %%rax;"
+                       "mov %1, %%rbx;"
+                       "mov %2, %%rcx;"
+                       "mov %3, %%rdx;"
+                       "hlt" ::
+    "r"(a), "r"(b), "r"(c), "r"(d) : "rax", "rbx", "rcx", "rdx");
+  return true;
+#else
+  return false;
+#endif
+}
diff --git a/nptl/descr.h b/nptl/descr.h
index 5f1f35e9a4..fe8115a24a 100644
--- a/nptl/descr.h
+++ b/nptl/descr.h
@@ -54,7 +54,44 @@
   ((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - 1) \
    / PTHREAD_KEY_2NDLEVEL_SIZE)
 
+/* Replacement type for __m128 since this file is included by ld.so,
+   which is compiled with -mno-sse.  It must not change the alignment
+   of rtld_savespace_sse.  */
+typedef struct
+{
+  int i[4];
+} __128bits;
 
+/* x86_64 tcbhead */
+typedef struct
+{
+  void *tcb;		/* Pointer to the TCB.  Not necessarily the
+			   thread descriptor used by libpthread.  */
+  dtv_t *dtv;
+  void *self;		/* Pointer to the thread descriptor.  */
+  int multiple_threads;
+  int gscope_flag;
+  uintptr_t sysinfo;
+  uintptr_t stack_guard;
+  uintptr_t pointer_guard;
+  unsigned long int vgetcpu_cache[2];
+  /* Bit 0: X86_FEATURE_1_IBT.
+     Bit 1: X86_FEATURE_1_SHSTK.
+   */
+  unsigned int feature_1;
+  int __glibc_unused1;
+  /* Reservation of some values for the TM ABI.  */
+  void *__private_tm[4];
+  /* GCC split stack support.  */
+  void *__private_ss;
+  /* The lowest address of shadow stack,  */
+  unsigned long long int ssp_base;
+  /* Must be kept even if it is no longer used by glibc since programs,
+     like AddressSanitizer, depend on the size of tcbhead_t.  */
+  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));
+
+  void *__padding[8];
+} x86_64_tcbhead_t;
 
 
 /* Internal version of the buffer to store cancellation handler
@@ -126,40 +163,8 @@ struct priority_protection_data
 /* Thread descriptor data structure.  */
 struct pthread
 {
-  union
-  {
-#if !TLS_DTV_AT_TP
-    /* This overlaps the TCB as used for TLS without threads (see tls.h).  */
-    tcbhead_t header;
-#else
-    struct
-    {
-      /* multiple_threads is enabled either when the process has spawned at
-	 least one thread or when a single-threaded process cancels itself.
-	 This enables additional code to introduce locking before doing some
-	 compare_and_exchange operations and also enable cancellation points.
-	 The concepts of multiple threads and cancellation points ideally
-	 should be separate, since it is not necessary for multiple threads to
-	 have been created for cancellation points to be enabled, as is the
-	 case is when single-threaded process cancels itself.
-
-	 Since enabling multiple_threads enables additional code in
-	 cancellation points and compare_and_exchange operations, there is a
-	 potential for an unneeded performance hit when it is enabled in a
-	 single-threaded, self-canceling process.  This is OK though, since a
-	 single-threaded process will enable async cancellation only when it
-	 looks to cancel itself and is hence going to end anyway.  */
-      int multiple_threads;
-      int gscope_flag;
-    } header;
-#endif
-
-    /* This extra padding has no special purpose, and this structure layout
-       is private and subject to change without affecting the official ABI.
-       We just have it here in case it might be convenient for some
-       implementation-specific instrumentation hack or suchlike.  */
-    void *__padding[24];
-  };
+  /* Least common denominator for a header.  */
+  x86_64_tcbhead_t header;
 
   /* This descriptor's link on the `stack_used' or `__stack_user' list.  */
   list_t list;
@@ -228,6 +233,12 @@ struct pthread
   {
     __pthread_slist_t robust_list;
     struct robust_list_head robust_head;
+
+    /* Padding for Popcorn Linux  */
+    struct {
+      __pthread_slist_t pad_robust_list;
+      struct robust_list_head pad_robust_head;
+    };
   };
 
 # define ENQUEUE_MUTEX_BOTH(mutex, val)					      \
@@ -400,6 +411,9 @@ struct pthread
   /* Indicates whether is a C11 thread created by thrd_creat.  */
   bool c11;
 
+  /* Popcorn Linux Migration Arguments.  */
+  void *popcorn_migrate;
+
   /* This member must be last.  */
   char end_padding[];
 
@@ -408,4 +422,25 @@ struct pthread
 } __attribute ((aligned (TCB_ALIGNMENT)));
 
 
+#if defined (__x86_64__)
+
+# ifdef __ILP32__
+/* morestack.S in libgcc uses offset 0x40 to access __private_ss,   */
+_Static_assert (offsetof (struct pthread, header.__private_ss) == 0x40,
+		"offset of __private_ss != 0x40");
+/* NB: ssp_base used to be "long int __glibc_reserved2", which was
+   changed from 32 bits to 64 bits.  Make sure that the offset of the
+   next field, __glibc_unused2, is unchanged.  */
+_Static_assert (offsetof (struct pthread, header.__glibc_unused2) == 0x60,
+		"offset of __glibc_unused2 != 0x60");
+# else
+/* morestack.S in libgcc uses offset 0x70 to access __private_ss,   */
+_Static_assert (offsetof (struct pthread, header.__private_ss) == 0x70,
+		"offset of __private_ss != 0x70");
+_Static_assert (offsetof (struct pthread, header.__glibc_unused2) == 0x80,
+		"offset of __glibc_unused2 != 0x80");
+# endif
+
+#endif
+
 #endif	/* descr.h */
diff --git a/nptl/pthread_migrate.c b/nptl/pthread_migrate.c
new file mode 100644
index 0000000000..a14f99a23c
--- /dev/null
+++ b/nptl/pthread_migrate.c
@@ -0,0 +1,16 @@
+#include "pthreadP.h"
+
+void
+pthread_set_migrate_args (void *args)
+{
+  struct pthread *self = THREAD_SELF;
+  THREAD_SETMEM (self, popcorn_migrate, args);
+}
+
+void
+*pthread_get_migrate_args (void)
+{
+  struct pthread *self = THREAD_SELF;
+  void *args = THREAD_GETMEM (self, popcorn_migrate);
+  return args;
+}
diff --git a/remote_io/Makefile b/remote_io/Makefile
new file mode 100644
index 0000000000..7c5cbdec08
--- /dev/null
+++ b/remote_io/Makefile
@@ -0,0 +1,76 @@
+# Copyright (C) 2022 RASEC Technologies
+# This file is part of the GNU C Library.
+
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, see
+# <https://www.gnu.org/licenses/>.
+
+#
+#	Sub-makefile for Remote I/O portion of the library.
+#
+subdir	:= remote_io
+
+include ../Makeconfig
+
+headers := remote_io.h platform.h message.h debug/log.h debug/arch_crash.h
+
+routines := pcn_sys_write rio_sys_write rio_sys_open rio_server rio_print \
+	    log platform rio_msg pcn_sys_send pcn_sys_open pcn_sys_read \
+	    rio_sys_read pcn_sys_fxstatat rio_sys_fxstatat pcn_sys_mmap \
+	    rio_sys_mmap rio_vma lio_sys_calls file_ops lio_util \
+	    lio_sys_signal pcn_sys_epoll rio_sys_epoll pcn_sys_fallocate \
+	    rio_sys_fallocate pcn_sys_sigaction rio_sys_sigaction \
+	    pcn_sys_fcntl rio_sys_fcntl pcn_sys_getcwd rio_sys_getcwd \
+	    pcn_sys_close rio_sys_close pcn_sys_pipe rio_sys_pipe \
+	    pcn_sys_socket rio_sys_socket pcn_sys_bind rio_sys_bind \
+	    pcn_sys_listen rio_sys_listen pcn_sys_accept rio_sys_accept \
+	    pcn_sys_connect rio_sys_connect pcn_sys_poll rio_sys_poll \
+	    pcn_sys_access rio_sys_access pcn_sys_uname rio_sys_uname \
+	    pcn_sys_sock_getname rio_sys_sock_getname pcn_sys_recv \
+	    rio_sys_recv rio_util rio_sys_send pcn_sys_dup rio_sys_dup \
+	    pcn_sys_getdents rio_sys_getdents pcn_sys_chdir rio_sys_chdir \
+	    pcn_sys_chmod rio_sys_chmod pcn_sys_sync rio_sys_sync \
+	    pcn_sys_truncate rio_sys_truncate pcn_sys_link rio_sys_link \
+	    pcn_sys_mkdir rio_sys_mkdir pcn_sys_rmdir rio_sys_rmdir \
+	    rio_common_dir pcn_sys_rename rio_sys_rename \
+	    pcn_sys_umask rio_sys_umask pcn_sys_lseek rio_sys_lseek \
+	    pcn_sys_sync_file_range rio_sys_sync_file_range \
+	    pcn_sys_sigprocmask pcn_signals rio_signals lio_malloc \
+	    lio_string pcn_sys_kill rio_sys_kill pcn_sys_select \
+	    rio_sys_select pcn_sys_statfs rio_sys_statfs \
+	    pcn_sys_setitimer rio_sys_setitimer pcn_sys_getitimer \
+	    rio_sys_getitimer pcn_sys_signalfd rio_sys_signalfd \
+	    pcn_util pcn_sys_exec pcn_migrate pcn_disconnect
+
+# Files to embed inside libc_nonshared.a
+#static-only-routines = lio_sys_calls lio_malloc lio_string lio_util lio_string
+
+$(objpfx)rio_write.os: $(common-objpfx)misc/bits/syscall.h
+
+others = popcorn_killd
+
+install-bin = popcorn_killd
+
+sysroot = `$(CC) -print-sysroot`
+rtld-LDFLAGS = $()
+
+# Debug workaround, because popcorn ld-linux is not backwards
+# compatible with the system's ld-linux.
+LDFLAGS-popcorn_killd = -Wl,-rpath,$(sysroot)/lib -Wl,-dynamic-linker,$(sysroot)/lib/ld-2.31.so
+
+popcorn_killd-modules = local_io lio_util lio_sys_signal
+
+include ../Rules
+
+#$(objpfx)popcorn_killd: $(popcorn_killd-modules%=$(objpfx)%.o)
+#$(objpfx)popcorn_killd: $(objpfx)local_io.o $(objpfx)lio_util.o
diff --git a/remote_io/Versions b/remote_io/Versions
new file mode 100644
index 0000000000..94c2d4cb47
--- /dev/null
+++ b/remote_io/Versions
@@ -0,0 +1,57 @@
+
+ld {
+  GLIBC_PRIVATE {
+    lio_error;
+    lio_strlen;
+  }
+}
+
+libc {
+  GLIBC_PRIVATE {
+    pcn_migrate;
+    pcn_server_connect;
+    pcn_server_init;
+    popcorn_log;
+    pcn_writev;
+    pcn_write;
+    pcn_openat;
+    pcn_close;
+    pcn_fxstatat;
+    pcn_sigaction;
+    pcn_epoll_create;
+    pcn_epoll_ctl;
+    pcn_epoll_wait;
+    pcn_fallocate;
+    pcn_mmap;
+    pcn_munmap;
+    pcn_get_ip;
+    pcn_unload_signals;
+    pcn_restore_signals;
+    pcn_accept;
+    pcn_connect;
+    pcn_read;
+    pcn_recvfrom;
+    pcn_pread64;
+    pcn_pwrite64;
+    pcn_recvmsg;
+    pcn_send;
+    pcn_sendto;
+    lio_fd_find;
+    pcn_lseek64;
+    pcn_sync;
+
+    rio_msg_id;
+    rio_msg_send;
+    rio_msg_send_iov;
+    rio_msg_send_raw;
+    rio_msg_get;
+    rio_signal_pending;
+    rio_disable;
+    rio_enable;
+    rio_restore;
+    pcn_migrate_disable;
+    pcn_migrate_enable;
+    pcn_rio_disconnect;
+    pcn_rio_restart_disabled;
+  }
+}
diff --git a/remote_io/debug/arch_crash.h b/remote_io/debug/arch_crash.h
new file mode 100644
index 0000000000..2a77b89fed
--- /dev/null
+++ b/remote_io/debug/arch_crash.h
@@ -0,0 +1,19 @@
+#ifndef _ARCH_CRASH_H
+#define _ARCH_CRASH_H
+
+#include <stdbool.h>
+
+/* Crash, placing up to 4 values in the first 4 integer registers of the
+ * architecture on which we're executing. */
+bool crash(long a, long b, long c, long d);
+
+/* These APIs will crash an application *only* if called on the corresponding
+ * architecture, i.e., crash_aarch64() will only crash the program if the
+ * calling thread is executing on aarch64. Similar to above, place up to 4
+ * values in the first 4 integer registers. */
+
+bool crash_aarch64(long a, long b, long c, long d);
+bool crash_powerpc64(long a, long b, long c, long d);
+bool crash_x86_64(long a, long b, long c, long d);
+
+#endif
diff --git a/remote_io/debug/log.h b/remote_io/debug/log.h
new file mode 100644
index 0000000000..916f6bd3e8
--- /dev/null
+++ b/remote_io/debug/log.h
@@ -0,0 +1,14 @@
+#ifndef _DEBUG_LOG_H
+#define _DEBUG_LOG_H
+
+/*
+ * Open a per-thread log & log a statement.  Valid regardless of migration.
+ * @param format a message/format descriptor
+ * @param ... arguments to format descriptor
+ * @return the number of characters printed (excluding ending null byte) or -1
+ *         if there was an error
+ */
+int popcorn_log(const char *format, ...);
+
+#endif
+
diff --git a/remote_io/file_ops.c b/remote_io/file_ops.c
new file mode 100644
index 0000000000..35cb985c55
--- /dev/null
+++ b/remote_io/file_ops.c
@@ -0,0 +1,161 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "server.h"
+#include "message.h"
+#include "remote_io.h"
+#include "local_io.h"
+
+/* File I/O Operations.  */
+
+int rio_tmp_init = 0;
+
+void
+rio_init_tmpdir (void)
+{
+  struct stat st;
+  int res, tmp_dir = 0;
+
+  if (rio_tmp_init)
+    return;
+
+  res = lio_stat (pcn_data->pcn_storage, &st);
+
+  if (res < 0)
+    tmp_dir = 0;
+  else if (res == 0 && !(st.st_mode & S_IFDIR))
+    lio_unlink (pcn_data->pcn_storage);
+  else
+    tmp_dir = 1;
+
+  if (!tmp_dir)
+    lio_mkdir (pcn_data->pcn_storage, 0770);
+
+  rio_tmp_init = 1;
+}
+
+void
+rio_maybe_zap_file (const char *fname)
+{
+  struct stat st;
+  int res;
+
+  res = lio_stat (fname, &st);
+  if (res >= 0)
+    lio_unlink (fname);
+}
+
+int
+rio_get_file (struct pcn_msg_open *msg, int sockfd)
+{
+  struct pcn_msg_io_data iod;
+  struct pcn_msg_hdr ack;
+  int recv, res;
+  int newfd;
+  void *addr;
+
+  rio_init_tmpdir ();
+  rio_maybe_zap_file (msg->pathname);
+
+  rio_dbg_printf ("%s: creating file '%s'\n", __FUNCTION__, msg->pathname);
+
+  newfd = lio_open (msg->pathname, O_CREAT|O_RDWR|O_TRUNC, 0664);
+  if (newfd < 0)
+    lio_error ("%s: failed to create local copy of '%s'\n",
+	       __FUNCTION__, msg->pathname);
+
+  ack.msg_id = 0;
+  ack.msg_type = PCN_TYPE_CONTROL;
+  ack.msg_kind = PCN_CTL_ACK;
+  ack.msg_async = PCN_SEND_NORET;
+  ack.msg_size = sizeof (ack);
+  rio_msg_send (sockfd, &ack);
+
+  res = rio_msg_get (sockfd, &iod, sizeof (iod));
+  if (res < sizeof (iod))
+    lio_error ("%s: failed to receive incoming file size\n", __FUNCTION__);
+
+  //res = lio_fallocate (newfd, 0, 0, iod.data.cnt);
+  res = lio_ftruncate (newfd, iod.data.cnt);
+  if (res < 0)
+    lio_error ("%s: failed to truncate '%s'\n", __FUNCTION__, msg->pathname);
+
+  addr = lio_mmap (NULL, iod.data.cnt, PROT_WRITE, MAP_SHARED, newfd, 0);
+  if (addr == (void *)-1)
+    lio_error ("%s: failed to mmap '%s'\n", __FUNCTION__, msg->pathname);
+
+  rio_dbg_printf ("%s: receiving '%s', size = %u bytes in fd = %u\n",
+		  __FUNCTION__, msg->pathname, iod.data.cnt, newfd);
+
+  recv = 0;
+
+  while (recv < iod.data.cnt)
+    {
+      res = lio_read (sockfd, addr + recv, iod.data.cnt - recv);
+
+      if (res < 0)
+	lio_error ("%s: failed to receive file, res = %u\n", __FUNCTION__, res);
+
+      recv += res;
+      //rio_dbg_printf ("%s: received %u bytes (%u)\n", __FUNCTION__, recv, res);
+    }
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, addr);
+
+  lio_munmap (addr, iod.data.cnt);
+  lio_close (newfd);
+
+  rio_msg_get (sockfd, &ack, sizeof (ack));
+
+  rio_dbg_printf ("%s: received %u bytes\n", __FUNCTION__, res);
+
+  return abs(msg->dirfd);
+}
+
+int
+rio_send_file (struct pcn_msg_hdr *hdr)
+{
+  struct pcn_msg_hdr ack;
+  struct stat st;
+  int sockfd = pcn_data->pcn_server_sockfd;
+  char fname[hdr->msg_size];
+  int sent, res;
+  int fd;
+  off_t offset = 0;
+
+  res = rio_msg_get (sockfd, fname, hdr->msg_size);
+
+  fd = lio_open (fname, O_RDONLY, 0);
+  lio_fstat (fd, &st);
+
+  rio_dbg_printf ("%s[%u]: sending file '%s', size = %u\n",
+		  __FUNCTION__, hdr->msg_id, fname, st.st_size);
+
+  sent = 0;
+  while (sent < st.st_size)
+    {
+      res = lio_sendfile (sockfd, fd, &offset, st.st_size - sent);
+
+      if (res < 0)
+	lio_error ("%s[%u]: failed to send file -- errno = %u\n",
+		   __FUNCTION__, hdr->msg_id, errno);
+
+      sent += res;
+    }
+
+  rio_dbg_printf ("%s[%u]: sent file '%s', size = '%u' bytes\n",
+		  __FUNCTION__, hdr->msg_id, fname, sent);
+
+  lio_close (fd);
+
+  res = rio_msg_get (sockfd, &ack, sizeof (ack));
+  LIO_ASSERT (res == sizeof (ack), "failed to receive ack\n");
+
+  return sent;
+}
diff --git a/remote_io/lio_malloc.c b/remote_io/lio_malloc.c
new file mode 100644
index 0000000000..8cd7d21cc5
--- /dev/null
+++ b/remote_io/lio_malloc.c
@@ -0,0 +1,107 @@
+/* This malloc is extremely simple. It always uses mmap for
+   memory allocations.  This assumes that longs 64-bits in size. */
+
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <linux/sockios.h>
+#include <elf/popcorn.h>
+#include "local_io.h"
+#include "remote_io.h"
+
+#define PCN_OFFSET (sizeof (struct lio_alloc))
+
+struct lio_alloc {
+  long size;
+  long unused;
+  void *data[0];
+};
+
+#if !IS_IN(rtld) && defined SHARED
+# define MMAP lio_mmap
+# define MUNMAP lio_munmap
+#else
+# define MMAP __mmap
+# define MUNMAP __munmap
+#endif
+
+void *
+lio_malloc (size_t size)
+{
+  size_t asize = sizeof (struct lio_alloc) + size;
+  struct lio_alloc *mem;
+
+  if (size == 0)
+    return NULL;
+
+  mem = MMAP (NULL, asize, PROT_READ | PROT_WRITE,
+	      MAP_ANON | MAP_PRIVATE, -1, 0);
+
+#if !IS_IN(rtld) && defined SHARED
+//  lio_dbg_printf ("%s: %ld -> %lx\n", __FUNCTION__, size, mem);
+#endif
+
+  if (mem == NULL)
+    return NULL;
+
+//  if (mem == 0x7ffff3121000)
+//    lio_spin ();
+
+  mem->size = size;
+
+  return mem->data;
+}
+
+void
+lio_free (void *ptr)
+{
+  struct lio_alloc *mem = (struct lio_alloc *) ((uintptr_t)ptr - PCN_OFFSET);
+
+  if (ptr == NULL)
+    return;
+
+#if !IS_IN(rtld) && defined SHARED
+//  lio_dbg_printf ("%s: %lx -> %ld\n", __FUNCTION__, mem, mem->size);
+#endif
+
+//  if (mem == 0x7ffff3121000)
+//    lio_spin ();
+
+  MUNMAP (mem, mem->size + sizeof (struct lio_alloc));
+
+  return;
+}
+
+void *
+lio_calloc(size_t nmemb, size_t size)
+{
+  return lio_malloc (nmemb * size);
+}
+
+void *
+lio_realloc(void *ptr, size_t size)
+{
+  struct lio_alloc *mem = (struct lio_alloc *) ((uintptr_t)ptr - PCN_OFFSET);
+  void *new_mem = NULL;
+
+  if (ptr == NULL)
+    return lio_malloc (size);
+
+  if (size == 0)
+    {
+      lio_free (ptr);
+      return NULL;
+    }
+
+  new_mem = lio_malloc (size);
+  lio_memcpy (new_mem, mem->data, mem->size);
+  lio_free (ptr);
+
+#if !IS_IN(rtld) && defined SHARED
+//  lio_dbg_printf ("%s: %lx / %ld -> %lx / %ld\n", __FUNCTION__, mem, mem->size, new_mem, size);
+#endif
+
+  return new_mem;
+}
diff --git a/remote_io/lio_string.c b/remote_io/lio_string.c
new file mode 100644
index 0000000000..c86a3cb591
--- /dev/null
+++ b/remote_io/lio_string.c
@@ -0,0 +1,122 @@
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <linux/sockios.h>
+#include <elf/popcorn.h>
+#include "local_io.h"
+#include "remote_io.h"
+
+int
+lio_strlen (const char *a)
+{
+  int i;
+
+  for (i = 0; a[i] != '\0'; i++)
+    ;
+
+  return i;
+}
+
+int
+lio_strcmp (const char *a, const char *b)
+{
+  int i;
+
+  for (i = 0; a[i] != '\0' && b[i] != '\0' && a[i] == b[i]; i++)
+    ;
+
+  return a[i] - b[i];
+}
+
+int
+lio_strncmp(const char *a, const char *b, size_t n)
+{
+  int i;
+
+  for (i = 0; i < n && a[i] != '\0' && b[i] != '\0' && a[i] == b[i]; i++)
+    ;
+
+  if (i == n)
+    return 0;
+
+  return a[i] - b[i];
+
+}
+
+/* Warning, once a string is allocated, it may not be deallocated.  */
+char *
+lio_strdup (const char *str)
+{
+  int len;
+  char *dup;
+
+  if (str == NULL)
+    return NULL;
+
+  len = lio_strlen (str) + 1;
+  dup = lio_malloc (len);
+  lio_memcpy (dup, str, len);
+
+  return dup;
+}
+
+size_t
+lio_strlcpy(char *dst, const char *src, size_t size)
+{
+  long i;
+
+  for (i = 0; i < size && src[i] != '\0'; i++)
+    dst[i] = src[i];
+
+  if (size > 0)
+    dst[i] = '\0';
+
+  return i;
+}
+
+void
+lio_memset (void *s, int c, size_t n)
+{
+  int i;
+  uint8_t *t = s;
+
+  for (i = 0; i < n; i++)
+    t[i] = c;
+}
+
+void *
+lio_memcpy (void *restrict d, const void *s, size_t n)
+{
+  int i;
+  uint8_t *dd = d;
+  const uint8_t *ss = s;
+
+  for (i = 0; i < n; i++)
+    dd[i] = ss[i];
+
+  return d;
+}
+
+int
+lio_memcmp(const void *s1, const void *s2, size_t n)
+{
+  const char *a = s1;
+  const char *b = s2;
+  long i;
+
+  for (i = 0; i < n; i++)
+    if (a[i] != b[i])
+      return a[i] - b[i];
+
+  return 0;
+}
+
+void
+lio_spin (void)
+{
+  volatile int lock = 1;
+  while (lock)
+    ;
+}
diff --git a/remote_io/lio_sys_calls.c b/remote_io/lio_sys_calls.c
new file mode 100644
index 0000000000..643c6327d3
--- /dev/null
+++ b/remote_io/lio_sys_calls.c
@@ -0,0 +1,694 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/uio.h>
+#include <elf.h>
+#include <errno.h>
+#include <sys/auxv.h>
+#include <nptl/pthreadP.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <poll.h>
+#include <socketcall.h>
+#include <sys/utsname.h>
+#include <sys/wait.h>
+#include <sys/resource.h>
+#include <sys/time.h>
+#include <kernel-features.h>
+#include <sys/syscall.h>
+
+#include "remote_io.h"
+#include "local_io.h"
+
+#ifdef __x86_64__
+#define EPOLL_VER 1
+#else
+#define EPOLL_VER 0
+#endif
+
+int pcn_mode; // 1 = server
+
+void
+*lio_mmap(void *addr, size_t length, int prot, int flags,
+	      int fd, off_t offset)
+{
+#ifdef __NR_mmap2
+  return (void *) INLINE_SYSCALL_CALL (mmap2, addr, length, prot, flags, fd, offset);
+#else
+  return (void *) INLINE_SYSCALL_CALL (mmap, addr, length, prot, flags, fd, offset);
+#endif
+}
+
+int
+lio_munmap (void *addr, size_t len)
+{
+  return (int) INLINE_SYSCALL_CALL (munmap, addr, len);
+}
+
+int
+lio_mprotect (void *addr, size_t len, int prot)
+{
+  return SYSCALL_CANCEL (mprotect, (uintptr_t) addr, len, prot);
+}
+
+int
+lio_write (int fd, const void *buf, unsigned long count)
+{
+  return SYSCALL_CANCEL (write, fd, (uintptr_t) buf, count);
+}
+
+int
+lio_writev (int fd, const struct iovec *iov, int iovcnt)
+{
+  return SYSCALL_CANCEL (writev, fd, (uintptr_t) iov, iovcnt);
+}
+
+ssize_t
+lio_pwrite (int fd, const void *buf, size_t count, off64_t offset)
+{
+  return SYSCALL_CANCEL (pwrite64, fd, buf, count, SYSCALL_LL64_PRW (offset));
+}
+
+ssize_t
+lio_pwritev64 (int fd, const struct iovec *vector, int count, off64_t offset)
+{
+# ifndef __NR_pwritev64
+#  define __NR_pwritev64 __NR_pwritev
+# endif
+
+  return SYSCALL_CANCEL (pwritev64, fd, vector, count, offset);
+}
+
+ssize_t
+lio_read(int fd, void *buf, size_t count)
+{
+  return SYSCALL_CANCEL (read, fd, (uintptr_t) buf, count);
+}
+
+ssize_t
+lio_pread(int fd, void *buf, size_t count, off_t offset)
+{
+  return SYSCALL_CANCEL (pread64, fd, (uintptr_t) buf, count, offset);
+}
+
+static int
+do_lio_openat (int dirfd, const char *pathname, int flags, mode_t mode)
+{
+#ifdef __aarch64__
+  int f2 = 0;
+
+  if (flags & __O_DIRECTORY)
+    {
+      flags &= ~__O_DIRECTORY;
+      f2 |= A64__O_DIRECTORY;
+    }
+  if (flags & __O_NOFOLLOW)
+    {
+      flags &= ~__O_NOFOLLOW;
+      f2 |= A64__O_NOFOLLOW;
+    }
+  if (flags & __O_DIRECT)
+    {
+      flags &= ~__O_DIRECT;
+      f2 |= A64__O_DIRECT;
+    }
+
+  flags |= f2;
+#endif
+  return SYSCALL_CANCEL (openat, AT_FDCWD, (uintptr_t)pathname, flags, mode);
+}
+
+int
+lio_open (const char *pathname, int flags, mode_t mode)
+{
+#ifdef SYS_open
+  return SYSCALL_CANCEL (open, (uintptr_t)pathname, flags, mode);
+#else
+  return do_lio_openat (AT_FDCWD, pathname, flags, mode);
+#endif
+}
+
+int
+lio_openat (int dirfd, const char *pathname, int flags, mode_t mode)
+{
+  return do_lio_openat (dirfd, pathname, flags, mode);
+}
+
+int
+lio_close (int fd)
+{
+  return SYSCALL_CANCEL (close, fd);
+}
+
+int
+lio_fstatat(int dirfd, const char *restrict pathname,
+	    struct stat *restrict statbuf, int flags)
+{
+  INTERNAL_SYSCALL_DECL (err);
+
+  return INTERNAL_SYSCALL (newfstatat, err, 4, dirfd, pathname, statbuf, flags);
+}
+
+int
+lio_stat(const char *restrict pathname, struct stat *restrict statbuf)
+{
+  return __do_fxstatat (_STAT_VER, AT_FDCWD, pathname, statbuf, 0);
+}
+
+int
+lio_fstat (int fd, struct stat *statbuf)
+{
+  return __do_fxstatat (_STAT_VER, fd, "", statbuf, AT_EMPTY_PATH);
+}
+
+int
+lio_statfs (const char *file, struct statfs *buf)
+{
+  return SYSCALL_CANCEL (statfs, file, buf);
+}
+
+int
+lio_fstatfs (int fd, struct statfs *buf)
+{
+  return SYSCALL_CANCEL (fstatfs, fd, buf);
+}
+
+int
+lio_truncate (const char *path, off_t length)
+{
+#ifndef __NR_truncate
+  return INLINE_SYSCALL_CALL (truncate64, path,
+			      __ALIGNMENT_ARG SYSCALL_LL (length));
+#else
+  return INLINE_SYSCALL_CALL (truncate, path, length);
+#endif
+}
+
+int
+lio_ftruncate (int fd, off_t length)
+{
+  return SYSCALL_CANCEL (ftruncate, fd, length);
+}
+
+int
+lio_fallocate (int fd, int mode, off_t offset, off_t len)
+{
+  return SYSCALL_CANCEL (fallocate, fd, mode,
+			 SYSCALL_LL (offset), SYSCALL_LL (len));
+}
+
+int
+lio_ioctl_3 (int fd, unsigned long request, const void *arg)
+{
+  return ioctl (fd, request, arg);
+}
+
+int
+lio_fcntl (int fd, int cmd, void *arg)
+{
+  LIO_ASSERT (cmd == F_GETFL || cmd == F_SETFL || F_GETFD,
+	      "unsupported fcntl arguments");
+
+  return INLINE_SYSCALL_CALL (fcntl, fd, cmd, (void *) arg);
+}
+
+int
+lio_link(const char *oldpath, const char *newpath)
+{
+  return INLINE_SYSCALL (linkat, 5, AT_FDCWD, oldpath, AT_FDCWD, newpath, 0);
+}
+
+int
+lio_unlink(const char *pathname)
+{
+  return INLINE_SYSCALL (unlinkat, 3, AT_FDCWD, pathname, 0);
+}
+
+int
+lio_symlink (const char *from, const char *to)
+{
+  return INLINE_SYSCALL (symlinkat, 3, from, AT_FDCWD, to);
+}
+
+ssize_t
+lio_readlink (const char *path, char *buf, size_t len)
+{
+  return INLINE_SYSCALL (readlinkat, 4, AT_FDCWD, path, buf, len);
+}
+
+int
+lio_getcwd (char *buf, size_t size)
+{
+  return INLINE_SYSCALL (getcwd, 2, buf, size);
+}
+
+ssize_t
+lio_getdents64 (int fd, void *buf, size_t nbytes)
+{
+  return INLINE_SYSCALL_CALL (getdents64, fd, buf, nbytes);
+}
+
+void
+lio_exit (int status)
+{
+  SYSCALL_CANCEL (exit, status);
+}
+
+int
+lio_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
+{
+  return SYSCALL_CANCEL (accept4, fd, addr.__sockaddr__, len, 0);
+}
+
+int
+lio_accept_raw(int sockfd, const void *addr, socklen_t *addrlen)
+{
+  return SYSCALL_CANCEL (accept, sockfd, addr, addrlen);
+}
+
+int
+lio_socket(int domain, int type, int protocol)
+{
+  return SYSCALL_CANCEL (socket, domain, type, protocol);
+}
+
+ssize_t
+lio_sendfile (int out_fd, int in_fd, off_t *offset, size_t count)
+{
+  return SYSCALL_CANCEL (sendfile, out_fd, in_fd, offset, count);
+}
+
+int
+lio_bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
+{
+  return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, len);
+}
+
+int
+lio_bind_raw (int fd, const void *addr, socklen_t len)
+{
+  return INLINE_SYSCALL (bind, 3, fd, addr, len);
+}
+
+int lio_getpeername (int fd, __SOCKADDR_ARG addr, socklen_t *len)
+{
+  return INLINE_SYSCALL (getpeername, 3, fd, addr.__sockaddr__, len);
+}
+
+int
+lio_getsockname (int fd, __SOCKADDR_ARG addr, socklen_t *len)
+{
+  return INLINE_SYSCALL (getsockname, 3, fd, addr.__sockaddr__, len);
+}
+
+int
+lio_getsockopt (int fd, int level, int optname, const void *optval,
+		socklen_t *len)
+{
+  return INLINE_SYSCALL (getsockopt, 5, fd, level, optname, optval, len);
+}
+
+int
+lio_setsockopt (int fd, int level, int optname, const void *optval, socklen_t len)
+{
+  return INLINE_SYSCALL (setsockopt, 5, fd, level, optname, optval, len);
+}
+
+int
+lio_listen (int sockfd, int backlog)
+{
+  return INLINE_SYSCALL (listen, 2, sockfd, backlog);
+}
+
+int
+lio_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
+{
+  return SYSCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
+}
+
+ssize_t
+lio_recvfrom(int fd, void *restrict buf, size_t len, int flags,
+	     __SOCKADDR_ARG addr, socklen_t *restrict addrlen)
+{
+  return SYSCALL_CANCEL (recvfrom, fd, buf, len, flags, addr.__sockaddr__,
+			 addrlen);
+}
+
+ssize_t
+lio_recvmsg (int sockfd, struct msghdr *rmsg, int flags)
+{
+  return SYSCALL_CANCEL (recvmsg, sockfd, rmsg, flags);
+}
+
+ssize_t
+lio_send (int fd, const void *buf, size_t len, int flags)
+{
+#ifdef __ASSUME_SEND_SYSCALL
+  return SYSCALL_CANCEL (send, fd, buf, len, flags);
+#elif defined __ASSUME_SENDTO_SYSCALL
+  return SYSCALL_CANCEL (sendto, fd, buf, len, flags, NULL, 0);
+#else
+  return SOCKETCALL_CANCEL (send, fd, buf, len, flags);
+#endif
+}
+
+ssize_t
+lio_sendto (int fd, const void *buf, size_t len, int flags,
+	    __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  return SYSCALL_CANCEL (sendto, fd, buf, len, flags, addr.__sockaddr__,
+			 addrlen);
+}
+
+int
+lio_pselect (int nfds, fd_set *readfds, fd_set *writefds,
+             fd_set *exceptfds, const struct timespec *timeout,
+             const sigset_t *sigmask)
+{
+  /* Note: the system call expects 7 values but on most architectures
+     we can only pass in 6 directly.  If there is an architecture with
+     support for more parameters a new version of this file needs to
+     be created.  */
+  struct
+  {
+    __syscall_ulong_t ss;
+    __syscall_ulong_t ss_len;
+  } data;
+
+  data.ss = (__syscall_ulong_t) (uintptr_t) sigmask;
+  data.ss_len = _NSIG / 8;
+
+  return SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds,
+                         timeout, &data);
+}
+
+int
+lio_select (int nfds, fd_set *readfds, fd_set *writefds,
+            fd_set *exceptfds, struct timeval *timeout)
+{
+#ifdef __NR_select
+  return SYSCALL_CANCEL (select, nfds, readfds, writefds, exceptfds,
+			 timeout);
+#else
+  int result;
+  struct timespec ts, *tsp = NULL;
+
+  if (timeout)
+    {
+      TIMEVAL_TO_TIMESPEC (timeout, &ts);
+      tsp = &ts;
+    }
+
+  result = SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds, tsp,
+			   NULL);
+
+  if (timeout)
+    {
+      /* Linux by default will update the timeout after a pselect6 syscall
+         (though the pselect() glibc call suppresses this behavior).
+         Since select() on Linux has the same behavior as the pselect6
+         syscall, we update the timeout here.  */
+      TIMESPEC_TO_TIMEVAL (timeout, &ts);
+    }
+
+  return result;
+#endif
+}
+
+int
+lio_getpid (void)
+{
+  return SYSCALL_CANCEL (getpid);
+}
+
+int
+lio_gettid (void)
+{
+  return SYSCALL_CANCEL (gettid);
+}
+
+int
+lio_kill (pid_t pid, int sig)
+{
+  return SYSCALL_CANCEL (kill, pid, sig);
+}
+
+int
+lio_tgkill (pid_t pid, pid_t tid, int sig)
+{
+  return SYSCALL_CANCEL (tgkill, pid, tid, sig);
+}
+
+pid_t
+lio_wait4 (pid_t pid, int *stat_loc, int options,
+           struct rusage *usage)
+{
+  return SYSCALL_CANCEL (wait4, pid, stat_loc, options, usage);
+}
+
+int
+lio_arch_prctl (int code, unsigned long addr)
+{
+#ifdef __x86_64__
+  return SYSCALL_CANCEL (arch_prctl, code, addr);
+#else
+  return 0;
+#endif
+}
+
+int
+lio_dup (int oldfd)
+{
+  return SYSCALL_CANCEL (dup, oldfd);
+}
+
+int
+lio_dup2 (int oldfd, int newfd)
+{
+  return SYSCALL_CANCEL (dup3, oldfd, newfd, 0);
+}
+
+int
+lio_dup3 (int oldfd, int newfd, int flags)
+{
+  return SYSCALL_CANCEL (dup3, oldfd, newfd, flags);
+}
+
+int
+lio_pipe2 (int pfds[2], int flags)
+{
+  return INLINE_SYSCALL (pipe2, 2, pfds, flags);
+}
+
+int
+lio_epoll_create1 (int flags)
+{
+ return INLINE_SYSCALL (epoll_create1, 1, flags);
+}
+
+int
+lio_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
+{
+  return __do_epoll_ctl (EPOLL_VER, epfd, op, fd, event);
+}
+
+int
+lio_epoll_wait (int epfd, struct epoll_event *events, int maxevents,
+                int timeout)
+{
+  return __do_epoll_wait (EPOLL_VER, epfd, events, maxevents, timeout);
+}
+
+int
+lio_poll (struct pollfd *fds, int nfds, int timeout)
+{
+#ifdef __NR_poll
+  return SYSCALL_CANCEL (poll, fds, nfds, timeout);
+#else
+  struct timespec t;
+
+  t.tv_sec = timeout;
+  t.tv_nsec = 0;
+
+  if (timeout == -1)
+    return SYSCALL_CANCEL (ppoll, fds, nfds, NULL, NULL, 0);
+  else
+    return SYSCALL_CANCEL (ppoll, fds, nfds, &t, NULL, 0);
+#endif
+}
+
+int
+lio_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+	   const sigset_t *sigmask)
+{
+  return SYSCALL_CANCEL (ppoll, fds, nfds, tp, sigmask, _NSIG / 8);
+}
+
+int
+lio_access (const char *pathname, int mode)
+{
+#ifdef __NR_access
+  return INLINE_SYSCALL_CALL (access, pathname, mode);
+#else
+  return INLINE_SYSCALL_CALL (faccessat, AT_FDCWD, pathname, mode);
+#endif
+}
+
+int
+lio_uname (struct utsname *buf)
+{
+  return SYSCALL_CANCEL (uname, buf);
+}
+
+int
+lio_prctl (int option, ...)
+{
+  va_list arg;
+  va_start (arg, option);
+  unsigned long int arg2 = va_arg (arg, unsigned long int);
+  unsigned long int arg3 = va_arg (arg, unsigned long int);
+  unsigned long int arg4 = va_arg (arg, unsigned long int);
+  unsigned long int arg5 = va_arg (arg, unsigned long int);
+  va_end (arg);
+  return INLINE_SYSCALL_CALL (prctl, option, arg2, arg3, arg4, arg5);
+}
+
+int
+lio_chdir (const char *path)
+{
+  return INLINE_SYSCALL (chdir, 1, path);
+}
+
+int
+lio_mkdir (const char *path, mode_t mode)
+{
+  return INLINE_SYSCALL (mkdirat, 3, AT_FDCWD, path, mode);
+}
+
+int
+lio_rmdir (const char *path)
+{
+  return INLINE_SYSCALL (unlinkat, 3, AT_FDCWD, path, AT_REMOVEDIR);
+}
+
+int
+lio_chmod (const char *file, mode_t mode)
+{
+  return INLINE_SYSCALL (fchmodat, 3, AT_FDCWD, file, mode);
+}
+
+int
+lio_rename (const char *old, const char *new)
+{
+#if defined (__NR_rename)
+  return INLINE_SYSCALL_CALL (rename, old, new);
+#elif defined (__NR_renameat)
+  return INLINE_SYSCALL_CALL (renameat, AT_FDCWD, old, AT_FDCWD, new);
+#else
+  return INLINE_SYSCALL_CALL (renameat2, AT_FDCWD, old, AT_FDCWD, new, 0);
+#endif
+}
+
+int
+lio_fdatasync (int fd)
+{
+  return SYSCALL_CANCEL (fdatasync, fd);
+}
+
+int
+lio_fsync (int fd)
+{
+  return SYSCALL_CANCEL (fsync, fd);
+}
+
+#ifndef __NR_ftruncate64
+# define __NR_ftruncate64 __NR_ftruncate
+#endif
+
+/* Truncate the file referenced by FD to LENGTH bytes.  */
+int
+lio_ftruncate64 (int fd, off64_t length)
+{
+  return INLINE_SYSCALL_CALL (ftruncate64, fd,
+			      __ALIGNMENT_ARG SYSCALL_LL64 (length));
+}
+
+#ifndef __NR_truncate64
+# define __NR_truncate64 __NR_truncate
+#endif
+
+int
+lio_truncate64 (const char *path, off64_t length)
+{
+  return INLINE_SYSCALL_CALL (truncate64, path,
+			      __ALIGNMENT_ARG SYSCALL_LL64 (length));
+}
+
+mode_t
+lio_umask (mode_t mask)
+{
+  return INLINE_SYSCALL (umask, 1, mask);
+}
+
+off64_t
+lio_lseek64 (int fd, off64_t offset, int whence)
+{
+#ifdef __NR__llseek
+  loff_t res;
+  int rc = INLINE_SYSCALL_CALL (_llseek, fd,
+				(long) (((uint64_t) (offset)) >> 32),
+				(long) offset, &res, whence);
+  return rc ?: res;
+#else
+  return INLINE_SYSCALL_CALL (lseek, fd, offset, whence);
+#endif
+}
+
+int
+lio_sync_file_range (int fd, off64_t offset, off64_t len,
+                     unsigned int flags)
+{
+#if defined (__NR_sync_file_range2)
+  return SYSCALL_CANCEL (sync_file_range2, fd, flags, SYSCALL_LL64 (offset),
+			 SYSCALL_LL64 (len));
+#elif defined (__NR_sync_file_range)
+  return SYSCALL_CANCEL (sync_file_range, fd,
+			 __ALIGNMENT_ARG SYSCALL_LL64 (offset),
+			 SYSCALL_LL64 (len), flags);
+#endif
+}
+
+int
+lio_setitimer (int which, const struct itimerval *new, struct itimerval *old)
+{
+  return SYSCALL_CANCEL (setitimer, which, new, old);
+}
+
+int
+lio_getitimer (int which, struct itimerval *value)
+{
+  return SYSCALL_CANCEL (getitimer, which, value);
+}
+
+int
+lio_signalfd (int fd, const sigset_t *mask, int flags)
+{
+  return INLINE_SYSCALL (signalfd4, 4, fd, mask, sizeof (long), flags);
+}
+
+int
+lio_sigpending (sigset_t *set)
+{
+  return INLINE_SYSCALL (rt_sigpending, 2, set, sizeof (long));
+}
+
+int
+lio_execve (const char *path, char *const argv[], char *const envp[])
+{
+  return INLINE_SYSCALL_CALL (execve, path, argv, envp);
+}
diff --git a/remote_io/lio_sys_signal.c b/remote_io/lio_sys_signal.c
new file mode 100644
index 0000000000..c74726efaf
--- /dev/null
+++ b/remote_io/lio_sys_signal.c
@@ -0,0 +1,64 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <sys/syscall.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/uio.h>
+#include <elf.h>
+#include <errno.h>
+#include <sys/auxv.h>
+#include <nptl/pthreadP.h>
+#include <kernel_sigaction.h>
+#include "remote_io.h"
+#include "local_io.h"
+
+/* Glibc: sysdeps/unix/sysv/linux/sigopts.h  */
+
+/* Return a mask that includes the bit for SIG only.  */
+# define __sigmask(sig) \
+  (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))
+
+/* Return the word index for SIG.  */
+# define __sigword(sig) (((sig) - 1) / (8 * sizeof (unsigned long int)))
+
+int
+lio_rt_sigaction (int sig, const struct kernel_sigaction *kact,
+                  struct kernel_sigaction *koact, int nr)
+{
+  return SYSCALL_CANCEL (rt_sigaction,  sig, (uintptr_t) kact,
+			 (uintptr_t) koact, nr);
+}
+
+int
+lio_rt_sigprocmask (int how, const sigset_t *set, sigset_t *oset, int nr)
+{
+  sigset_t local_newmask;
+
+  /* The only thing we have to make sure here is that SIGCANCEL and
+     SIGSETXID are not blocked.  */
+  if (set != NULL
+      && __glibc_unlikely (__sigismember (set, SIGCANCEL)
+	|| __glibc_unlikely (__sigismember (set, SIGSETXID))))
+    {
+      local_newmask = *set;
+      __sigdelset (&local_newmask, SIGCANCEL);
+      __sigdelset (&local_newmask, SIGSETXID);
+      set = &local_newmask;
+    }
+
+  return INLINE_SYSCALL_CALL (rt_sigprocmask, how, set, oset, nr);
+}
+
+int
+lio_sigaddset (sigset_t *set, int sig)
+{
+  unsigned long int __mask = __sigmask (sig);
+  unsigned long int __word = __sigword (sig);
+
+  set->__val[__word] |= __mask;
+
+  return 0;
+}
\ No newline at end of file
diff --git a/remote_io/lio_util.c b/remote_io/lio_util.c
new file mode 100644
index 0000000000..793c433e5b
--- /dev/null
+++ b/remote_io/lio_util.c
@@ -0,0 +1,75 @@
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <linux/sockios.h>
+#include "local_io.h"
+#include "remote_io.h"
+
+#define __USE_GNU 1
+#include <search.h>
+
+void
+lio_print (const char *str)
+{
+  int len;
+
+  for (len = 0; str[len] != '\0'; len++)
+    ;
+
+  lio_write (1, str, len);
+}
+
+void
+lio_error (const char *restrict fmt, ...)
+{
+  va_list arg;
+
+  va_start (arg, fmt);
+  rio_dbg_vfprintf (STDOUT_FILENO, fmt, arg);
+  va_end (arg);
+
+  lio_spin ();
+  lio_exit (-1);
+}
+
+void
+lio_assert (int cond, const char *restrict msg, const char *restrict file, int lineno)
+{
+  if (cond)
+    return;
+
+  lio_error ("%s:%u -- %s\n", file, lineno, msg);
+}
+
+void
+lio_assert_sock_free (int fd, const char *fn, int lineno)
+{
+  int res;
+
+  /* man 3 tcp.  */
+  lio_ioctl_3 (fd, SIOCINQ, &res);
+  if (res != 0)
+    lio_error ("%s @ %u: detected incoming message fragments = %u\n", fn, lineno, res);
+
+  /*
+  lio_ioctl_3 (fd, SIOCOUTQ, &res);
+  if (res != 0)
+    lio_error ("%s @ %u: detected outgoing message fragments = %u\n", fn, lineno, res);
+  */
+}
+
+void
+lio_inet_ntop (int af, const void *src, char *dst, size_t size)
+{
+  const unsigned char *usrc = src;
+
+  if (af != AF_INET)
+    {
+      rio_dbg_snprintf (dst, size, "<unknown>");
+      return;
+    }
+
+  rio_dbg_snprintf (dst, size, "%u.%u.%u.%u", usrc[0], usrc[1], usrc[2], usrc[3]);
+}
diff --git a/remote_io/local_io.h b/remote_io/local_io.h
new file mode 100644
index 0000000000..9a8566cf19
--- /dev/null
+++ b/remote_io/local_io.h
@@ -0,0 +1,193 @@
+#ifndef LIO_H
+#define LIO_H
+
+#include <unistd.h>
+#include <stddef.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
+#include <sys/vfs.h>
+#include <signal.h>
+#include <stddef.h>
+
+#if defined (__x86_64__)
+#define pcn_break()  do { asm volatile ("int3;"); } while (0)
+#elif defined (__aarch64__)
+#define pcn_break()  do { asm volatile ("brk #01;"); } while (0)
+#else
+#define pcn_break() spin()
+#endif
+
+#define LIO_ASSERT(cond, msg) lio_assert ((int)(cond), msg, __FILE__, __LINE__)
+
+struct iovec;
+struct pollfd;
+struct epoll_event;
+struct utsname;
+struct stat;
+struct kernel_sigaction;
+struct rusage;
+struct itimerval;
+
+#define lio_stdin STDIN_FILENO
+#define lio_stdout STDOUT_FILENO
+#define lio_stderr STDERR_FILENO
+
+extern int pcn_mode; // 1 = server
+
+extern void *lio_mmap(void *addr, size_t length, int prot, int flags,
+		     int fd, off_t offset);
+extern int lio_munmap (void *addr, size_t len);
+extern int lio_mprotect (void *addr, size_t len, int prot);
+extern int lio_write (int fd, const void *buf, unsigned long count);
+extern int lio_writev (int fd, const struct iovec *iov, int iovcnt);
+extern ssize_t lio_pwrite (int fd, const void *buf, size_t count,
+                           off64_t offset);
+extern ssize_t lio_pwritev64 (int fd, const struct iovec *vector, int count,
+                              off64_t offset);
+extern ssize_t lio_read(int fd, void *buf, size_t count);
+extern ssize_t lio_pread(int fd, void *buf, size_t count, off_t offset);
+extern int lio_open (const char *pathname, int flags, mode_t mode);
+extern int lio_openat (int dirfd, const char *pathname, int flags, mode_t mode);
+extern int lio_close (int fd);
+extern int lio_fstatat (int dirfd, const char *restrict pathname,
+			struct stat *restrict statbuf, int flags);
+extern int lio_fstat (int fd, struct stat *statbuf);
+extern int lio_stat (const char *restrict pathname,
+                    struct stat *restrict statbuf);
+extern int lio_statfs (const char *file, struct statfs *buf);
+extern int lio_fstatfs (int fd, struct statfs *buf);
+extern int lio_truncate (const char *path, off_t length);
+extern int lio_ftruncate (int fd, off_t length);
+extern int lio_fallocate (int fd, int mode, off_t offset, off_t len);
+
+extern int lio_link (const char *oldpath, const char *newpath);
+extern int lio_unlink (const char *pathname);
+extern int lio_symlink (const char *from, const char *to);
+extern ssize_t lio_readlink (const char *path, char *buf, size_t len);
+extern int lio_getcwd (char *buf, size_t size);
+extern ssize_t lio_getdents64 (int fd, void *buf, size_t nbytes);
+extern int lio_chdir (const char *path);
+extern int lio_mkdir (const char *path, mode_t mode);
+extern int lio_rmdir (const char *path);
+extern int lio_chmod (const char *file, mode_t mode);
+extern int lio_rename (const char *old, const char *new);
+extern int lio_fdatasync (int fd);
+extern int lio_fsync (int fd);
+extern int lio_ftruncate64 (int fd, off64_t length);
+extern int lio_truncate64 (const char *path, off64_t length);
+extern mode_t lio_umask (mode_t mask);
+extern off64_t lio_lseek64 (int fd, off64_t offset, int whence);
+extern int lio_sync_file_range (int fd, off64_t offset, off64_t len,
+                                unsigned int flags);
+
+extern int lio_ioctl_3 (int fd, unsigned long request, const void *arg);
+extern int lio_fcntl (int fd, int cmd, void *arg);
+
+extern int lio_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len);
+extern int lio_accept_raw (int sockfd, const void *addr, socklen_t *addrlen);
+extern int lio_socket (int domain, int type, int protocol);
+extern ssize_t lio_sendfile (int out_fd, int in_fd, off_t *offset, size_t count);
+extern int lio_bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
+extern int lio_bind_raw (int fd, const void * addr, socklen_t len);
+extern int lio_getpeername (int fd, __SOCKADDR_ARG addr, socklen_t *len);
+extern int lio_getsockname (int fd, __SOCKADDR_ARG addr, socklen_t *len);
+extern int lio_getsockopt (int fd, int level, int optname, const void *optval,
+			   socklen_t *len);
+extern int lio_setsockopt (int fd, int level, int optname, const void *optval,
+			   socklen_t len);
+extern int lio_sigpending (sigset_t *set);
+extern int lio_listen (int sockfd, int backlog);
+extern int lio_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
+extern ssize_t lio_recvfrom(int sockfd, void *restrict buf, size_t len, int flags,
+                            struct sockaddr *restrict src_addr,
+                            socklen_t *restrict addrlen);
+extern ssize_t lio_recvmsg (int sockfd, struct msghdr *rmsg, int flags);
+extern ssize_t lio_send (int fd, const void *buf, size_t len, int flags);
+extern ssize_t lio_sendto (int fd, const void *buf, size_t len, int flags,
+                           __CONST_SOCKADDR_ARG addr, socklen_t addrlen);
+extern int lio_pselect (int nfds, fd_set *readfds, fd_set *writefds,
+                        fd_set *exceptfds, const struct timespec *timeout,
+                        const sigset_t *sigmask);
+extern int lio_select (int nfds, fd_set *readfds, fd_set *writefds,
+                       fd_set *exceptfds, struct timeval *timeout);
+
+extern void lio_exit (int status);
+extern int lio_getpid (void);
+extern int lio_gettid (void);
+extern int lio_kill (pid_t pid, int sig);
+extern int lio_tgkill (pid_t pid, pid_t tid, int sig);
+extern int lio_arch_prctl (int code, unsigned long addr);
+extern pid_t lio_wait4 (pid_t pid, int *stat_loc, int options,
+                        struct rusage *usage);
+extern int lio_execve (const char *path, char *const argv[], char *const envp[]);
+
+extern int lio_getitimer (int which, struct itimerval *value);
+extern int lio_rt_sigaction (int sig, const struct kernel_sigaction *kact,
+			    struct kernel_sigaction *koact, int nr);
+extern int lio_rt_sigprocmask (int how, const sigset_t *set, sigset_t *oset,
+                               int nr);
+extern int lio_sigaddset (sigset_t *set, int sig);
+extern int lio_setitimer (int which, const struct itimerval *new,
+	                 struct itimerval *old);
+extern int lio_signalfd (int fd, const sigset_t *mask, int flags);
+extern int lio_dup (int oldfd);
+extern int lio_dup2 (int oldfd, int newfd);
+extern int lio_dup3 (int oldfd, int newfd, int flags);
+extern int lio_pipe2 (int pfds[2], int flags);
+
+extern int lio_epoll_create1 (int flags);
+extern int lio_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event);
+extern int lio_epoll_wait (int epfd, struct epoll_event *events, int maxevents,
+                           int timeout);
+extern int lio_poll (struct pollfd *fds, int nfds, int timeout);
+extern int lio_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+		      const sigset_t *sigmask);
+
+extern int lio_access (const char *pathname, int mode);
+extern int lio_uname (struct utsname *buf);
+
+extern int lio_prctl (int __option, ...);
+
+/* Utility functions  */
+
+extern int lio_strlen (const char *str);
+extern int lio_strcmp (const char *a, const char *b);
+extern int lio_strncmp(const char *s1, const char *s2, size_t n);
+extern size_t lio_strlcpy(char *dst, const char *src, size_t size);
+extern char *lio_strdup (const char *str);
+extern void lio_memset (void *s, int c, size_t n);
+extern void *lio_memcpy (void *restrict d, const void *s, size_t n);
+extern int lio_memcmp(const void *s1, const void *s2, size_t n);
+extern void lio_spin (void);
+
+extern int lio_dbg_printf (const char *fmt, ...);
+extern void lio_print (const char *str);
+extern void lio_error (const char *restrict fmt, ...);
+extern void lio_assert (int cond, const char *restrict msg,
+			const char *restrict file, int lineno);
+
+extern void lio_inet_ntop (int af, const void *src, char *dst, size_t size);
+
+extern void *lio_malloc (size_t size);
+extern void lio_free (void *ptr);
+extern void *lio_calloc(size_t nmemb, size_t size);
+extern void * lio_realloc(void *ptr, size_t size);
+
+extern void lio_assert_sock_free (int fd, const char *fn, int lineno);
+
+/* Eventually this will be a debug option.  */
+#define lio_assert_empty_socket(fd) (lio_assert_sock_free ((fd), __FUNCTION__, __LINE__))
+
+/* Multi-versioned functions.  */
+extern int __do_epoll_ctl (int ver, int epfd, int op, int fd,
+			   struct epoll_event *event);
+extern int __do_epoll_wait (int ver, int epfd, struct epoll_event *events,
+			    int maxevents, int timeout);
+extern int __do_epoll_pwait (int ver, int epfd, struct epoll_event *events,
+			     int maxevents, int timeout,
+                             const sigset_t *sigmask);
+
+/* Workaround LLVM Stackmap liveout limitations.  */
+#define LIO_LIVE(var) (*(volatile typeof(var)*)&(var))
+
+#endif
diff --git a/remote_io/log.c b/remote_io/log.c
new file mode 100644
index 0000000000..69a69d8327
--- /dev/null
+++ b/remote_io/log.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdarg.h>
+#include <unistd.h>
+
+#define BUF_SIZE 32
+
+int popcorn_log(const char *format, ...)
+{
+  int ret = -1;
+  char buf[BUF_SIZE];
+  FILE *fp;
+  va_list ap;
+
+  snprintf(buf, BUF_SIZE, "/tmp/%d.log", gettid());
+  fp = fopen(buf, "a");
+  if(fp) {
+    va_start(ap, format);
+    ret = vfprintf(fp, format, ap);
+    fclose(fp);
+  }
+  return ret;
+}
+
diff --git a/remote_io/message.h b/remote_io/message.h
new file mode 100644
index 0000000000..fa3d825433
--- /dev/null
+++ b/remote_io/message.h
@@ -0,0 +1,441 @@
+#ifndef MESSAGE_H
+#define MESSAGE_H
+
+/* Other header files shouldn't be included here. Ultimately,
+  the structures should be defined elsewhere, especially if they
+  have external structure dependencies.  */
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <sys/time.h>
+struct iovec;
+
+typedef enum {
+  PCN_TYPE_CONTROL,
+  PCN_TYPE_SYSCALL,
+  PCN_TYPE_POLL,
+  PCN_TYPE_RES,
+} pcn_msg_type;
+
+typedef enum {
+  PCN_SYS_OPEN,
+  PCN_SYS_CLOSE,
+  PCN_SYS_READ,
+  PCN_SYS_PREAD,
+  PCN_SYS_WRITE,
+  PCN_SYS_FXSTATAT,
+  PCN_SYS_MMAP,
+  PCN_SYS_MUNMAP,
+  PCN_SYS_EPOLL_CREATE,
+  PCN_SYS_EPOLL_CTL,
+  PCN_SYS_EPOLL_WAIT,
+  PCN_SYS_FALLOCATE,
+  PCN_SYS_RT_SIGACTION,
+  PCN_SYS_FCNTL,
+  PCN_SYS_GETCWD,
+  PCN_SYS_PIPE,
+  PCN_SYS_SOCKET,
+  PCN_SYS_GETSOCKOPT,
+  PCN_SYS_SETSOCKOPT,
+  PCN_SYS_BIND,
+  PCN_SYS_LISTEN,
+  PCN_SYS_ACCEPT,
+  PCN_SYS_CONNECT,
+  PCN_SYS_POLL,
+  PCN_SYS_PPOLL,
+  PCN_SYS_ACCESS,
+  PCN_SYS_UNAME,
+  PCN_SYS_GETPEERNAME,
+  PCN_SYS_RECVFROM,
+  PCN_SYS_RECVMSG,
+  PCN_SYS_GETSOCKNAME,
+  PCN_SYS_SEND,
+  PCN_SYS_SENDTO,
+  PCN_SYS_DUP,
+  PCN_SYS_DUP2,
+  PCN_SYS_DUP3,
+  PCN_SYS_GETDENTS64,
+  PCN_SYS_CHDIR,
+  PCN_SYS_CHMOD,
+  PCN_SYS_FDATASYNC,
+  PCN_SYS_FSYNC,
+  PCN_SYS_FTRUNCATE64,
+  PCN_SYS_TRUNCATE64,
+  PCN_SYS_LINK,
+  PCN_SYS_UNLINK,
+  PCN_SYS_SYMLINK,
+  PCN_SYS_READLINK,
+  PCN_SYS_MKDIR,
+  PCN_SYS_RMDIR,
+  PCN_SYS_RENAME,
+  PCN_SYS_UMASK,
+  PCN_SYS_LSEEK,
+  PCN_SYS_SYNC_FILE_RANGE,
+  PCN_SYS_KILL,
+  PCN_SYS_EPOLL_PWAIT,
+  PCN_SYS_SELECT,
+  PCN_SYS_PSELECT,
+  PCN_SYS_PWRITE,
+  PCN_SYS_STATFS,
+  PCN_SYS_FSTATFS,
+  PCN_SYS_SETITIMER,
+  PCN_SYS_GETITIMER,
+  PCN_SYS_SIGNALFD,
+} pcn_syscall;
+
+typedef enum {
+  PCN_CTL_ACK,
+  PCN_CTL_MIGRATE,
+  PCN_CTL_ATTACH,
+  PCN_CTL_SYNC,
+  PCN_CTL_FORK,
+  PCN_CTL_EXEC,
+  PCN_CTL_RESTART_DISABLED,
+} pcn_control;
+
+typedef enum {
+  PCN_SEND_SYNC = 0,
+  PCN_SEND_ASYNC,
+  PCN_SEND_NORET,
+} pcn_send_t;
+
+typedef enum {
+  PCN_SIG_SHUTDOWN,
+  PCN_SIG_KILL,
+  PCN_SIG_ADD,
+} pcn_signal_t;
+
+typedef enum {
+  PCN_POLL_RIO_ONGOING,
+  PCN_POLL_RIO_COMPLETE,
+  PCN_POLL_STOP,
+  PCN_POLL_RESUME,
+} pcn_poll_t;
+
+#define PCN_EPOLL_TYPE_CTL 1
+#define PCN_EPOLL_TYPE_WAIT 2
+
+#define set_arg(val, arg) ((val) |= (1<<(arg)))
+#define get_arg(val, arg) ((val) & (1<<(arg)))
+
+struct pcn_msg_hdr {
+  pcn_msg_type msg_type;
+  int msg_kind;
+  int msg_id;
+  int msg_size;  /* size of the message payload. */
+  int msg_errno;
+  pcn_send_t msg_async;
+} __attribute__ ((packed));
+
+struct pcn_msg_open {
+  int flags;
+  mode_t mode;
+  int dirfd;
+  char pathname[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_close {
+  int fd;
+  int err;
+  int res;
+} __attribute__ ((packed));
+
+struct pcn_msg_read {
+  int fd;
+  long cnt;
+  long offset;
+  char buf[0];
+} __attribute__ ((packed));
+
+struct pcn_write_msg {
+  int fd;
+  long size;
+  long offset;
+  char buf[0];
+};
+
+struct pcn_msg_fallocate {
+  int fd;
+  int mode;
+  off_t offset;
+  off_t len;
+} __attribute__ ((packed));
+
+struct pcn_msg_fxstatat {
+  int fd;
+  int flag;
+  int size;
+  int vers;
+  long st_dev;
+  long st_ino;
+  long st_mode;
+  long st_nlink;
+  long st_uid;
+  long st_gid;
+  long st_rdev;
+  long st_size;
+  long st_blksize;
+  long st_blocks;
+  struct timespec st_atim;
+  struct timespec st_mtim;
+  struct timespec st_ctim;
+  char pathname[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_mmap {
+  void *addr;
+  size_t length;
+  int prot;
+  int flags;
+  int fd;
+  off_t offset;
+} __attribute__ ((packed));
+
+struct pcn_msg_epoll {
+  int ver;
+  int epfd;
+  int arg1;
+  int arg2;
+} __attribute__ ((packed));
+
+struct pcn_msg_epoll_pwait {
+  int ver;
+  int epfd;
+  int maxevents;
+  int timeout;
+  long sigmask;
+  char events[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_signal {
+  int sig;
+  int pid;
+  int type;
+} __attribute__ ((packed));
+
+struct pcn_msg_fcntl {
+  int fd;
+  int cmd;
+  void *arg;
+} __attribute__ ((packed));
+
+struct pcn_msg_pipe {
+  int pfds[2];
+  int res;
+  int _errno;
+} __attribute__ ((packed));
+
+struct pcn_msg_socket {
+  int domain;
+  int type;
+  int protocol;
+} __attribute__ ((packed));
+
+struct pcn_msg_sockopt {
+  int sockfd;
+  int level;
+  int optname;
+  int optlen;
+  char optval[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_bind {
+  int sockfd;
+  int addrlen;
+  int rio_errno;
+  char addr[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_listen {
+  int sockfd;
+  int backlog;
+} __attribute__ ((packed));
+
+struct pcn_msg_poll {
+  int nfds;
+  long tv_sec;
+  long tv_nsec;
+  sigset_t sigmask;
+  char fds[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_getpeername {
+  int sockfd;
+  socklen_t addrlen;
+  int rio_errno;
+  char addr[0];
+} __attribute__ ((packed));
+
+#define PCN_UNAME_LEN 65
+struct pcn_msg_uname {
+  int rio_errno;
+  int rio_res;
+  char sysname[PCN_UNAME_LEN];
+  char nodename[PCN_UNAME_LEN];
+  char release[PCN_UNAME_LEN];
+  char version[PCN_UNAME_LEN];
+
+  char machine[PCN_UNAME_LEN];
+  char domainname[PCN_UNAME_LEN];
+} __attribute__ ((packed));
+
+struct pcn_msg_recvfrom {
+  int sockfd;
+  long len;
+  int flags;
+  struct sockaddr_storage src_addr;
+  socklen_t addrlen;
+  int rio_errno;
+} __attribute__ ((packed));
+
+struct pcn_msg_recvmsg {
+  int sockfd;
+  int flags;
+  struct sockaddr_storage msg_name;
+  int msg_namelen;
+  long msg_iovsize;
+  int msg_controllen;
+  int msg_flags;
+  int rio_errno;
+} __attribute__ ((packed));
+
+struct pcn_msg_send {
+  int sockfd;
+  long len;
+  int flags;
+  char buf[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_sendto {
+  int sockfd;
+  long len;
+  int flags;
+  struct sockaddr_storage dest_addr;
+  socklen_t addrlen;
+  char buf[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_getdents {
+  int fd;
+  size_t nbytes;
+  char buf[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_chmod {
+  mode_t mode;
+  char file[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_ftruncate {
+  int fd;
+  unsigned long length;
+} __attribute__ ((packed));
+
+struct pcn_msg_truncate {
+  unsigned long length;
+  char path[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_link {
+  int from_len;
+  int to_len;
+} __attribute__ ((packed));
+
+struct pcn_msg_readlink {
+  int path_len;
+  int bufsz;
+} __attribute__ ((packed));
+
+struct pcn_msg_mkdir {
+  mode_t mode;
+  char path[0];
+} __attribute__ ((packed));
+
+struct pcn_msg_lseek {
+  int fd;
+  unsigned long offset;
+  int whence;
+} __attribute__ ((packed));
+
+struct pcn_msg_sync_file_range {
+  int fd;
+  unsigned long offset;
+  unsigned long len;
+  unsigned int flags;
+} __attribute__ ((packed));
+
+struct pcn_msg_select {
+  int nfds;
+  fd_set readfds;
+  fd_set writefds;
+  fd_set exceptfds;
+  struct timeval tv;
+  unsigned char args;
+} __attribute__ ((packed));
+
+struct pcn_msg_pselect {
+  int nfds;
+  fd_set readfds;
+  fd_set writefds;
+  fd_set exceptfds;
+  struct timespec ts;
+  long sigmask;
+  unsigned char args;
+} __attribute__ ((packed));
+
+struct pcn_msg_select_res {
+  int res;
+  int rio_errno;
+  fd_set readfds;
+  fd_set writefds;
+  fd_set exceptfds;
+} __attribute__ ((packed));
+
+struct pcn_msg_setitimer {
+  int which;
+  struct itimerval new;
+  unsigned int null_args;
+} __attribute__ ((packed));
+
+struct pcn_msg_signalfd {
+  int fd;
+  unsigned long sigmask;
+  int size;
+  int flags;
+} __attribute__ ((packed));
+
+struct pcn_msg_io_mmap {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_mmap mmap;
+} __attribute__ ((packed));
+
+struct pcn_msg_io_open {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_open open;
+} __attribute__ ((packed));
+
+struct pcn_msg_io_data {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_read data;
+} __attribute__ ((packed));
+
+struct pcn_msg_io_close {
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_close close;
+} __attribute__ ((packed));
+
+/* A generic PCN syscall response. */
+struct pcn_msg_res {
+  long res;
+  int id;
+  int rio_errno;
+};
+
+/* Message Functions */
+extern int rio_msg_id (void);
+extern int rio_msg_send_iov (int fd, struct pcn_msg_hdr *hdr,
+                             struct iovec *payload, int cnt);
+extern int rio_msg_send (int fd, struct pcn_msg_hdr *hdr);
+extern void rio_msg_res (int fd, struct pcn_msg_res *res);
+extern int rio_msg_ack (int sockfd, struct pcn_msg_hdr *hdr, int res);
+
+#endif
diff --git a/remote_io/notes.txt b/remote_io/notes.txt
new file mode 100644
index 0000000000..93dc86be2f
--- /dev/null
+++ b/remote_io/notes.txt
@@ -0,0 +1,189 @@
+PostgreSQL:
+ * clone
+ * execve
+ * exit_group
+ * wait4 [*]
+
+ * kill [SP]
+
+ * setsid
+
+ * futex [*]
+ * set_robust_list
+
+ * ioctl [* not used by postgres proper]
+ * mmap
+ * mprotect
+ * mremap
+ * munmap
+ * newfstatat
+ * rt_sigaction
+ * rt_sigprocmask
+ * rt_sigreturn
+
+Environment variables
+ * RIO_DEBUG={1,2,3}
+   - 1: Enable both RIO server and client diagnostics
+   - 2: Only generate RIO server diagnostics
+   - 3: Only generate RIO client diagnostics
+ * RIO_DBG_FILE=filename
+   - Opens filename as a truncated file for writing all of the RIO
+     diagnostics as specified by RIO_DEBUG.
+   - If RIO_DBG_FILE is not specified, RIO_DEBUG diagnostics are
+     emitted to stdout.
+
+General
+ * Remove elf/rtld dependencies on remote_io (rio is probably
+   being pulled in from the system call forwarding)
+ * Add memory allocator for rtld
+ * Teach pcn_mmap to cache read-only files. Xcalc maps locale-archive,
+   which is 214M. So if that file could be cached, Xcalc would start
+   up faster.
+ * Glibc's malloc contains many static global variables. Consequently,
+   a malloc'ed allocation that occurred before migration cannot be freed
+   after migration.
+ * O_DIRECT, from fcntl.h, is defined differently for x86 and ARM64.
+   Therefore build Popcorn executables separately with -popcorn-target=...
+ * RIO gives special care to SIGCHLD. It presently is not forwarded through
+   signalfd.
+ * Glibc reserves RT signal 34 for CRIU to initiate migration. This is
+   necessary because the client blocks signals while the RIO server is
+   processing them. In order to improve responsiveness, long running
+   system calls, eg. poll, epoll, select, have their polling broken down
+   to shorter intervals. Glibc installs a NOP signal handler for Signal 34.
+ * Migration needs to be explicitly disabled by the programmer in ISR's
+   by calling pcn_migrate_disable / pcn_migrate_enable. Also, each ISR
+   needs to have the __attribute__((pcn_data)) set.
+ * Break up pcn_data into small struct which can be malloc'ed for better
+   randomization of data.
+
+SYSV IPC
+ * CRIU excepts all SYSV IPC resources to be in a separate namespace,
+   either using docker or 'unshare -i'. E.g.
+     $ touch /root/ipc-ns
+     $ unshare --ipc=/root/ipc-ns ./foo
+
+TODO
+ * Clean up usage of rio_msg_send_raw.
+ * Check return status of rio_msg*.
+ * Update pcn_sys_mmap to better use lio_malloc
+ * Teach llvm to use lio_memcpy / lio_memset when any Popcorn flag has
+   been specified.
+ * Update LLVM to make to capture LIVE_IN registers in stackmaps, not
+   just LIVE_OUT, as stack unwinding reqires LIVE_IN registers. This
+   problem could manifest if a functions arguments are passed to another
+   function, but not used elsewhere inside the function. A workaround
+   for this issue is to use the LIO_LIVE macro to force a variable to
+   be live.
+ * Handle the interruptible select/pselect case when those system calls
+   return 0.
+ * Handle execve gracefully when the exec'ed application is not linked
+   against Popcorn glibc. Probably need a way to decode which version of
+   libc is being used to coordinate with the RIO server accordingly.
+ * Teach LLVM not to pass temporary values to functions. See test-fork-3.c's
+   usage of static variable for epfd as a workaround for this defect.
+ * Make openat multi-versioned for ARM64 as it defines O_DIRECTORY,
+   O_NOFOLLOW, and O_DIRECT differently from x86. At present, AArch64
+   defaults to the same version as x86.
+
+NOPs
+ * arch_prctl
+ * brk
+ * futex
+ * geteuid
+ * getpid
+ * getppid
+ * getrandom
+ * getrusage [*]
+ * getuid
+ * prctl [*]
+ * prlimit64 [*]
+ * rseq [todo - DISABLE because of multi-ISA incompatilities]
+ * set_tid_address
+ * shm_open [*]
+ * shm_unlink [*]
+ * shmat [todo: SHM_REMAP]
+ * shmctl
+ * shmdt
+ * shmget
+ * sysinfo
+
+Forwarded System Calls
+ * access
+ * chdir
+ * close
+ * chmod
+ * dup
+ * dup2rio
+ * dup3
+ * faccessat [*]
+ * fallocate
+ * fchmodat [*]
+ * fcntl [*]
+ * fdatasync
+ * fstat
+ * fstatfs
+ * fsync
+ * ftruncate
+ * fxstatat
+ * getcwd
+ * getdents64
+ * getitimer
+ * kill
+ * link
+ * mkdir
+ * lseek
+ * lstat
+ * mmap
+ * munmap
+ * openat
+ * pipe
+ * pipe2
+ * pread64
+ * pwrite64
+ * pwritev64
+ * read
+ * readlink
+ * rename
+ * renameat [*]
+ * rmdir
+ * setitimer
+ * signalfd4
+ * symlink
+ * sync_file_range
+ * stat
+ * statfs
+ * truncate
+ * umask
+ * uname
+ * unlink
+ * unlinkat [*]
+ * write
+ * writev
+
+ * epoll_create
+ * epoll_create1
+ * epoll_ctl
+ * epoll_wait
+ * epoll_pwait
+ * poll
+ * ppoll
+ * pselect6
+ * select
+ * sigaction
+
+ * accept
+ * bind
+ * connect
+ * getpeername
+ * getsockopt
+ * listen
+ * recv
+ * recvfrom
+ * recvmsg
+ * send
+ * sendto
+ * socket
+ * setsockopt
+ * uname
+ * getsockname
diff --git a/remote_io/pcn-platform.h b/remote_io/pcn-platform.h
new file mode 100644
index 0000000000..a8cf57648b
--- /dev/null
+++ b/remote_io/pcn-platform.h
@@ -0,0 +1,68 @@
+/*
+ * Popcorn-specific platform information.
+ *
+ * Author: Rob Lyerly <rlyerly@vt.edu>
+ * Date: February 13th, 2018
+ */
+
+#ifndef _PLATFORM_H
+#define _PLATFORM_H
+
+/* The size of a page in the system. */
+#define PAGESZ 4096UL
+
+/*
+ * Round down & up to the nearest pages, respectively.  Arguments must be of
+ * unsigned long/uint64_t type.
+ */
+#define PAGE_ROUND_DOWN( x ) ((x) & ~(PAGESZ - 1))
+#define PAGE_ROUND_UP( x ) PAGE_ROUND_DOWN((x) + PAGESZ - 1)
+
+/* The maximum number of nodes supported by the system. */
+#define MAX_POPCORN_NODES 32
+
+/* Status of thread within Popcorn's single system image */
+struct popcorn_thread_status {
+  int current_nid;  /* The thread's current node */
+  int proposed_nid; /* Destination node if somebody proposed migration */
+  int peer_nid;     /* Node ID of peer thread in SSI */
+  int peer_pid;     /* PID of peer thread in SSI */
+};
+
+/*
+ * Return the node ID on which the current thread is executing.
+ * @return the current node ID or -1 otherwise
+ */
+extern int popcorn_getnid(void);
+
+/*
+ * Query thread status information.  Populates the thread status struct with
+ * the current thread's status.
+ *
+ * @param status thread status struct
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+extern int popcorn_getthreadinfo(struct popcorn_thread_status *status);
+
+/* Status of nodes in Popcorn's single system image */
+struct popcorn_node_status {
+  unsigned int status; /* 1 if online, 0 if not */
+  int arch;            /* Architecture of node -- see arch.h */
+  int distance;        /* Hop distance between current and other node */
+};
+
+/*
+ * Query node status information.  Populates the integer passed via pointer
+ * with the ID of the origin node and populates the array of nodes status
+ * structs with their current status.
+ *
+ * @param origin pointer to integer to be set with the origin ID
+ * @param status array of node status structs, must have MAX_POPCORN_NODES
+ *               elements
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+extern int popcorn_getnodeinfo(int *origin,
+                        struct popcorn_node_status status[MAX_POPCORN_NODES]);
+
+#endif /* _PLATFORM_H */
+
diff --git a/remote_io/pcn_disconnect.c b/remote_io/pcn_disconnect.c
new file mode 100644
index 0000000000..48f320d4e7
--- /dev/null
+++ b/remote_io/pcn_disconnect.c
@@ -0,0 +1,94 @@
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <elf/popcorn.h>
+#include "message.h"
+#include "local_io.h"
+#include "server.h"
+#include "remote_io.h"
+
+int
+pcn_rio_disconnect (void)
+{
+  DIR *dir;
+  struct dirent *de;
+  struct stat st_stdout, st;
+  char fname[300];
+  int fd = -1, pgid = -1;
+
+  if (!getenv ("PCN_RIO_LOCAL"))
+    {
+      pcn_data->pcn_remote_io_active = 0;
+
+      /* This closes STDIN_FILENO.  */
+      close (pcn_data->pcn_server_sockfd);
+
+      /* Restore STDIN_FILENO.  */
+      fstat (STDOUT_FILENO, &st_stdout);
+
+      dir = opendir ("/dev/pts");
+      while ((de = readdir (dir)) != NULL)
+        {
+          rio_dbg_snprintf (fname, 300, "/dev/pts/%s", de->d_name);
+          stat (fname, &st);
+          if (st.st_ino == st_stdout.st_ino)
+            break;
+        }
+
+      if (de == NULL)
+        {
+          rio_dbg_printf ("%s: Error: could not restore STDIN\n", __FUNCTION__);
+          closedir (dir);
+          return -1;
+        }
+
+      closedir (dir);
+
+      fd = open (fname, O_WRONLY);
+      if (fd < 0)
+        {
+          rio_dbg_printf ("%s: Error: could not restore STDIN\n", __FUNCTION__);
+          return -1;
+        }
+      else if (fd > STDIN_FILENO)
+        {
+          int newfd = lio_dup2 (fd, STDIN_FILENO);
+          if (newfd != STDIN_FILENO)
+            {
+              rio_dbg_printf ("%s: Error: could not dup2 file\n", __FUNCTION__);
+              return -1;
+            }
+          close (fd);
+          fd = newfd;
+        }
+
+      /* Place popcorn-killd in the foreground in place of the original RIO server.  */
+      signal(SIGTTOU, SIG_IGN);
+      pgid = getpid ();
+      setpgid (pgid, pgid);
+      pgid = tcsetpgrp(0, pgid);
+    }
+
+  return fd;
+}
+
+void
+pcn_rio_restart_disabled (void)
+{
+  struct pcn_msg_hdr hdr;
+
+  if (pcn_data->pcn_remote_io_active == 0)
+    return;
+
+  hdr.msg_type = PCN_TYPE_CONTROL;
+  hdr.msg_kind = PCN_CTL_RESTART_DISABLED;
+  hdr.msg_id = rio_msg_id ();
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (hdr);
+
+  rio_msg_send (pcn_data->pcn_server_sockfd, &hdr);
+
+  exit (EXIT_SUCCESS);
+}
diff --git a/remote_io/pcn_migrate.c b/remote_io/pcn_migrate.c
new file mode 100644
index 0000000000..600d41b35b
--- /dev/null
+++ b/remote_io/pcn_migrate.c
@@ -0,0 +1,47 @@
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "local_io.h"
+
+void
+pcn_migrate (void)
+{
+  struct pcn_msg_hdr hdr;
+
+  hdr.msg_type = PCN_TYPE_CONTROL;
+  hdr.msg_kind = PCN_CTL_MIGRATE;
+  hdr.msg_id = rio_msg_id ();
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (hdr);
+
+  rio_msg_send (pcn_data->pcn_server_sockfd, &hdr);
+
+  lio_close (pcn_data->pcn_server_sockfd);
+
+  pcn_data->pcn_server_sockfd = -1;
+
+  rio_dbg_printf ("%s: success!\n", __FUNCTION__);
+}
+
+void pcn_migrate_disable (void)
+{
+  pcn_data->rio_migrate_disabled = 1;
+}
+
+void
+pcn_migrate_enable (void)
+{
+  pcn_data->rio_migrate_disabled = 0;
+}
+
+extern void check_migrate (void *, void *);
+libc_hidden_proto (check_migrate)
+
+void
+check_migrate (void *a __attribute__ ((unused)),
+                 void *b __attribute__ ((unused)))
+{
+  return;
+}
+
+libc_hidden_weak (check_migrate)
diff --git a/remote_io/pcn_signals.c b/remote_io/pcn_signals.c
new file mode 100644
index 0000000000..4a4959fdfd
--- /dev/null
+++ b/remote_io/pcn_signals.c
@@ -0,0 +1,137 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <signal.h>
+#include <errno.h>
+#include <termios.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+#define GLIBC_SIG_1 32
+#define GLIBC_SIG_2 33
+
+#define PCN_SIGNAL_DEBUG 1
+
+static void
+pcn_sigerror (int signo, siginfo_t *info, void *data)
+{
+  lio_dbg_printf ("%s: pid = %d, signo = %d, info = %lx, data = %lx\n",
+                  __FUNCTION__, getpid (), signo, info, data);
+  lio_spin ();
+  lio_dbg_printf ("%s: addr = %lx\n", __FUNCTION__, info->si_addr);
+}
+
+void
+pcn_setup_sigerror (int signo)
+{
+#ifdef PCN_SIGNAL_DEBUG
+  struct sigaction act;
+
+  rio_dbg_printf ("%s: settting up signal '%u'\n", __FUNCTION__, signo);
+
+  sigemptyset (&act.sa_mask);
+  act.sa_flags = SA_SIGINFO;
+  act.sa_sigaction = pcn_sigerror;
+  sigaction (signo, &act, NULL);
+#endif
+}
+
+int
+pcn_unload_signals (void)
+{
+  int status = rio_disable ();
+  int i;
+  long old_set, new_set = 0;
+
+  pcn_data->pcn_remote_io_active = 0;
+  lio_rt_sigprocmask (SIG_BLOCK, (sigset_t *)&new_set,
+		      (sigset_t *)&old_set, sizeof (long));
+  pcn_data->rio_sigmask = old_set;
+
+  for (i = 0; i < PCN_NSIG; i++)
+    {
+      if (pcn_data->rio_sa_sigs[i].pcn_sa_handler != NULL)
+	{
+	  struct sigaction dfl;
+
+	  rio_dbg_printf ("%s: removing signal '%d'\n", __FUNCTION__, i+1);
+
+	  sigemptyset (&dfl.sa_mask);
+          dfl.sa_handler = NULL;
+	  dfl.sa_flags = 0;
+	  sigaction (i+1, &dfl, NULL);
+	}
+    }
+
+  rio_restore (status);
+
+  return status;
+}
+
+int
+pcn_restore_signals (void)
+{
+  int status = rio_disable ();
+  int i;
+
+  for (i = 0; i < PCN_NSIG; i++)
+    {
+      if (PCN_SIGNAL_DEBUG && (i+1 == SIGSEGV || i+1 == SIGILL))
+        {
+	  struct sigaction act;
+
+	  rio_dbg_printf ("%s: restoring signal '%u'\n", __FUNCTION__, i+1);
+
+	  lio_memcpy (&act.sa_mask, &pcn_data->rio_sa_sigs[i].pcn_sa_mask,
+		      sizeof (long));
+	  act.sa_flags = pcn_data->rio_sa_sigs[i].pcn_sa_flags;
+	  act.sa_sigaction = pcn_sigerror;
+	  sigaction (i+1, &act, NULL);
+        }
+      else if (pcn_data->rio_sa_sigs[i].pcn_sa_handler != NULL
+          && i+1 != GLIBC_SIG_1 && i+1 != GLIBC_SIG_2)
+	{
+	  struct sigaction act;
+
+	  rio_dbg_printf ("%s: restoring signal '%u'\n", __FUNCTION__, i+1);
+
+	  lio_memcpy (&act.sa_mask, &pcn_data->rio_sa_sigs[i].pcn_sa_mask,
+		      sizeof (long));
+	  act.sa_flags = pcn_data->rio_sa_sigs[i].pcn_sa_flags;
+	  act.sa_handler = (void (*)(int)) pcn_data->rio_sa_sigs[i].pcn_sa_handler;
+	  sigaction (i+1, &act, NULL);
+	}
+    }
+
+  lio_rt_sigprocmask (SIG_SETMASK, (sigset_t *)&pcn_data->rio_sigmask,
+		      NULL, sizeof (long));
+
+  rio_restore (status);
+
+  return status;
+}
+
+static void
+handle_pcn_sig_rio (int signo)
+{
+  LIO_ASSERT (signo == PCN_SIG_RIO, "unrecognized signal");
+  return;
+}
+
+void
+pcn_sig_rio_init (void)
+{
+  sigset_t signal_mask;
+  struct sigaction act;
+
+  sigemptyset (&signal_mask);
+  sigaddset (&signal_mask, PCN_SIG_RIO);
+  lio_rt_sigprocmask (SIG_UNBLOCK, &signal_mask, NULL, sizeof (long));
+
+  act.sa_flags = 0;
+  act.sa_handler = handle_pcn_sig_rio;
+  sigaction (PCN_SIG_RIO, &act, NULL);
+}
diff --git a/remote_io/pcn_sys_accept.c b/remote_io/pcn_sys_accept.c
new file mode 100644
index 0000000000..9c9d2e24e3
--- /dev/null
+++ b/remote_io/pcn_sys_accept.c
@@ -0,0 +1,68 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_accept (int sockfd, void *addr, socklen_t *addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_bind msg;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_accept_raw (sockfd, addr, (socklen_t *)addrlen);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_ACCEPT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg) + *addrlen;
+  hdr.msg_errno = errno;
+
+  msg.sockfd = sockfd;
+  msg.addrlen = *addrlen;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = addr;
+  payload[1].iov_len = *addrlen;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+  if (res < sizeof (hdr) + hdr.msg_size)
+    lio_error ("%s: failed to send request\n", __FUNCTION__);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &msg, sizeof (msg));
+  LIO_ASSERT (res == sizeof (msg), "corrupted response from server");
+  
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, addr, *addrlen);
+  LIO_ASSERT (res == *addrlen, "corrupted response from server");
+
+  errno = msg.rio_errno;
+
+  if (msg.sockfd < 0)
+    errno = msg.rio_errno;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, sockfd, addr, *addrlen, msg.sockfd, msg.addrlen);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  *addrlen = msg.addrlen;
+
+  return msg.sockfd;
+}
diff --git a/remote_io/pcn_sys_access.c b/remote_io/pcn_sys_access.c
new file mode 100644
index 0000000000..e6413713ee
--- /dev/null
+++ b/remote_io/pcn_sys_access.c
@@ -0,0 +1,53 @@
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_access(const char *pathname, int mode)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  struct pcn_msg_open msg;
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_access (pathname, mode);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.flags = 0;
+  msg.mode = mode;
+  msg.dirfd = 0;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  payload[1].iov_base = (void *)pathname;
+  payload[1].iov_len = strlen (pathname) + 1;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_ACCESS;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + strlen (pathname) + 1;
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: pathname = %s, mode = %x -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, pathname, msg.mode, res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_bind.c b/remote_io/pcn_sys_bind.c
new file mode 100644
index 0000000000..2d6057e77a
--- /dev/null
+++ b/remote_io/pcn_sys_bind.c
@@ -0,0 +1,53 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_bind (int sockfd, const void *addr, int addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_bind msg;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_bind_raw (sockfd, addr, addrlen);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_BIND;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + addrlen;
+  hdr.msg_errno = errno;
+
+  msg.sockfd = sockfd;
+  msg.addrlen = addrlen;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)addr;
+  payload[1].iov_len = addrlen;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u\n",
+		  __FUNCTION__, mid, sockfd, addr, addrlen, res);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_chdir.c b/remote_io/pcn_sys_chdir.c
new file mode 100644
index 0000000000..99ecc04a85
--- /dev/null
+++ b/remote_io/pcn_sys_chdir.c
@@ -0,0 +1,29 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "rio_common_dir.h"
+
+int
+pcn_chdir (const char *path)
+{
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_chdir (path);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  res = pcn_common_dir (PCN_SYS_CHDIR, &mid, path);
+
+  rio_dbg_printf ("%s[%u]: path = %s -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, path, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_chmod.c b/remote_io/pcn_sys_chmod.c
new file mode 100644
index 0000000000..51fdf07692
--- /dev/null
+++ b/remote_io/pcn_sys_chmod.c
@@ -0,0 +1,53 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_chmod (const char *file, mode_t mode)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_res ack;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_chmod (file, mode);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_CHMOD;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (mode) + strlen (file) + 1;
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &mode;
+  payload[0].iov_len = sizeof (mode);
+  payload[1].iov_base = (void *)file;
+  payload[1].iov_len = strlen (file) + 1;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+  if (res != sizeof (hdr) + hdr.msg_size)
+    lio_error ("%s: failed to send request\n", __FUNCTION__);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &ack, sizeof (ack));
+  LIO_ASSERT (res == sizeof (ack), "corrupted response from server");
+
+  errno = ack.rio_errno;
+
+  rio_dbg_printf ("%s[%u]: file = %s, mode = %x -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, file, mode, ack.res, ack.rio_errno);
+
+  rio_enable_signals ();
+
+  return ack.res;
+}
diff --git a/remote_io/pcn_sys_close.c b/remote_io/pcn_sys_close.c
new file mode 100644
index 0000000000..7d19f1483a
--- /dev/null
+++ b/remote_io/pcn_sys_close.c
@@ -0,0 +1,65 @@
+/* pcn_open needs to be seperated from rio_open because rtld uses
+   libc_pic.so when linking to establish a map file containing all of
+   the libc dependencies. This is complicated because both rtld and
+   libc use the same open64.c function to implement open64, but we
+   don't want rtld to use pcn_open because the RIO server may not be
+   setup yet. Hence, rio_open needs to be separated from pcn_openat so
+   that it may use malloc, free, and rio_dbg_printf.  */
+
+#include <sysdep-cancel.h>
+
+#include <errno.h>
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+// TODO: update to close any file descriptors locally if they used by mmap
+int
+pcn_close (int fd)
+{
+  struct pcn_msg_io_close msg;
+  int res, mid;
+  struct fdinfo *fdp;
+
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_close (fd);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.close.fd = fd;
+
+  msg.hdr.msg_type = PCN_TYPE_SYSCALL;
+  msg.hdr.msg_kind = PCN_SYS_CLOSE;
+  msg.hdr.msg_id = mid;
+  msg.hdr.msg_async = PCN_SEND_SYNC;
+  msg.hdr.msg_size = sizeof (msg);
+  msg.hdr.msg_errno = errno;
+
+  //rio_dbg_printf ("%s[%u]: closing file descriptor %u\n",
+  //		  __FUNCTION__, mid, fd);
+
+  //rio_dbg_printf ("%s[%u]: sending %u bytes\n", __FUNCTION__, mid, msg.hdr.msg_size);
+  res = rio_msg_send (pcn_data->pcn_server_sockfd, (struct pcn_msg_hdr *)&msg);
+  if (res < 0)
+    lio_error ("%s[%u]: failed to send close request. res = %u\n",
+	       __FUNCTION__, mid, res);
+
+  rio_dbg_printf ("%s[%u]: closed file descriptor %u -- res = %d\n",
+		  __FUNCTION__, mid, fd, res);
+
+  if ((fdp = rio_fd_find (fd)) != NULL)
+    {
+      lio_close (fd);
+      rio_fd_rm (fdp);
+    }
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_connect.c b/remote_io/pcn_sys_connect.c
new file mode 100644
index 0000000000..f819eca493
--- /dev/null
+++ b/remote_io/pcn_sys_connect.c
@@ -0,0 +1,53 @@
+#include <string.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_connect (int sockfd, const void *addr, int addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_bind msg;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_connect (sockfd, addr, addrlen);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_CONNECT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + addrlen;
+  hdr.msg_errno = errno;
+
+  msg.sockfd = sockfd;
+  msg.addrlen = addrlen;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)addr;
+  payload[1].iov_len = addrlen;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, sockfd, addr, addrlen, res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_dup.c b/remote_io/pcn_sys_dup.c
new file mode 100644
index 0000000000..33c7b689ec
--- /dev/null
+++ b/remote_io/pcn_sys_dup.c
@@ -0,0 +1,127 @@
+#include <string.h>
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_dup (int fd)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[1];
+  int mid, res;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_dup (fd);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_DUP;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (int);
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &fd;
+  payload[0].iov_len = sizeof (int);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %u -- res = %d\n",
+		  __FUNCTION__, mid, fd, res);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_dup2 (int oldfd, int newfd)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  int mid, res;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_dup2 (oldfd, newfd);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_DUP2;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (int);
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &oldfd;
+  payload[0].iov_len = sizeof (int);
+  payload[1].iov_base = &newfd;
+  payload[1].iov_len = sizeof (int);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: oldfd = %d, newfd = %d -- res = %d\n",
+		  __FUNCTION__, mid, oldfd, newfd, res);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_dup3 (int oldfd, int newfd, int flags)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[3];
+  int mid, res;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_dup3 (oldfd, newfd, flags);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_DUP3;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (int);
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &oldfd;
+  payload[0].iov_len = sizeof (int);
+  payload[1].iov_base = &newfd;
+  payload[1].iov_len = sizeof (int);
+  payload[2].iov_base = &flags;
+  payload[2].iov_len = sizeof (int);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 3);
+
+  rio_dbg_printf ("%s[%u]: oldfd = %d, newfd = %d, flags = %d -- res = %d\n",
+		  __FUNCTION__, mid, oldfd, newfd, flags, res);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_epoll.c b/remote_io/pcn_sys_epoll.c
new file mode 100644
index 0000000000..b224aa59b6
--- /dev/null
+++ b/remote_io/pcn_sys_epoll.c
@@ -0,0 +1,195 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/epoll.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+pcn_epoll_create (int size)
+{
+  struct pcn_msg_hdr hdr;
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_epoll_create1 (size);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_EPOLL_CREATE;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (hdr);
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send (pcn_data->pcn_server_sockfd, &hdr);
+
+  rio_dbg_printf ("%s[%u]: size = %d -- res = %d\n",
+                  __FUNCTION__, mid, size, res);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_epoll_ctl (int ver, int epfd, int op, int fd, struct epoll_event *event)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_epoll msg;
+  struct iovec payload[2];
+  ssize_t res;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return __do_epoll_ctl (ver, epfd, op, fd, event);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = event;
+  payload[1].iov_len = sizeof (struct epoll_event);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_EPOLL_CTL;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (struct pcn_msg_epoll) + sizeof (struct epoll_event);
+  hdr.msg_errno = errno;
+
+  msg.ver = ver;
+  msg.epfd = epfd;
+  msg.arg1 = op;
+  msg.arg2 = fd;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  rio_dbg_printf ("%s[%u]: epfd = %d, op = %x, fd = %d, event = %lx -- res = %ld\n",
+		  __FUNCTION__, mid, epfd, op, fd, event, res);
+
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_epoll_wait (int ver, int epfd, struct epoll_event *events, int maxevents,
+		int timeout)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_epoll msg;
+  struct iovec payload[1];
+  ssize_t revents;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return __do_epoll_wait (ver, epfd, events, maxevents, timeout);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_EPOLL_WAIT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (struct pcn_msg_epoll);
+  hdr.msg_errno = errno;
+
+  msg.ver = ver;
+  msg.epfd = epfd;
+  msg.arg1 = maxevents;
+  msg.arg2 = timeout;
+
+  revents = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (revents > 0)
+    rio_msg_get (pcn_data->pcn_server_sockfd, events,
+		 revents * sizeof (struct epoll_event));
+
+  rio_dbg_printf ("%s[%u]: epfd = %d, events = %lx, maxevents = %d, timeout = %d -- res = %ld, errno = %d\n",
+		  __FUNCTION__, mid, epfd, events, maxevents,
+		  timeout, revents, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return revents;
+}
+
+int
+pcn_epoll_pwait (int ver, int epfd, struct epoll_event *events,
+		int maxevents, int timeout, const sigset_t *sigmask)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_epoll_pwait msg;
+  struct iovec payload[1];
+  ssize_t revents;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return __do_epoll_wait (ver, epfd, events, maxevents, timeout);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_EPOLL_PWAIT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (struct pcn_msg_epoll_pwait);
+  hdr.msg_errno = errno;
+
+  msg.ver = ver;
+  msg.epfd = epfd;
+  msg.maxevents = maxevents;
+  msg.timeout = timeout;
+
+  if (sigmask == NULL)
+    msg.sigmask = 0;
+  else
+    msg.sigmask = *(long *)sigmask;
+
+  revents = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (revents > 0)
+    rio_msg_get (pcn_data->pcn_server_sockfd, events,
+		 revents * sizeof (struct epoll_event));
+
+  rio_dbg_printf ("%s[%u]: epfd = %d, events = %lx, maxevents = %d, timeout = %d, sigmask = %lx -- res = %ld, errno = %d\n",
+		  __FUNCTION__, mid, epfd, events, maxevents,
+		  timeout, revents, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return revents;
+}
diff --git a/remote_io/pcn_sys_exec.c b/remote_io/pcn_sys_exec.c
new file mode 100644
index 0000000000..a10bf47eeb
--- /dev/null
+++ b/remote_io/pcn_sys_exec.c
@@ -0,0 +1,135 @@
+#include <errno.h>
+#include <stdlib/stdlib.h>
+#include <fcntl.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "rio_common_dir.h"
+
+static int
+getenv_key (const char *name,  char *const env[])
+{
+  size_t len = strlen (name);
+  char *const *ep;
+  uint16_t name_start;
+  int i = 0;
+
+  if (env == NULL || name[0] == '\0')
+    return -1;
+
+  if (name[1] == '\0')
+    {
+      /* The name of the variable consists of only one character.  Therefore
+	 the first two characters of the environment entry are this character
+	 and a '=' character.  */
+#if __BYTE_ORDER == __LITTLE_ENDIAN || !_STRING_ARCH_unaligned
+      name_start = ('=' << 8) | *(const unsigned char *) name;
+#else
+      name_start = '=' | ((*(const unsigned char *) name) << 8);
+#endif
+      for (ep = env, i = 0; *ep != NULL; ++ep, ++i)
+	{
+#if _STRING_ARCH_unaligned
+	  uint16_t ep_start = *(uint16_t *) *ep;
+#else
+	  uint16_t ep_start = (((unsigned char *) *ep)[0]
+			       | (((unsigned char *) *ep)[1] << 8));
+#endif
+	  if (name_start == ep_start)
+	    return i;
+	}
+    }
+  else
+    {
+#if _STRING_ARCH_unaligned
+      name_start = *(const uint16_t *) name;
+#else
+      name_start = (((const unsigned char *) name)[0]
+		    | (((const unsigned char *) name)[1] << 8));
+#endif
+      len -= 2;
+      name += 2;
+
+      for (ep = env, i = 0; *ep != NULL; ++ep, ++i)
+	{
+#if _STRING_ARCH_unaligned
+	  uint16_t ep_start = *(uint16_t *) *ep;
+#else
+	  uint16_t ep_start = (((unsigned char *) *ep)[0]
+			       | (((unsigned char *) *ep)[1] << 8));
+#endif
+
+	  if (name_start == ep_start && !strncmp (*ep + 2, name, len)
+	      && (*ep)[len + 2] == '=')
+	    return i;
+	}
+    }
+
+  return -1;
+}
+
+int
+pcn_execve (const char *path, char *const argv[], char *const envp[])
+{
+  int i, j, total, cnt, port = -1, ip = -1;
+  char **new_envp, rio_port[50], rio_ip[50];
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_execve (path, argv, envp);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  /* Exec'ing a process is essentially the same as a migration, as the
+     exec'ed process needs to connect to an existing server. */
+  rio_disable_signals ();
+  pcn_exec ();
+  rio_enable_signals ();
+
+  rio_dbg_snprintf (rio_port, 50, "PCN_SERVER_PORT=%d",pcn_data->pcn_server_port);
+  rio_dbg_snprintf (rio_ip, 50, "PCN_SERVER_IP=%d", pcn_data->pcn_server_ip);
+
+  for (i = 0, cnt = 0; envp[i] != NULL; i++)
+    {
+      if (port < 0 && getenv_key ("PCN_SERVER_PORT", envp))
+        port = i;
+      else if (ip < 0 && getenv_key ("PCN_SERVER_IP", envp))
+        ip = i;
+      else
+        cnt++;
+    }
+
+  total = i;
+
+  new_envp = lio_malloc (sizeof (char *) * cnt + 3);
+
+  for (i = 0, j = 0; i < total; i++)
+    {
+      if (i == ip || i == port)
+        continue;
+
+      new_envp[j++] = envp[i];
+    }
+
+  new_envp[cnt] = rio_ip;
+  new_envp[cnt+1] = rio_port;
+  new_envp[cnt+2] = NULL;
+
+  if (lio_fcntl (STDIN_FILENO, F_GETFD, NULL) == -1)
+    lio_close (STDIN_FILENO);
+
+  /* Open /dev/zero for reading to populate a dummy stdin for
+     the exec'ed process.  */
+  lio_open ("/dev/zero", O_RDONLY, 0);
+
+#if 0
+  for (i = 0; new_envp[i] != NULL; i++)
+    lio_dbg_printf ("%s: new_envp[%d] = %s\n", __FUNCTION__, i, new_envp[i]);
+
+  lio_dbg_printf ("%s: seen %d of %d environment variables\n", __FUNCTION__, i, cnt + 1);
+#endif
+
+  return lio_execve (path, argv, new_envp);
+}
diff --git a/remote_io/pcn_sys_fallocate.c b/remote_io/pcn_sys_fallocate.c
new file mode 100644
index 0000000000..4a05d4c553
--- /dev/null
+++ b/remote_io/pcn_sys_fallocate.c
@@ -0,0 +1,58 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_fallocate (int fd, int mode, off_t offset, off_t len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_fallocate msg;
+  struct iovec payload[1];
+  ssize_t res;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    return lio_fallocate (fd, mode, offset, len);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.fd = fd;
+  msg.mode = mode;
+  msg.offset = offset;
+  msg.len = len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FALLOCATE;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//_		  FUNCTION__, mid, count, fd, buf);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, mode = %u, offset = %lx, len = %u -- res = %ld\n",
+		  __FUNCTION__, mid, fd, mode, offset, len, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_fcntl.c b/remote_io/pcn_sys_fcntl.c
new file mode 100644
index 0000000000..1f43d283ec
--- /dev/null
+++ b/remote_io/pcn_sys_fcntl.c
@@ -0,0 +1,56 @@
+/* At present, the RIO server only supports F_GETFL, F_SETFL,
+   and F_GETFD.  */
+
+#include <fcntl.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_fcntl (int fd, int cmd, void *arg)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_fcntl msg;
+  struct iovec payload[1];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_fcntl (fd, cmd, arg);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.fd = fd;
+  msg.cmd = cmd;
+  msg.arg = arg;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FCNTL;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, cmd = %x, arg = %lx -- res = %d\n",
+		  __FUNCTION__, mid, fd, cmd, arg, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_fxstatat.c b/remote_io/pcn_sys_fxstatat.c
new file mode 100644
index 0000000000..7cf75093be
--- /dev/null
+++ b/remote_io/pcn_sys_fxstatat.c
@@ -0,0 +1,88 @@
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+ssize_t
+pcn_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_fxstatat msg, rmsg;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return __do_fxstatat (vers, fd, file, st, flag);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+//  rio_dbg_printf ("%s[%u]: sizeof (struct stat) = %u\n",
+//		  __FUNCTION__, mid, sizeof (struct stat));
+
+  mid = rio_msg_id ();
+
+  msg.fd = fd;
+  msg.flag = flag;
+  msg.size = sizeof (msg) + strlen (file) + 1;
+  msg.vers = vers;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)file;
+  payload[1].iov_len = strlen (file) + 1;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FXSTATAT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_ASYNC;
+  hdr.msg_size = msg.size;
+  hdr.msg_errno = errno;
+
+  rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &rmsg, sizeof (rmsg));
+  LIO_ASSERT (res == sizeof (rmsg), "corrupted response from server");
+
+  rio_dbg_printf ("%s[%u]: fd = %u, flag = %x, file = '%s' -> dev = %x, "
+		  "ino = %x, mode = %u, nlink = %x, uid = %x, gid = %x, "
+		  "rdev = %x, size = %u, blksize = %x, blocks = %u, "
+                  "res = %d, errno = %d\n",
+		  __FUNCTION__, mid, fd, flag, file,
+		  rmsg.st_dev, rmsg.st_ino, rmsg.st_mode,
+		  rmsg.st_nlink, rmsg.st_uid, rmsg.st_gid,
+		  rmsg.st_rdev, rmsg.st_size,
+		  rmsg.st_blksize, rmsg.st_blocks, rmsg.flag, rmsg.fd);
+
+  errno = rmsg.fd;
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  st->st_dev = rmsg.st_dev;
+  st->st_ino = rmsg.st_ino;
+  st->st_mode = rmsg.st_mode;
+  st->st_nlink = rmsg.st_nlink;
+  st->st_uid = rmsg.st_uid;
+  st->st_gid = rmsg.st_gid;
+  st->st_rdev = rmsg.st_dev;
+  st->st_size = rmsg.st_size;
+  st->st_blksize = rmsg.st_blksize;
+  st->st_blocks = rmsg.st_blocks;
+  st->st_atim = rmsg.st_atim;
+  st->st_mtim = rmsg.st_mtim;
+  st->st_ctim = rmsg.st_ctim;
+
+//  rio_dbg_printf ("%s[%u]: res = %u, filesize = %u\n",
+//		  __FUNCTION__, mid, res, st->st_size);
+
+  return rmsg.flag;
+}
diff --git a/remote_io/pcn_sys_getcwd.c b/remote_io/pcn_sys_getcwd.c
new file mode 100644
index 0000000000..b2df8ea1c2
--- /dev/null
+++ b/remote_io/pcn_sys_getcwd.c
@@ -0,0 +1,58 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_getcwd (char *buf, size_t size)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_read msg;
+  ssize_t res;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_getcwd (buf, size);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_GETCWD;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = size;
+  hdr.msg_errno = errno;
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//_		  FUNCTION__, mid, count, fd, buf);
+
+  res = rio_msg_send_raw (pcn_data->pcn_server_sockfd, &hdr, sizeof (hdr));
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &msg, sizeof (msg));
+
+  if (res <= 0)
+    {
+      rio_dbg_printf ("%s[%u]: res = %x\n", __FUNCTION__, mid, res);
+      return res;
+    }
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, buf, msg.cnt);
+
+  rio_dbg_printf ("%s[%u]: cwd = %s\n",__FUNCTION__, mid, buf);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_getdents.c b/remote_io/pcn_sys_getdents.c
new file mode 100644
index 0000000000..f8c7213320
--- /dev/null
+++ b/remote_io/pcn_sys_getdents.c
@@ -0,0 +1,58 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_getdents64 (int fd, void *buf, size_t nbytes)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_getdents msg;
+  struct pcn_msg_res ack;
+  struct iovec payload[1];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_getdents64 (fd, buf, nbytes);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_GETDENTS64;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.fd = fd;
+  msg.nbytes = nbytes;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+  if (res != sizeof (hdr) + hdr.msg_size)
+    lio_error ("%s: failed to send request\n", __FUNCTION__);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &ack, sizeof (ack));
+  LIO_ASSERT (res == sizeof (ack), "corrupted response from server");
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, buf, nbytes);
+  LIO_ASSERT (res == nbytes, "corrupted response from server");
+
+  errno = ack.rio_errno;
+
+  rio_dbg_printf ("%s[%u]: fd = %d, buf = %lx, nbytes = %d -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, fd, buf, nbytes, ack.res, ack.rio_errno);
+
+  rio_enable_signals ();
+
+  return ack.res;
+}
diff --git a/remote_io/pcn_sys_getitimer.c b/remote_io/pcn_sys_getitimer.c
new file mode 100644
index 0000000000..87887c0fb6
--- /dev/null
+++ b/remote_io/pcn_sys_getitimer.c
@@ -0,0 +1,53 @@
+#include <errno.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_getitimer (int which, struct itimerval *value)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[1];
+  int res, mid, t;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_getitimer (which, value);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_GETITIMER;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (int);
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &which;
+  payload[0].iov_len = sizeof (int);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  t = rio_msg_get (pcn_data->pcn_server_sockfd, value,
+                   sizeof (struct itimerval));
+  if (t < sizeof (struct itimerval))
+    lio_error ("%s: failed to receive struct itimerval old\n",
+               __FUNCTION__);
+
+  rio_dbg_printf ("%s[%u]: which = %d, value = { [%ld, %ld], [%ld, %ld] } -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, which, value->it_interval.tv_sec,
+                  value->it_interval.tv_usec, value->it_value.tv_sec,
+                  value->it_value.tv_usec, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_kill.c b/remote_io/pcn_sys_kill.c
new file mode 100644
index 0000000000..3340ba0693
--- /dev/null
+++ b/remote_io/pcn_sys_kill.c
@@ -0,0 +1,52 @@
+#include <errno.h>
+#include <signal.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+#define KERNEL_NSIG 64
+
+int
+pcn_kill (pid_t pid, int sig)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_signal msg;
+  struct iovec payload;
+  int res, mid;
+
+  /* Check if the server is down.  */
+  //if (!pcn_data->pcn_remote_io_active)
+    return lio_kill (pid, sig);
+
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_KILL;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.pid = pid;
+  msg.sig = sig;
+  msg.type = 0;
+  
+  payload.iov_base = &msg;
+  payload.iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, &payload, 1);
+
+  rio_dbg_printf ("%s: pid = %d, sig = %d -- res = %u, errno = %u\n",
+		  __FUNCTION__, pid, sig, res, errno);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_link.c b/remote_io/pcn_sys_link.c
new file mode 100644
index 0000000000..f9d7ac49c8
--- /dev/null
+++ b/remote_io/pcn_sys_link.c
@@ -0,0 +1,147 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+#include "rio_common_dir.h"
+
+int
+pcn_link (const char *from, const char *to)
+{
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_link (from, to);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  res = pcn_common_dir_path2 (PCN_SYS_LINK, &mid, from, to);
+
+  rio_dbg_printf ("%s[%u]: from = %s, to = %s -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, from, to, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_unlink (const char *name)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[1];
+  int res, mid;
+  int l_name;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_unlink (name);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  l_name = lio_strlen (name) + 1;
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_UNLINK;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = l_name;
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = (void *)name;
+  payload[0].iov_len = l_name;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: name = %s -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, name, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_symlink (const char *from, const char *to)
+{
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_symlink (from, to);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  res = pcn_common_dir_path2 (PCN_SYS_SYMLINK, &mid, from, to);
+
+  rio_dbg_printf ("%s[%u]: from = %s, to = %s -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, from, to, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
+
+ssize_t
+pcn_readlink (const char *path, char *buf, size_t len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_readlink msg;
+  struct iovec payload[2];
+  int res, mid, t;
+  int l_path;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_readlink (path, buf, len);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  l_path = lio_strlen (path) + 1;
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_READLINK;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + l_path;
+  hdr.msg_errno = errno;
+
+  msg.path_len = l_path;
+  msg.bufsz = len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)path;
+  payload[1].iov_len = l_path;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+  if (res == -1)
+    {
+      rio_dbg_printf ("%s[%u]: path = %s, len = %d -- res = %d, errno = %d\n",
+                      __FUNCTION__, mid, path, len, res, errno);
+      rio_enable_signals ();
+      return res;
+    }
+
+  t = rio_msg_get (pcn_data->pcn_server_sockfd, buf, res);
+  if (t != res)
+    lio_error ("%s: failed to receive PATH from server\n", __FUNCTION__);
+
+  rio_dbg_printf ("%s[%u]: path = %s, len = %d -- res = %d, buf = %s, errno = %d\n",
+                  __FUNCTION__, mid, path, len, res, buf, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_listen.c b/remote_io/pcn_sys_listen.c
new file mode 100644
index 0000000000..e48d50ec62
--- /dev/null
+++ b/remote_io/pcn_sys_listen.c
@@ -0,0 +1,54 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_listen (int sockfd, int backlog)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_listen msg;
+  struct iovec payload[1];
+  int res;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_listen (sockfd, backlog);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_LISTEN;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.sockfd = sockfd;
+  msg.backlog = backlog;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, backlog = %u -- res = %d\n",
+		  __FUNCTION__, mid, sockfd, backlog, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_lseek.c b/remote_io/pcn_sys_lseek.c
new file mode 100644
index 0000000000..3b0d2a06d3
--- /dev/null
+++ b/remote_io/pcn_sys_lseek.c
@@ -0,0 +1,49 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "rio_common_dir.h"
+
+off_t
+pcn_lseek64 (int fd, off_t offset, int whence)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_lseek msg;
+  struct iovec payload[1];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_lseek64 (fd, offset, whence);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_LSEEK;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.fd = fd;
+  msg.offset = offset;
+  msg.whence = whence;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %d, offset = %ld, whence = %d -- res = %d, errno = %u\n",
+		  __FUNCTION__, mid, fd, offset, whence, res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_mkdir.c b/remote_io/pcn_sys_mkdir.c
new file mode 100644
index 0000000000..d0bc22e16b
--- /dev/null
+++ b/remote_io/pcn_sys_mkdir.c
@@ -0,0 +1,50 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_mkdir (const char *path, mode_t mode)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_mkdir msg;
+  struct iovec payload[2];
+  int res, mid;
+  int l_path;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_mkdir (path, mode);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  l_path = lio_strlen (path) + 1;
+  msg.mode = mode;
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_MKDIR;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + l_path;
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)path;
+  payload[1].iov_len = l_path;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: path = %s, mode = %x -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, path, mode, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_mmap.c b/remote_io/pcn_sys_mmap.c
new file mode 100644
index 0000000000..e1e78f1318
--- /dev/null
+++ b/remote_io/pcn_sys_mmap.c
@@ -0,0 +1,371 @@
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+#define MAX_PCN_MAPS 1024*1024
+
+struct pcn_map {
+  long addr;
+  int len;
+};
+
+static void
+merge (struct pcn_map *maps, int low, int mid, int high)
+{
+  int t = mid + 1;
+
+  if (maps[mid].addr < maps[mid+1].addr)
+    return;
+
+  while (low <= mid && t <= high)
+    {
+      if (maps[low].addr <= maps[t].addr)
+	low++;
+      else
+	{
+	  struct pcn_map val = { maps[t].addr, maps[t].len };
+	  int idx = t;
+
+	  while (idx != low)
+	    {
+	      maps[idx].addr = maps[idx-1].addr;
+	      maps[idx].len = maps[idx-1].len;
+	      idx--;
+	    }
+
+	  maps[low].addr = val.addr;
+	  maps[low].len = val.len;
+
+	  low++;
+	  mid++;
+	  t++;
+	}
+    }
+}
+
+static void
+merge_sort (struct pcn_map *maps, int low, int high)
+{
+  int mid;
+
+  if (low >= high)
+    return;
+
+  mid = (high - low) / 2 + low;
+
+  merge_sort (maps, low, mid);
+  merge_sort (maps, mid + 1, high);
+  merge (maps, low, mid, high);
+}
+
+static void
+pcn_sort_maps (void)
+{
+  struct pcn_map *pcn_active_maps = (struct pcn_map *)pcn_data->rio_active_maps;
+
+  merge_sort (pcn_active_maps, 0, pcn_data->rio_num_maps - 1);
+
+#if 0
+  int i;
+
+  rio_dbg_printf ("%lx", pcn_active_maps[0].addr);
+
+  for (i = 1; i < pcn_num_maps; i++)
+    rio_dbg_printf (", %lx", pcn_active_maps[i].addr);
+
+  rio_dbg_printf ("\n");
+#endif
+}
+
+static int
+pcn_map_add (long addr, int len)
+{
+  struct pcn_map *pcn_active_maps;
+
+  if (pcn_data->rio_num_maps == -1)
+    {
+#if 0
+      rio_dbg_printf ("%s: allocating storage for rio_active_maps\n", __FUNCTION__);
+#endif
+
+      int pages = (sizeof (struct pcn_map) * MAX_PCN_MAPS) / 1024;
+      int sz = pages * 1024;
+      pcn_data->rio_num_maps = 0;
+      pcn_data->rio_active_maps = lio_malloc (sz);
+      if ((long)(pcn_data->rio_active_maps) == -1)
+        lio_error ("failed to allocate rio_active_maps\n");
+    }
+
+  LIO_ASSERT (pcn_data->rio_num_maps <= MAX_PCN_MAPS, "too many active mmaps");
+
+  pcn_active_maps = (struct pcn_map *)pcn_data->rio_active_maps;
+
+  pcn_active_maps[pcn_data->rio_num_maps].addr = addr;
+  pcn_active_maps[pcn_data->rio_num_maps].len = len;
+  pcn_data->rio_num_maps++;
+
+#if 0
+  rio_dbg_printf ("%s: addr = %lx, len = %d\n", __FUNCTION__, addr, len);
+#endif
+
+  pcn_sort_maps ();
+
+  return 0;
+}
+
+static int
+pcn_map_rm (int idx)
+{
+  struct pcn_map *pcn_active_maps = (struct pcn_map *)pcn_data->rio_active_maps;
+
+  pcn_data->rio_num_maps--;
+
+  if (pcn_data->rio_num_maps == 0)
+    return 0;
+
+#if 0
+  rio_dbg_printf ("%s: removing addr %lx\n", __FUNCTION__,
+                  pcn_active_maps[idx].addr);
+#endif
+
+  lio_memcpy (&pcn_active_maps[idx], &pcn_active_maps[pcn_data->rio_num_maps],
+	      sizeof (struct pcn_map));
+
+
+  pcn_sort_maps ();
+
+  return pcn_data->rio_num_maps;
+}
+
+static int
+pcn_map_find (long addr)
+{
+  struct pcn_map *pcn_active_maps = (struct pcn_map *)pcn_data->rio_active_maps;
+  int low = 0;
+  int high = pcn_data->rio_num_maps;
+
+#if 0
+  rio_dbg_printf ("%s: searching for addr = %lx\n", __FUNCTION__, addr);
+#endif
+
+  while (low <= high)
+    {
+      int idx = (high - low) / 2 + low;
+      long mid = pcn_active_maps[idx].addr;
+      if (mid == addr)
+	return idx;
+      else if (mid > addr)
+	high = idx - 1;
+      else
+	low = idx + 1;
+    }
+
+#if 0
+  rio_dbg_printf ("%s: addr = %lx is missing\n", __FUNCTION__, addr);
+#endif
+
+  return -1;
+}
+
+static int
+do_pcn_open_mmap (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_open *omsg = alloca (hdr->msg_size);
+  int newfd, res, flags;
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, omsg, hdr->msg_size);
+  if (res < hdr->msg_size)
+    lio_error ("%s[%u]: failed to recive response from the remote_io server\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+//  rio_dbg_printf ("%s: hdr = { kind = %u, type = %u, id = %u, size = %u }\n",
+//		  __FUNCTION__, hdr->msg_kind, hdr->msg_type, hdr->msg_id,
+//		  hdr->msg_size);
+  rio_dbg_printf ("%s[%u]: res = { dirfd = %d, flags = %u, mode = %u, "
+		  "pathname = %s }\n",
+		  __FUNCTION__, hdr->msg_id, omsg->dirfd, omsg->flags, omsg->mode,
+		  omsg->pathname);
+
+  // Handle the case where the server has to transfer a file over the wire.
+  if (omsg->dirfd < 0)
+    omsg->dirfd = rio_get_file (omsg, pcn_data->pcn_server_sockfd);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  rio_dbg_printf ("%s: mapping '%s', flags = %u\n", __FUNCTION__,
+		  omsg->pathname, omsg->flags);
+
+  flags = omsg->flags & ~(O_CREAT|O_TRUNC);
+
+  newfd = lio_open (omsg->pathname, flags, 0);
+
+  if (newfd != omsg->dirfd)
+    {
+      lio_dup2 (newfd, omsg->dirfd);
+      lio_close (newfd);
+      newfd = omsg->dirfd;
+    }
+
+  return newfd;
+}
+
+void *
+pcn_mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
+{
+  struct pcn_msg_io_mmap msg;
+  struct pcn_msg_hdr hdr, ack;
+  ssize_t res = 0;
+  int newfd = -1;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_mmap (addr, length, prot, flags, fd, offset);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  /* Don't need to disturb the server if this is an anonymous mapping.  */
+  if (flags & MAP_ANONYMOUS || flags & MAP_ANON || rio_fd_find (fd))
+    {
+      addr = lio_mmap (addr, length, prot, flags, fd, offset);
+      pcn_map_add ((long)addr, length);
+      return addr;
+    }
+
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.mmap.addr = addr;
+  msg.mmap.length = length;
+  msg.mmap.prot = prot;
+  msg.mmap.flags = flags;
+  msg.mmap.fd = fd;
+  msg.mmap.offset = offset;
+
+  msg.hdr.msg_type = PCN_TYPE_SYSCALL;
+  msg.hdr.msg_kind = PCN_SYS_MMAP;
+  msg.hdr.msg_id = mid;
+  msg.hdr.msg_async = PCN_SEND_NORET;
+  msg.hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: addr = %lx, len = %lu, prot = %u, flags = %u, "
+		  "fd = %u, offset = %lx\n",
+		  __FUNCTION__, mid, addr, length, prot, flags, fd, offset);
+
+  res = rio_msg_send (pcn_data->pcn_server_sockfd, (struct pcn_msg_hdr *)&msg);
+  if (res < 0)
+    lio_error ("%s[%u]: failed to send request to the remote_io server\n",
+	       __FUNCTION__, mid);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &hdr, sizeof (hdr));
+  if (res < sizeof (hdr))
+    lio_error ("%s[%u]: failed to receive response from server\n",
+	       __FUNCTION__, mid);
+
+  /* Has the file already been opened?   */
+  if (hdr.msg_type == PCN_TYPE_RES && hdr.msg_kind == PCN_SYS_OPEN)
+    newfd = do_pcn_open_mmap (&hdr, fd);
+  else if (hdr.msg_type == PCN_TYPE_CONTROL && hdr.msg_kind == PCN_CTL_ACK)
+    newfd = hdr.msg_size;
+  else
+    lio_error ("%s[%u]: unexpected response from remote i/o server\n",
+	       __FUNCTION__, mid);
+
+  LIO_ASSERT (newfd == fd, "mismatched file descriptors\n");
+
+  msg.mmap.addr = lio_mmap (addr, length, prot, flags, fd, offset);
+
+  res = lio_write (pcn_data->pcn_server_sockfd, &msg.mmap.addr, sizeof (long));
+
+//  int count;
+//  ioctl (pcn_data->pcn_server_sockfd, FIONREAD, &count);
+//  rio_dbg_printf ("%s[%u]: pending message bytes = %u\n", __FUNCTION__, mid, count);
+
+  rio_msg_get (pcn_data->pcn_server_sockfd, &ack, sizeof (ack));
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  // Keep track of the fd to be able close it locally later.
+  if (fd && rio_fd_find (fd) == NULL)
+    rio_fd_open_special (fd, RIO_FD_MMAP);
+
+  rio_enable_signals ();
+
+  return msg.mmap.addr;
+}
+
+/* RTL: Add a munmap wrapper in sysdeps/unix/sysv/linux/munmap.c and
+   call pcn_munmap.  */
+int
+pcn_munmap(void *addr, size_t length)
+{
+  struct pcn_msg_hdr hdr, ack;
+  struct pcn_msg_mmap msg = {0};
+  struct iovec payload[1];
+  ssize_t res = 0;
+  int mid, map;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_munmap (addr, length);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  if ((map = pcn_map_find ((long)addr)) >= 0)
+    {
+      pcn_map_rm (map);
+      return lio_munmap (addr, length);
+    }
+
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.addr = addr;
+  msg.length = length;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_MUNMAP;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: addr = %lx, len = %lu\n",
+		  __FUNCTION__, mid, addr, length);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, PCN_SEND_ASYNC);
+  if (res < 0)
+    lio_error ("%s[%u]: failed to unmap file @ %lx", __FUNCTION__, mid, addr);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &ack, sizeof (hdr));
+  if (res < 0)
+    lio_error ("%s[%u]: failed to unmap file @ %lx", __FUNCTION__, mid, addr);
+
+  if (ack.msg_type == (int)PCN_CTL_SYNC)
+    rio_send_file (&ack);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return lio_munmap (addr, length);
+}
diff --git a/remote_io/pcn_sys_open.c b/remote_io/pcn_sys_open.c
new file mode 100644
index 0000000000..8b52041ddf
--- /dev/null
+++ b/remote_io/pcn_sys_open.c
@@ -0,0 +1,87 @@
+/* pcn_open needs to be seperated from rio_open because rtld uses
+   libc_pic.so when linking to establish a map file containing all of
+   the libc dependencies. This is complicated because both rtld and
+   libc use the same open64.c function to implement open64, but we
+   don't want rtld to use pcn_open because the RIO server may not be
+   setup yet. Hence, rio_open needs to be separated from pcn_openat so
+   that it may use malloc, free, and rio_dbg_printf.  */
+
+#include <sysdep-cancel.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <shm-directory.h>
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_openat(int dirfd, const char *pathname, int flags, mode_t mode)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  struct pcn_msg_open msg;
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_openat (dirfd, pathname, flags, mode);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.flags = flags;
+  msg.mode = mode;
+  msg.dirfd = dirfd;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  payload[1].iov_base = (void *)pathname;
+  payload[1].iov_len = strlen (pathname) + 1;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_OPEN;
+  hdr.msg_id = mid;
+  hdr.msg_async = 0;
+  hdr.msg_size = sizeof (msg) + strlen (pathname) + 1;
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: pathname = %s, flags = %x, mode = %x, dirfd = %x -- res = %d\n",
+		  __FUNCTION__, mid, pathname, msg.flags, msg.mode, msg.dirfd, res);
+
+  if (res >= 0 && lio_strncmp (pathname, pcn_data->pcn_storage_shm,
+                               pcn_data->pcn_storage_shm_len) == 0)
+    {
+      int newfd, old_flags = flags;
+
+      if (!lio_access (pathname, F_OK))
+	flags &= ~(O_CREAT | O_EXCL);
+
+      newfd = lio_openat (dirfd, pathname, flags, mode);
+      if (newfd == -1)
+	lio_error("%s: shm_open openat: newfd = %d, rio = %d, flags = %x:%x\n",
+		  __FUNCTION__, newfd, res, old_flags, flags);
+
+
+      res = lio_dup2 (newfd, res);
+      if (res == -1)
+	lio_error ("%s: shm_open dup2: newfd = %d, rio = %d, flags = %x:%x\n",
+		    __FUNCTION__, newfd, res, old_flags, flags);
+
+      lio_close (newfd);
+
+      rio_fd_open_special (res, RIO_FD_SHM);
+    }
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_pipe.c b/remote_io/pcn_sys_pipe.c
new file mode 100644
index 0000000000..1391590c07
--- /dev/null
+++ b/remote_io/pcn_sys_pipe.c
@@ -0,0 +1,62 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_pipe (int pfds[2], int flags)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_pipe msg;
+  ssize_t res;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_pipe2 (pfds, flags);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_PIPE;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = flags;
+  hdr.msg_errno = errno;
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//_		  FUNCTION__, mid, count, fd, buf);
+
+  res = rio_msg_send_raw (pcn_data->pcn_server_sockfd, &hdr, sizeof (hdr));
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &msg, sizeof (msg));
+
+  if (res < 0 || msg.res)
+    {
+      errno = msg._errno;
+      rio_dbg_printf ("%s[%u]: failed to create pipe - %d / %d\n",
+		      __FUNCTION__, mid, res, msg.res, msg._errno);
+      return msg.res;
+    }
+
+  pfds[0] = msg.pfds[0];
+  pfds[1] = msg.pfds[1];
+
+  rio_dbg_printf ("%s[%u]: flags = %x, pdfs = [%d, %d] -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, flags, pfds[0], pfds[1],
+                  msg.res, errno);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return msg.res;
+}
diff --git a/remote_io/pcn_sys_poll.c b/remote_io/pcn_sys_poll.c
new file mode 100644
index 0000000000..fa75de910f
--- /dev/null
+++ b/remote_io/pcn_sys_poll.c
@@ -0,0 +1,138 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <poll.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static int
+do_pcn_poll (int syscall, int mid, struct pollfd *fds, int nfds,
+	     long tv_sec, long tv_nsec, const sigset_t *sigmask)
+{
+  struct pcn_msg_hdr hdr;
+  static struct pcn_msg_poll *msg = NULL;
+  struct iovec payload[2];
+  sigset_t mask;
+  int res, fdsize, msg_size;
+
+  fdsize = sizeof (struct pollfd) * nfds;
+  msg_size = fdsize + sizeof (struct pcn_msg_poll);
+
+  /* Stackmaps can't cope with alloca, so keep this msg buffer
+     persistent across multiple invocations.  */
+  msg = lio_realloc (msg, msg_size);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = syscall;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = msg_size;
+  hdr.msg_errno = errno;
+
+  msg->nfds = nfds;
+  msg->tv_sec = tv_sec;
+  msg->tv_nsec = tv_nsec;
+
+  if (sigmask == NULL)
+    {
+      sigemptyset (&mask);
+      lio_memcpy (&msg->sigmask, &mask, sizeof (sigset_t));
+    }
+  else
+    msg->sigmask = *sigmask;
+
+  payload[0].iov_base = msg;
+  payload[0].iov_len = sizeof (struct pcn_msg_poll);
+  payload[1].iov_base = fds;
+  payload[1].iov_len = fdsize;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  hdr.msg_type = PCN_TYPE_POLL;
+  hdr.msg_size = sizeof (hdr);
+  rio_poll (&hdr);
+
+  rio_msg_get (pcn_data->pcn_server_sockfd, msg, msg_size);
+
+  lio_memcpy (fds, msg->fds, fdsize);
+
+  res = msg->nfds;
+  errno = msg->tv_sec;
+
+  LIO_LIVE (syscall);
+  LIO_LIVE (mid);
+  LIO_LIVE (nfds);
+  LIO_LIVE (tv_sec);
+  LIO_LIVE (tv_nsec);
+  LIO_LIVE (sigmask);
+
+  return res;
+}
+
+int
+pcn_poll (struct pollfd *fds, int nfds, int timeout)
+{
+  int res, mid;
+  long sec, nsec;
+
+  /* Note the timeout provided to poll is in miliseconds.  */
+  if (timeout == -1)
+    {
+      sec = -1;
+      nsec = 0;
+    }
+  else
+    {
+      sec = timeout / 1000;
+      nsec = (timeout % 1000) * 1000;
+    }
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_poll (fds, nfds, timeout);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  res = do_pcn_poll (PCN_SYS_POLL, mid, fds, nfds, sec, nsec, NULL);
+
+  rio_dbg_printf ("%s[%u]: fds = %lx, nfds = %u, timeout = %d -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, fds, nfds, timeout, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+	   const sigset_t *sigmask)
+{
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_ppoll (fds, nfds, tp, sigmask);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  res = do_pcn_poll (PCN_SYS_PPOLL, mid, fds, nfds, tp == NULL ? -1 : tp->tv_sec,
+		     tp == NULL ? 0 : tp->tv_nsec, NULL);
+
+  rio_dbg_printf ("%s[%u]: fds = %lx, nfds = %u, tp = %x, sigmask = %x -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, fds, nfds, tp, sigmask, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_read.c b/remote_io/pcn_sys_read.c
new file mode 100644
index 0000000000..8f1cfaef76
--- /dev/null
+++ b/remote_io/pcn_sys_read.c
@@ -0,0 +1,111 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+ssize_t
+pcn_read (int fd, void *buf, size_t count)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_read msg;
+  struct iovec payload[1];
+  ssize_t res;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    return lio_read (fd, buf, count);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.fd = fd;
+  msg.cnt = count;
+  msg.offset = -1;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_READ;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//		  FUNCTION__, mid, count, fd, buf);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (res > 0)
+    rio_msg_get (pcn_data->pcn_server_sockfd, buf, res);
+
+  rio_dbg_printf ("%s[%u]: read %u from fd %u into %lx -- res = %ld\n",
+		  __FUNCTION__, mid, count, fd, buf, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+ssize_t
+pcn_pread64 (int fd, void *buf, size_t count, off_t offset)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_read msg;
+  struct iovec payload[1];
+  ssize_t res;
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    return lio_pread (fd, buf, count, offset);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.fd = fd;
+  msg.cnt = count;
+  msg.offset = offset;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_PREAD;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+//  rio_dbg_printf ("%s[%u]: reading %u from fd %u into %lx\n",
+//		  FUNCTION__, mid, count, fd, buf);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (res > 0)
+    rio_msg_get (pcn_data->pcn_server_sockfd, buf, res);
+
+  rio_dbg_printf ("%s[%u]: pread %u from fd %u at offset %lx into %lx -- res = %ld\n",
+		  __FUNCTION__, mid, count, fd, offset, buf, res);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_recv.c b/remote_io/pcn_sys_recv.c
new file mode 100644
index 0000000000..ac7b767b26
--- /dev/null
+++ b/remote_io/pcn_sys_recv.c
@@ -0,0 +1,163 @@
+/* At present, recvfrom only support AF_INET and AF_INET6.  */
+
+#include <sys/socket.h>
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+ssize_t
+pcn_recvfrom (int sockfd, void *restrict buf, size_t len, int flags,
+              struct sockaddr *restrict src_addr, socklen_t *addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_recvfrom msg;
+  struct iovec payload[1];
+  int mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_recvfrom (sockfd, buf, len, flags, src_addr, addrlen);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.sockfd = sockfd;
+  msg.len = len;
+  msg.flags = flags;
+  msg.addrlen = addrlen == NULL ? 0 : *addrlen;
+  msg.rio_errno = 0;
+
+  if (src_addr == NULL)
+    memset (&msg.src_addr, 0, sizeof (struct sockaddr_storage));
+  else
+    memcpy (&msg.src_addr, src_addr, *addrlen);
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_RECVFROM;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+  rio_msg_get (pcn_data->pcn_server_sockfd, &msg, sizeof (msg));
+
+  if (msg.len > 0)
+    rio_msg_get (pcn_data->pcn_server_sockfd, buf, msg.len);
+  else if (msg.len < 0)
+    errno = msg.rio_errno;
+
+  if (src_addr != NULL)
+    {
+      memcpy (src_addr, &msg.src_addr, msg.addrlen);
+      memcpy (addrlen, &msg.addrlen, sizeof (socklen_t));
+    }
+
+  rio_dbg_printf ("%s[%u]: received %ld bytes from fd %u into %lx -- addrlen = %ld, errno = %d\n",
+		  __FUNCTION__, mid, msg.len, sockfd, buf, msg.addrlen,
+                  msg.rio_errno);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return msg.len;
+}
+
+ssize_t
+pcn_recvmsg (int sockfd, struct msghdr *rmsg, int flags)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_recvmsg msg;
+  struct iovec payload[2];
+  int i, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_recvmsg (sockfd, rmsg, flags);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.sockfd = sockfd;
+  msg.flags = flags;
+  msg.msg_namelen = rmsg->msg_namelen;
+  msg.msg_iovsize = 0;
+  msg.msg_controllen = rmsg->msg_controllen;
+  msg.msg_flags = rmsg->msg_flags;
+  msg.rio_errno = 0;
+
+  for (i = 0; i < rmsg->msg_iovlen; i++)
+    msg.msg_iovsize += rmsg->msg_iov[i].iov_len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = &rmsg->msg_control;
+  payload[1].iov_len = rmsg->msg_controllen;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_RECVMSG;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+  rio_msg_get (pcn_data->pcn_server_sockfd, &msg, sizeof (msg));
+
+  if (msg.msg_controllen > 0)
+    rio_msg_get (pcn_data->pcn_server_sockfd, rmsg->msg_control,
+                 msg.msg_controllen);
+
+  if (msg.msg_iovsize > 0)
+    {
+      char *buf = alloca (msg.msg_iovsize);
+      int size = msg.msg_iovsize;
+
+      rio_msg_get (pcn_data->pcn_server_sockfd, buf, msg.msg_iovsize);
+
+      for (i = 0; i < rmsg->msg_iovlen && size > 0; i++)
+        {
+          int t = rmsg->msg_iov[i].iov_len;
+
+          memcpy (rmsg->msg_iov[i].iov_base, buf, MIN(size, t));
+
+          buf += MIN(size, t);
+          size -= MIN(size, t);
+        }
+    }
+  else if (msg.msg_iovsize < 0)
+    errno = msg.rio_errno;
+
+  if (rmsg->msg_namelen > 0)
+    memcpy (rmsg->msg_name, &msg.msg_name, rmsg->msg_namelen);
+
+  rio_dbg_printf ("%s[%u]: received %ld bytes from fd %u, "
+                  "flags = %x, msg_flags = %x -- msg_controllen = %d, errno = %d\n",
+		  __FUNCTION__, mid, msg.msg_iovsize, sockfd,
+                  flags, rmsg->msg_flags, msg.msg_controllen, msg.rio_errno);
+
+  if (msg.msg_iovsize <= 0)
+    errno = msg.rio_errno;
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return (ssize_t) msg.msg_iovsize;
+}
diff --git a/remote_io/pcn_sys_rename.c b/remote_io/pcn_sys_rename.c
new file mode 100644
index 0000000000..2f3ac0ea58
--- /dev/null
+++ b/remote_io/pcn_sys_rename.c
@@ -0,0 +1,30 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+#include "rio_common_dir.h"
+
+int
+pcn_rename (const char *from, const char *to)
+{
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_link (from, to);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  res = pcn_common_dir_path2 (PCN_SYS_RENAME, &mid, from, to);
+
+  rio_dbg_printf ("%s[%u]: from = %s, to = %s -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, from, to, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_rmdir.c b/remote_io/pcn_sys_rmdir.c
new file mode 100644
index 0000000000..2f59f414a9
--- /dev/null
+++ b/remote_io/pcn_sys_rmdir.c
@@ -0,0 +1,29 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "rio_common_dir.h"
+
+int
+pcn_rmdir (const char *path)
+{
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_rmdir (path);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  res = pcn_common_dir (PCN_SYS_RMDIR, &mid, path);
+
+  rio_dbg_printf ("%s[%u]: path = %s -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, path, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_select.c b/remote_io/pcn_sys_select.c
new file mode 100644
index 0000000000..48c4387c71
--- /dev/null
+++ b/remote_io/pcn_sys_select.c
@@ -0,0 +1,184 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+static unsigned char
+populate_args (void *r, void *w, void *e,
+	       void *ir, void *iw, void *ie)
+{
+  unsigned char args = 0;
+
+  if (ir != NULL)
+    {
+      memcpy (r, ir, sizeof (fd_set));
+      set_arg (args, 1);
+    }
+
+  if (iw != NULL)
+    {
+      memcpy (w, iw, sizeof (fd_set));
+      set_arg (args, 2);
+    }
+
+  if (ie != NULL)
+    {
+      memcpy (e, ie, sizeof (fd_set));
+      set_arg (args, 3);
+    }
+
+  return args;
+}
+
+static void
+collect_args (void *r, void *w, void *e, struct pcn_msg_select_res *msg)
+{
+  if (r != NULL)
+    memcpy (r, &msg->readfds, sizeof (fd_set));
+
+  if (w != NULL)
+    memcpy (w, &msg->writefds, sizeof (fd_set));
+
+  if (e != NULL)
+    memcpy (e, &msg->exceptfds, sizeof (fd_set));
+}
+
+int
+pcn_pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	     const struct timespec *timeout, const sigset_t *sigmask)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_pselect msg;
+  struct pcn_msg_select_res rmsg;
+  struct iovec payload;
+  int res, mid;
+  unsigned char args = 0;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_pselect (nfds, readfds, writefds, exceptfds, timeout, sigmask);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_PSELECT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.nfds = nfds;
+
+  args = populate_args (&msg.readfds, &msg.writefds, &msg.exceptfds,
+			readfds, writefds, exceptfds);
+
+  if (timeout != NULL)
+    {
+      memcpy (&msg.ts, timeout, sizeof (struct timespec));
+      set_arg (args, 4);
+    }
+
+  if (sigmask != NULL)
+    {
+      memcpy (&msg.sigmask, sigmask, sizeof (long));
+      set_arg (args, 5);
+    }
+
+  msg.args = args;
+
+  payload.iov_base = &msg;
+  payload.iov_len = sizeof (msg);
+
+  rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, &payload, 1);
+
+  rio_msg_get (pcn_data->pcn_server_sockfd, &rmsg, sizeof (rmsg));
+
+  res = rmsg.res;
+
+  if (res < 0)
+    errno = rmsg.rio_errno;
+
+  collect_args (readfds, writefds, exceptfds, &rmsg);
+
+  rio_dbg_printf ("%s[%u]: nfds = %d, readfds = %ls, writefds = %lx execpfds = %lx, timeout = %lx, sigmask = %lx -- res = %u\n",
+		  __FUNCTION__, mid, nfds, readfds, writefds,
+		  exceptfds, sigmask, res);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_select (int nfds, fd_set *readfds, fd_set *writefds,
+	    fd_set *exceptfds, struct timeval *timeout)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_select msg;
+  struct pcn_msg_select_res rmsg;
+  struct iovec payload;
+  int res, mid;
+  unsigned char args = 0;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_select (nfds, readfds, writefds, exceptfds, timeout);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SELECT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.nfds = nfds;
+
+  args = populate_args (&msg.readfds, &msg.writefds, &msg.exceptfds,
+			readfds, writefds, exceptfds);
+
+  if (timeout != NULL)
+    {
+      memcpy (&msg.tv, timeout, sizeof (struct timeval));
+      set_arg (args, 4);
+    }
+
+  msg.args = args;
+
+  payload.iov_base = &msg;
+  payload.iov_len = sizeof (msg);
+
+  rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, &payload, 1);
+
+  rio_msg_get (pcn_data->pcn_server_sockfd, &rmsg, sizeof (rmsg));
+
+  res = rmsg.res;
+
+  if (res < 0)
+    errno = rmsg.rio_errno;
+
+  collect_args (readfds, writefds, exceptfds, &rmsg);
+
+  rio_dbg_printf ("%s[%u]: nfds = %d, readfds = %ls, writefds = %lx execpfds = %lx, timeout = %lx -- res = %u\n",
+		  __FUNCTION__, mid, nfds, readfds, writefds,
+		  exceptfds, res);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_send.c b/remote_io/pcn_sys_send.c
new file mode 100644
index 0000000000..cd7c8f8da8
--- /dev/null
+++ b/remote_io/pcn_sys_send.c
@@ -0,0 +1,104 @@
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+ssize_t
+pcn_send (int fd, const void *buf, size_t count, int flags)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  struct pcn_msg_send msg;
+  ssize_t res;
+  int mid;
+
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_send (fd, buf, count, flags);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.sockfd = fd;
+  msg.len = count;
+  msg.flags = flags;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  payload[1].iov_base = (void *)buf;
+  payload[1].iov_len = count;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SEND;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + count;
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, count = %d, flags = %d -- res = %ld, errno = %d\n",
+		  __FUNCTION__, mid, fd, count, flags, res, errno);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+ssize_t
+pcn_sendto (int fd, const void *buf, size_t count, int flags,
+                    const struct sockaddr *dest_addr, socklen_t addrlen)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  struct pcn_msg_sendto msg;
+  ssize_t res;
+  int mid;
+
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_sendto (fd, buf, count, flags, dest_addr, addrlen);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  mid = rio_msg_id ();
+
+  msg.sockfd = fd;
+  msg.len = count;
+  msg.flags = flags;
+  msg.addrlen = addrlen;
+
+  if (addrlen == 0)
+    memset (&msg.dest_addr, 0, sizeof (struct sockaddr_storage));
+  else
+    memcpy (&msg.dest_addr, dest_addr, addrlen);
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  payload[1].iov_base = (void *)buf;
+  payload[1].iov_len = count;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SENDTO;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + count;
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, count = %d, flags = %d, addrlen = %d -- res = %ld, errno = %d\n",
+		  __FUNCTION__, mid, fd, count, flags, addrlen,
+                  res, errno);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_setitimer.c b/remote_io/pcn_sys_setitimer.c
new file mode 100644
index 0000000000..7622245831
--- /dev/null
+++ b/remote_io/pcn_sys_setitimer.c
@@ -0,0 +1,67 @@
+#include <errno.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_setitimer (int which, const struct itimerval *new,
+	       struct itimerval *old)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_setitimer msg;
+  struct iovec payload[1];
+  int res, mid, t;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_setitimer (which, new, old);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SETITIMER;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.which = which;
+  msg.null_args = 0;
+
+  if (new == NULL)
+    set_arg (msg.null_args, 1);
+  else
+    memcpy (&msg.new, new, sizeof (struct itimerval));
+
+  if (old == NULL)
+    set_arg (msg.null_args, 2);
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (old != NULL)
+    {
+      t = rio_msg_get (pcn_data->pcn_server_sockfd, old,
+                       sizeof (struct itimerval));
+      if (t < sizeof (struct itimerval))
+        lio_error ("%s: failed to receive struct itimerval old\n",
+                   __FUNCTION__);
+    }
+
+  rio_dbg_printf ("%s[%u]: which = %d, new = %lx, old = %lx -- res = %d, errno = %d\n",
+                  __FUNCTION__, mid, which, new, old, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_sigaction.c b/remote_io/pcn_sys_sigaction.c
new file mode 100644
index 0000000000..7eebc1cfe6
--- /dev/null
+++ b/remote_io/pcn_sys_sigaction.c
@@ -0,0 +1,58 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <signal.h>
+#include <errno.h>
+#include <termios.h>
+#include <kernel_sigaction.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+#ifndef SA_RESTORER
+#define SA_RESTORER 0x04000000L
+#endif
+
+void
+pcn_sigaction_forwarder (int sig, siginfo_t *info, void *data)
+{
+  void (*sa_fwd)(int, siginfo_t *, void *) = pcn_data->rio_sa_sigs[sig-1].pcn_sa_handler;
+
+  rio_dbg_printf ("%s: received signal %u\n", __FUNCTION__, sig);
+
+  /* Flush incoming socket buffer to effectively cancel a system call.  */
+  tcflush (pcn_data->pcn_server_sockfd, TCIFLUSH);
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  sa_fwd (sig-1, info, data);
+  rio_dbg_printf ("%s: exiting signal %u\n", __FUNCTION__, sig);
+}
+
+int
+pcn_sigaction (int sig, const struct kernel_sigaction *act,
+               struct kernel_sigaction *oacc, int size)
+{
+  int res;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_rt_sigaction (sig, act, oacc, size);
+
+  res = lio_rt_sigaction (sig, act, oacc, size);
+
+  rio_dbg_printf ("%s: signal = %d -> res = %d\n",
+                  __FUNCTION__, sig, res);
+
+  if (act == NULL || sig < 0 || sig > PCN_NSIG)
+    return res;
+
+  // Register the signal handler in dl_pcn_data
+  pcn_data->rio_sa_active |= (1LL << sig);
+  pcn_data->rio_sa_sigs[sig-1].pcn_sa_handler = (void *)act->k_sa_handler;
+  pcn_data->rio_sa_sigs[sig-1].pcn_sa_mask = *(unsigned long *)&act->sa_mask;
+  pcn_data->rio_sa_sigs[sig-1].pcn_sa_flags = act->sa_flags & ~SA_RESTORER;
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_signalfd.c b/remote_io/pcn_sys_signalfd.c
new file mode 100644
index 0000000000..e65b7a3ff8
--- /dev/null
+++ b/remote_io/pcn_sys_signalfd.c
@@ -0,0 +1,55 @@
+#include <errno.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_signalfd (int fd, const sigset_t *mask, int flags)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_signalfd msg;
+  struct iovec payload[1];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_signalfd (fd, mask, flags);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SIGNALFD;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.fd = fd;
+
+  if (mask == NULL)
+    msg.sigmask = 0;
+  else
+    memcpy (&msg.sigmask, mask, sizeof (long));
+
+  msg.flags = flags;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %d, mask = %lx, flags = %d -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, fd, mask, flags, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_sigprocmask.c b/remote_io/pcn_sys_sigprocmask.c
new file mode 100644
index 0000000000..0fea3b6bc8
--- /dev/null
+++ b/remote_io/pcn_sys_sigprocmask.c
@@ -0,0 +1,42 @@
+#include <errno.h>
+#include <signal.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+#define KERNEL_NSIG 64
+
+int
+pcn_sigprocmask (int how, const sigset_t *set, sigset_t *oset)
+{
+  int res;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_rt_sigprocmask (how, set, oset, _NSIG / 8);
+
+  if (set != NULL)
+    {
+      if (how == SIG_BLOCK)
+	pcn_data->rio_sigmask |= set->__val[0];
+      else if (how == SIG_UNBLOCK)
+	pcn_data->rio_sigmask &= ~set->__val[0];
+      else if (how == SIG_SETMASK)
+	pcn_data->rio_sigmask = set->__val[0];
+      else
+	lio_error ("%s: unrecognized option %d", __FUNCTION__, how);
+    }
+
+  res = lio_rt_sigprocmask (how, set, oset, sizeof (long));
+
+  rio_dbg_printf ("%s[local]: mask = %lx -> %lx -- oset = %lx res = %u, errno = %u\n",
+		  __FUNCTION__, set == NULL ? 0LL : set->__val[0], pcn_data->rio_sigmask,
+                  oset == NULL ? 0LL : oset->__val[0], res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  return (mode_t)res;
+}
diff --git a/remote_io/pcn_sys_sock_getname.c b/remote_io/pcn_sys_sock_getname.c
new file mode 100644
index 0000000000..ed2fccb7ae
--- /dev/null
+++ b/remote_io/pcn_sys_sock_getname.c
@@ -0,0 +1,86 @@
+#include <string.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_sock_getname (int syscall, int fd, struct sockaddr *restrict addr, socklen_t *restrict len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_getpeername *msg;
+  struct iovec payload[1];
+  ssize_t res, size;
+  int mid;
+  const char *sysname = NULL;
+
+  if (syscall == PCN_SYS_GETPEERNAME)
+    sysname = "getpeername";
+  else
+    {
+      LIO_ASSERT (syscall == PCN_SYS_GETSOCKNAME, "unexpected syscall");
+      sysname = "getsockname";
+    }
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    {
+      if (syscall == PCN_SYS_GETPEERNAME)
+        return lio_getpeername (fd, addr, len);
+      else
+        return lio_getsockname (fd, addr, len);
+    }
+
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  size = sizeof (struct pcn_msg_getpeername) + *len;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = syscall;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = size;
+  hdr.msg_errno = errno;
+
+  msg = alloca (sizeof (struct pcn_msg_getpeername) + *len);
+  msg->sockfd = fd;
+  msg->addrlen = *len;
+  msg->rio_errno = 0;
+  memcpy (msg->addr, addr, *len);
+
+  payload->iov_base = msg;
+  payload->iov_len = size;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, msg, size);
+
+  if (res < 0 || msg->sockfd)
+    {
+      rio_dbg_printf ("%s[%u]: failed to create pipe - %x / %x\n",
+		      __FUNCTION__, mid, res, msg->sockfd, msg->rio_errno);
+      return msg->sockfd;
+    }
+
+  *len = msg->addrlen;
+  memcpy (addr, msg->addr, *len);
+
+  rio_dbg_printf ("%s[%u]: syscall = %s, socket = %u, len = %u -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, sysname, fd, *len, msg->sockfd,
+                  msg->rio_errno);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return msg->sockfd;
+}
diff --git a/remote_io/pcn_sys_socket.c b/remote_io/pcn_sys_socket.c
new file mode 100644
index 0000000000..503fc42b6c
--- /dev/null
+++ b/remote_io/pcn_sys_socket.c
@@ -0,0 +1,157 @@
+#include <string.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+#include <elf/popcorn.h>
+#include <errno.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_socket (int domain, int type, int protocol)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_socket msg;
+  struct iovec payload[1];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_socket (domain, type, protocol);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SOCKET;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.domain = domain;
+  msg.type = type;
+  msg.protocol = protocol;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  rio_dbg_printf ("%s[%u]: domain = %x, type = %x, protocol = %x -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, domain, type, protocol, res, errno);
+
+  //rio_dbg_printf ("%s: %s\n", __FUNCTION__, buf);
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_setsockopt (int fd, int level, int optname, const void *optval,
+		int len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_sockopt msg;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_setsockopt (fd, level, optname, optval, len);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SETSOCKOPT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + len;
+  hdr.msg_errno = errno;
+
+  msg.sockfd = fd;
+  msg.level = level;
+  msg.optname = optname;
+  msg.optlen = len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)optval;
+  payload[1].iov_len = len;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, fd, level, optname, optval, len,
+                  res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_getsockopt (int fd, int level, int optname, const void *optval,
+		socklen_t *len)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_sockopt msg, *rmsg;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_getsockopt (fd, level, optname, optval, len);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_GETSOCKOPT;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (msg) + *len;
+  hdr.msg_errno = errno;
+
+  msg.sockfd = fd;
+  msg.level = level;
+  msg.optname = optname;
+  msg.optlen = *len;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)optval;
+  payload[1].iov_len = *len;
+
+  rmsg = alloca (hdr.msg_size);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, rmsg, hdr.msg_size);
+
+  res = rmsg->sockfd;
+  errno = rmsg->level;
+  lio_memcpy ((void *)optval, rmsg->optval, rmsg->optlen);
+  *len = rmsg->optlen;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %d, errno = %d\n",
+		  __FUNCTION__, mid, fd, level, optname, optval, *len,
+                  res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_statfs.c b/remote_io/pcn_sys_statfs.c
new file mode 100644
index 0000000000..bb817b1b63
--- /dev/null
+++ b/remote_io/pcn_sys_statfs.c
@@ -0,0 +1,116 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+pcn_statfs (const char *file, struct statfs *buf)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[1];
+  int res, mid, msize, t;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_statfs (file, buf);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+  msize = strlen (file) + 1;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_STATFS;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = msize;
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = (void *)file;
+  payload[0].iov_len = msize;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (res < 0)
+    {
+      rio_dbg_printf ("%s[%u]: file = %s, buf = %lx -- res = %d, errno = %d\n",
+                      __FUNCTION__, mid, file, buf, res, errno);
+      return res;
+    }
+
+  t = rio_msg_get (pcn_data->pcn_server_sockfd, buf, sizeof (struct statfs));
+  if (t < sizeof (struct statfs))
+    lio_error ("%s: failed to receive struct statfs buf\n", __FUNCTION__);
+
+  rio_dbg_printf ("%s[%u]: file = %s, buf = %lx -- res = %d, "
+                  "f_type = %lx, f_bsize = %ld, f_blocks = %ld, f_bfree = %ld, "
+                  "f_bavail = %ld, f_files = %ld, f_ffree = %ld, f_fsid = %lx, "
+                  "f_namelen = %ld, f_frsize = %ld, f_flags = %ld\n",
+		  __FUNCTION__, mid, file, buf, res,
+                  buf->f_type, buf->f_bsize, buf->f_blocks, buf->f_bfree,
+                  buf->f_bavail, buf->f_files, buf->f_ffree, buf->f_fsid,
+                  buf->f_namelen, buf->f_frsize, buf->f_flags);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_fstatfs (int fd, struct statfs *buf)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[1];
+  int res, t, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    return lio_fstatfs (fd, buf);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FSTATFS;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (fd);
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &fd;
+  payload[0].iov_len = sizeof (int);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  if (res < 0)
+    {
+      rio_dbg_printf ("%s[%u]: fd = %d, buf = %lx -- res = %d, errno = %d\n",
+                      __FUNCTION__, mid, fd, buf, res, errno);
+      return res;
+    }
+
+  t = rio_msg_get (pcn_data->pcn_server_sockfd, buf, sizeof (struct statfs));
+  if (t < sizeof (struct statfs))
+    lio_error ("%s: failed to receive struct statfs buf\n", __FUNCTION__);
+
+  rio_dbg_printf ("%s[%u]: fd = %d, buf = %lx -- res = %d, "
+                  "f_type = %lx, f_bsize = %ld, f_blocks = %ld, f_bfree = %ld, "
+                  "f_bavail = %ld, f_files = %ld, f_ffree = %ld, f_fsid = %lx, "
+                  "f_namelen = %ld, f_frsize = %ld, f_flags = %ld\n",
+		  __FUNCTION__, mid, fd, buf, res,
+                  buf->f_type, buf->f_bsize, buf->f_blocks, buf->f_bfree,
+                  buf->f_bavail, buf->f_files, buf->f_ffree, buf->f_fsid,
+                  buf->f_namelen, buf->f_frsize, buf->f_flags);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_sync.c b/remote_io/pcn_sys_sync.c
new file mode 100644
index 0000000000..c86afccea1
--- /dev/null
+++ b/remote_io/pcn_sys_sync.c
@@ -0,0 +1,68 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+pcn_sync (int type, int fd)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[1];
+  int res, mid;
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    {
+      switch (type) {
+        case PCN_SYS_FDATASYNC:
+          lio_fdatasync (fd);
+          break;
+
+        case PCN_SYS_FSYNC:
+          lio_fsync (fd);
+          break;
+
+        default:
+          lio_error ("%s: invalid type %d\n", __FUNCTION__, type);
+      }
+    }
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = type;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (int);
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = &fd;
+  payload[0].iov_len = sizeof (int);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  switch (type) {
+    case PCN_SYS_FDATASYNC:
+      rio_dbg_printf ("%s[%u]: type = fdatasync, fd = %d -- res = %d, errno = %d\n",
+                      __FUNCTION__, mid, fd, res, errno);
+        break;
+
+    case PCN_SYS_FSYNC:
+      rio_dbg_printf ("%s[%u]: type = fsync, fd = %d -- res = %d, errno = %d\n",
+                      __FUNCTION__, mid, fd, res, errno);
+        break;
+
+    default:
+      lio_error ("%s: invalid type %d\n", __FUNCTION__, type);
+    }
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_sync_file_range.c b/remote_io/pcn_sys_sync_file_range.c
new file mode 100644
index 0000000000..1372adaab4
--- /dev/null
+++ b/remote_io/pcn_sys_sync_file_range.c
@@ -0,0 +1,52 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "rio_common_dir.h"
+#include "server.h"
+
+int
+pcn_sync_file_range (int fd, off_t offset, off_t len,
+                     unsigned int flags)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_sync_file_range msg;
+  struct iovec payload[1];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    return lio_sync_file_range (fd, offset, len, flags);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_SYNC_FILE_RANGE;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.fd = fd;
+  msg.offset = offset;
+  msg.len = len;
+  msg.flags = flags;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %d, offset = %ld, len = %ld, flags = %d -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, fd, offset, len, flags, res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_truncate.c b/remote_io/pcn_sys_truncate.c
new file mode 100644
index 0000000000..fec9fe3dfb
--- /dev/null
+++ b/remote_io/pcn_sys_truncate.c
@@ -0,0 +1,89 @@
+#include <string.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "local_io.h"
+#include "server.h"
+
+int
+pcn_ftruncate64 (int fd, off_t length)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_ftruncate msg;
+  struct iovec payload[1];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    return lio_ftruncate64 (fd, length);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_FTRUNCATE64;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.fd = fd;
+  msg.length = length;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+
+  rio_dbg_printf ("%s[%u]: fd = %d, length = %ld -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, fd, length, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
+
+int
+pcn_truncate64 (const char *path, off_t length)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_truncate msg;
+  struct iovec payload[2];
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_truncate64 (path, length);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_TRUNCATE64;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + strlen (path) + 1;
+  hdr.msg_errno = errno;
+
+  msg.length = length;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+  payload[1].iov_base = (void *)path;
+  payload[1].iov_len = strlen (path) + 1;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: path = %s, length = %ld -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, path, length, res, errno);
+
+  rio_enable_signals ();
+
+  return res;
+}
diff --git a/remote_io/pcn_sys_umask.c b/remote_io/pcn_sys_umask.c
new file mode 100644
index 0000000000..c94a46d4b4
--- /dev/null
+++ b/remote_io/pcn_sys_umask.c
@@ -0,0 +1,40 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+mode_t
+pcn_umask (mode_t mask)
+{
+  struct pcn_msg_hdr hdr;
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_umask (mask);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_UMASK;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = mask;
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, NULL, 0);
+
+  rio_dbg_printf ("%s[%u]: mask = %x -- res = %u, errno = %u\n",
+		  __FUNCTION__, mid, mask, res, errno);
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return (mode_t)res;
+}
diff --git a/remote_io/pcn_sys_uname.c b/remote_io/pcn_sys_uname.c
new file mode 100644
index 0000000000..32c5b7599c
--- /dev/null
+++ b/remote_io/pcn_sys_uname.c
@@ -0,0 +1,59 @@
+#include <string.h>
+#include <sys/utsname.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+pcn_uname (struct utsname *buf)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_uname msg;
+  int res, mid;
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active)
+    return lio_uname (buf);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = PCN_SYS_UNAME;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = 0;
+  hdr.msg_errno = errno;
+
+  rio_msg_send_raw (pcn_data->pcn_server_sockfd, &hdr, sizeof (hdr));
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &msg, sizeof (msg));
+  LIO_ASSERT (res == sizeof (msg), "corrupted response from server");
+
+  rio_dbg_printf ("%s[%u]: sysname = %s, nodename = %s, release = %s, "
+		  "version = %s, machine = %s, domainname = %s -- "
+		  "res = %d, errno = %d\n",
+		  __FUNCTION__, mid, msg.sysname, msg.nodename,
+		  msg.release, msg.version, msg.machine, msg.domainname,
+		  msg.rio_res, msg.rio_errno);
+
+  memcpy (buf->sysname, msg.sysname, PCN_UNAME_LEN);
+  memcpy (buf->nodename, msg.nodename, PCN_UNAME_LEN);
+  memcpy (buf->release, msg.release, PCN_UNAME_LEN);
+  memcpy (buf->version, msg.version, PCN_UNAME_LEN);
+  memcpy (buf->machine, msg.machine, PCN_UNAME_LEN);
+  memcpy (buf->domainname, msg.domainname, PCN_UNAME_LEN);
+
+  errno = msg.rio_errno;
+  
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return msg.rio_res;
+}
diff --git a/remote_io/pcn_sys_write.c b/remote_io/pcn_sys_write.c
new file mode 100644
index 0000000000..57c1f53535
--- /dev/null
+++ b/remote_io/pcn_sys_write.c
@@ -0,0 +1,182 @@
+/* 
+ * Write and writev system call forwarding.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+#include <ldsodefs.h>
+
+static ssize_t
+do_pcn_write (const char *fn, int kind, int fd, const void *buf, size_t count, off_t offset)
+{
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[2];
+  struct pcn_write_msg msg;
+  ssize_t res;
+  int mid;
+
+  /* Don't forward the write message unless the file
+     descriptor is available on the server.
+
+     TODO: add support or remote file I/O on the server. */
+//  if (fd > 2)
+//    return syscall (SYS_write, fd, buf, count);
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    {
+      if (kind == PCN_SYS_WRITE)
+        return lio_write (fd, buf, count);
+      else
+        return lio_pwrite (fd, buf, count, offset);
+    }
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  mid = rio_msg_id ();
+
+  msg.fd = fd;
+  msg.size = count;
+  msg.offset = offset;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  payload[1].iov_base = (void *)buf;
+  payload[1].iov_len = count;
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = kind;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg) + count;
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 2);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, count = %ld -- res = %ld, errno = %d\n",
+		  fn, mid, fd, count, res, errno);
+
+//  printf ("size: hdr = %zu, msg = %zu (%d), payload = %d\n",
+//	  sizeof (hdr), sizeof (msg), msg.size, size);
+//
+//  printf ("transmitted %d bytes\n", res);
+
+  //res = read (pcn_server_sockfd, &hdr, sizeof hdr);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+
+  rio_enable_signals ();
+
+  return res;
+}
+
+ssize_t
+pcn_write (int fd, const void *buf, size_t count)
+{
+  return do_pcn_write (__FUNCTION__, PCN_SYS_WRITE, fd, buf, count, 0);
+}
+
+static ssize_t
+do_pcn_writev (const char *fn, int kind, int fd, const struct iovec *iov, int iovcnt,
+               off_t offset)
+{
+  int i, mid, size = 0;
+//  int off = 0;
+//  uint8_t *buf;
+  struct pcn_msg_hdr hdr;
+  struct iovec payload[iovcnt + 1];
+  struct pcn_write_msg msg;
+  ssize_t res;
+  int payload_sz = sizeof (msg);
+
+  /* Check if the server is down.  */
+  if (!pcn_data->pcn_remote_io_active || rio_fd_find (fd))
+    {
+      if (kind == PCN_SYS_WRITE)
+        return lio_writev (fd, iov, iovcnt);
+      else
+        return lio_pwritev64 (fd, iov, iovcnt, offset);
+    }
+
+  lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_disable_signals ();
+
+  for (i = 0; i < iovcnt; i++)
+    size += iov[i].iov_len;
+
+//  buf = malloc (size);
+//
+//  for (i = 0; i < iovcnt; i++) {
+//    memcpy (buf + off, iov[i].iov_base, iov[i].iov_len);
+//    off += iov[i].iov_len;
+//  }
+
+  mid = rio_msg_id ();
+
+  msg.fd = fd;
+  msg.size = size;
+  msg.offset = offset;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = sizeof (msg);
+
+  for (i = 1; i < iovcnt+1; i++) {
+    payload[i].iov_base = iov[i-1].iov_base;
+    payload[i].iov_len = iov[i-1].iov_len;
+    payload_sz += iov[i-1].iov_len;
+  }
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = kind;
+  hdr.msg_id = mid;
+  hdr.msg_async = 0;
+  hdr.msg_size = payload_sz;
+  hdr.msg_errno = errno;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, iovcnt+1);
+
+  if (kind == PCN_SYS_WRITE)
+    rio_dbg_printf ("%s[%u]: fd = %u, iovcnt = %u, size = %u -- res = %ld, errno = %d\n",
+		    fn, mid, fd, iovcnt, size, res, errno);
+  else
+    rio_dbg_printf ("%s[%u]: fd = %u, iovcnt = %u, size = %u, offset = %ld -- res = %ld, errno = %d\n",
+		    fn, mid, fd, iovcnt, size, offset, res, errno);
+
+  //lio_assert_empty_socket (pcn_data->pcn_server_sockfd);
+  rio_enable_signals ();
+
+  return res;
+}
+
+ssize_t
+pcn_writev (int fd, const struct iovec *iov, int iovcnt)
+{
+  return do_pcn_writev (__FUNCTION__, PCN_SYS_WRITE, fd, iov, iovcnt, 0);
+}
+
+ssize_t
+pcn_pwrite64 (int fd, const void *buf, size_t count, off_t offset)
+{
+  return do_pcn_write (__FUNCTION__, PCN_SYS_PWRITE, fd, buf, count, offset);
+}
+
+ssize_t
+pcn_pwritev64 (int fd, const struct iovec *iov, size_t count, off_t offset)
+{
+  return do_pcn_writev (__FUNCTION__, PCN_SYS_PWRITE, fd, iov, count, offset);
+}
diff --git a/remote_io/pcn_util.c b/remote_io/pcn_util.c
new file mode 100644
index 0000000000..db53ef51b5
--- /dev/null
+++ b/remote_io/pcn_util.c
@@ -0,0 +1,43 @@
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "local_io.h"
+
+int
+pcn_server_fork (void)
+{
+  struct pcn_msg_hdr hdr;
+  int res;
+
+  hdr.msg_type = PCN_TYPE_CONTROL;
+  hdr.msg_kind = PCN_CTL_FORK;
+  hdr.msg_id = rio_msg_id ();
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (hdr);
+
+  res = rio_msg_send (pcn_data->pcn_server_sockfd, &hdr);
+
+  rio_dbg_printf ("%s: success! PORT = %d\n", __FUNCTION__, res);
+
+  return res;
+}
+
+void
+pcn_exec (void)
+{
+  struct pcn_msg_hdr hdr;
+
+  hdr.msg_type = PCN_TYPE_CONTROL;
+  hdr.msg_kind = PCN_CTL_EXEC;
+  hdr.msg_id = rio_msg_id ();
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = sizeof (hdr);
+
+  rio_msg_send (pcn_data->pcn_server_sockfd, &hdr);
+
+  lio_close (pcn_data->pcn_server_sockfd);
+
+  pcn_data->pcn_server_sockfd = -1;
+
+  rio_dbg_printf ("%s: success!\n", __FUNCTION__);
+}
diff --git a/remote_io/platform.c b/remote_io/platform.c
new file mode 100644
index 0000000000..e4ce5b1905
--- /dev/null
+++ b/remote_io/platform.c
@@ -0,0 +1,20 @@
+#include <errno.h>
+#include "pcn-platform.h"
+
+int popcorn_getnid(void)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+int popcorn_getthreadinfo(struct popcorn_thread_status *a)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+int popcorn_getnodeinfo(int *a, struct popcorn_node_status *b)
+{
+  errno = ENOSYS;
+  return -1;
+}
diff --git a/remote_io/platform.h b/remote_io/platform.h
new file mode 100644
index 0000000000..1690818300
--- /dev/null
+++ b/remote_io/platform.h
@@ -0,0 +1,68 @@
+/*
+ * Popcorn-specific platform information.
+ *
+ * Author: Rob Lyerly <rlyerly@vt.edu>
+ * Date: February 13th, 2018
+ */
+
+#ifndef _PLATFORM_H
+#define _PLATFORM_H
+
+/* The size of a page in the system. */
+#define PAGESZ 4096UL
+
+/*
+ * Round down & up to the nearest pages, respectively.  Arguments must be of
+ * unsigned long/uint64_t type.
+ */
+#define PAGE_ROUND_DOWN( x ) ((x) & ~(PAGESZ - 1))
+#define PAGE_ROUND_UP( x ) PAGE_ROUND_DOWN((x) + PAGESZ - 1)
+
+/* The maximum number of nodes supported by the system. */
+#define MAX_POPCORN_NODES 32
+
+/* Status of thread within Popcorn's single system image */
+struct popcorn_thread_status {
+  int current_nid;  /* The thread's current node */
+  int proposed_nid; /* Destination node if somebody proposed migration */
+  int peer_nid;     /* Node ID of peer thread in SSI */
+  int peer_pid;     /* PID of peer thread in SSI */
+};
+
+/*
+ * Return the node ID on which the current thread is executing.
+ * @return the current node ID or -1 otherwise
+ */
+int popcorn_getnid();
+
+/*
+ * Query thread status information.  Populates the thread status struct with
+ * the current thread's status.
+ *
+ * @param status thread status struct
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+int popcorn_getthreadinfo(struct popcorn_thread_status *status);
+
+/* Status of nodes in Popcorn's single system image */
+struct popcorn_node_status {
+  unsigned int status; /* 1 if online, 0 if not */
+  int arch;            /* Architecture of node -- see arch.h */
+  int distance;        /* Hop distance between current and other node */
+};
+
+/*
+ * Query node status information.  Populates the integer passed via pointer
+ * with the ID of the origin node and populates the array of nodes status
+ * structs with their current status.
+ *
+ * @param origin pointer to integer to be set with the origin ID
+ * @param status array of node status structs, must have MAX_POPCORN_NODES
+ *               elements
+ * @return 0 if completed successfully or non-zero otherwise
+ */
+int popcorn_getnodeinfo(int *origin,
+                        struct popcorn_node_status status[MAX_POPCORN_NODES]);
+
+#endif /* _PLATFORM_H */
+
diff --git a/remote_io/popcorn_killd.c b/remote_io/popcorn_killd.c
new file mode 100644
index 0000000000..8f315fc1a2
--- /dev/null
+++ b/remote_io/popcorn_killd.c
@@ -0,0 +1,408 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <signal.h>
+#include <fcntl.h>
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <assert.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <sys/epoll.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "message.h"
+#include "local_io.h"
+#include "server.h"
+#include "remote_io.h"
+
+#define OPT_KILL (1 << 0)
+#define OPT_CLIENT (1 << 1)
+#define OPT_SIGNAL (1 << 2)
+
+#define BACKLOG 3
+
+int pcn_rio_disable = 1;
+int daemonize = 0;
+int verbose = 0;
+int port = POPCORN_KILLD_PORT;
+
+void
+print_help (char *execname)
+{
+  printf ("%s options:\n", execname);
+  printf ("  -c -> client mode; send kill message to server\n");
+  printf ("  -d -> launch as a daemon\n");
+  printf ("  -i [string] -> ip address of the server\n");
+  printf ("  -k -> terminate an active daemon\n");
+  printf ("  -p [int] -> port to listen for signal requests\n");
+  printf ("  -P [int] -> pid to forward a signal to\n");
+  printf ("  -S [int] -> signal to send\n");
+  printf ("  -v -> emit verbose diagnostics\n");
+  printf ("  -h -> print usage\n");
+}
+
+int
+get_msg (int sock, void *buf, int size)
+{
+  int cnt = 0;
+  int res;
+
+  while (cnt < size)
+  {
+    res = read (sock, &((char *)buf)[cnt], size - cnt);
+
+    if (res <= 0)
+      {
+	//rio_dbg_printf ("%s: error - lost data (%d -> %d/%d) - %d\n",
+	//	    __FUNCTION__, size, cnt, res, errno);
+	return res;
+      }
+
+      cnt += res;
+  }
+
+  return cnt;
+}
+
+void
+terminate_daemon (void)
+{
+  struct pcn_msg_signal msg;
+  struct addrinfo hints, *ai;
+  uint32_t myip = pcn_get_ip ();
+  int sockfd, res;
+  char s_addr[INET_ADDRSTRLEN];
+  char buf[INET_ADDRSTRLEN], *s_port;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  inet_ntop (AF_INET, &myip, s_addr, INET_ADDRSTRLEN);
+  snprintf (buf, INET_ADDRSTRLEN, "%d", POPCORN_KILLD_PORT);
+  s_port = buf;
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0)
+    {
+      printf ("getaddrinfo: %s\n", gai_strerror (res));
+      exit (EXIT_FAILURE);
+    }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      exit (EXIT_FAILURE);
+    }
+
+  if (connect (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      perror ("connection failed");
+      printf ("   -> %s:%s\n", s_addr, s_port);
+      exit (EXIT_FAILURE);
+    }
+
+  freeaddrinfo (ai);
+
+  msg.pid = 0;
+  msg.sig = SIGKILL;
+  msg.type = PCN_SIG_SHUTDOWN;
+
+  write (sockfd, &msg, sizeof (msg));
+  close (sockfd);
+}
+
+void
+forward_signal (int sig, int pid, uint32_t ip)
+{
+  struct pcn_msg_signal msg;
+  struct addrinfo hints, *ai;
+  int sockfd, res;
+  char s_addr[INET_ADDRSTRLEN];
+  char buf[INET_ADDRSTRLEN], *s_port;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  inet_ntop (AF_INET, &ip, s_addr, INET_ADDRSTRLEN);
+  snprintf (buf, INET_ADDRSTRLEN, "%d", POPCORN_KILLD_PORT);
+  s_port = buf;
+
+  if (verbose)
+    printf ("Sending signal '%d' to pid '%d' @ ip = '%s'\n", sig, pid, s_addr);
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0)
+    {
+      printf ("getaddrinfo: %s\n", gai_strerror (res));
+      exit (EXIT_FAILURE);
+    }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      exit (EXIT_FAILURE);
+    }
+
+  if (connect (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      perror ("connection failed");
+      printf ("   -> %s:%s\n", s_addr, s_port);
+      exit (EXIT_FAILURE);
+    }
+
+  freeaddrinfo (ai);
+
+  msg.pid = pid;
+  msg.sig = sig;
+  msg.type = PCN_SIG_KILL;
+
+  write (sockfd, &msg, sizeof (msg));
+
+  close (sockfd);
+}
+
+int
+init_network (void)
+{
+  int sockfd = -1;
+  struct addrinfo hints, *ai;
+  int res;
+  char buf[INET_ADDRSTRLEN], *s_addr = NULL, *s_port = NULL;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  snprintf (buf, INET_ADDRSTRLEN, "%d", POPCORN_KILLD_PORT);
+  s_port = buf;
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0)
+    {
+      printf ("getaddrinfo: %s\n", gai_strerror (res));
+      exit (EXIT_FAILURE);
+    }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      exit (EXIT_FAILURE);
+    }
+
+  if (bind (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      perror ("BIND: connection failed");
+      printf ("   -> %s:%s, errno = %d\n", s_addr == NULL ? "" : s_addr,
+	      s_port == NULL ? "" : s_port, errno);
+      exit (EXIT_FAILURE);
+    }
+
+  if (listen (sockfd, 2) == -1) {
+    perror ("listen");
+    exit (EXIT_FAILURE);
+  }
+
+  freeaddrinfo (ai);
+
+  return sockfd;
+}
+
+void
+event_loop (int sockfd)
+{
+  struct epoll_event e;
+  int epfd;
+
+  epfd = epoll_create1 (0);
+
+  e.events = EPOLLIN;
+  e.data.fd = sockfd;
+  epoll_ctl (epfd, EPOLL_CTL_ADD, sockfd, &e);
+
+  while (1)
+    {
+      struct sockaddr_storage remoteaddr;
+      socklen_t addrlen;
+      struct pcn_msg_signal msig;
+      int events, client;
+
+      events = epoll_wait (epfd, &e, 1, -1);
+      if (events == -1 && errno != EINTR)
+	{
+	  perror ("epoll");
+	  exit (EXIT_FAILURE);
+	}
+      else if (events == 0)
+	continue;
+
+      if (!(e.events & (EPOLLIN)))
+	{
+	  printf ("Error: unexpected event\n");
+	  exit (EXIT_FAILURE);
+	}
+
+      /* Handle incoming event  */
+
+      if (e.data.fd != sockfd)
+	{
+	  printf ("Error: unexpected client\n");
+	  exit (EXIT_FAILURE);
+	}
+
+      addrlen = sizeof (remoteaddr);
+      client = accept (sockfd, (struct sockaddr *)&remoteaddr,
+			   &addrlen);
+
+      if (client < 0)
+	perror ("Failed to accept client");
+      else
+	{
+	  char buf[INET_ADDRSTRLEN];
+	  struct sockaddr_in *sin = (struct sockaddr_in *)&remoteaddr;
+
+	  if (verbose)
+	    {
+	      inet_ntop (remoteaddr.ss_family, &sin->sin_addr, buf,
+			 INET_ADDRSTRLEN);
+	      printf ("Accepted client %s\n", buf);
+	    }
+
+	  /* Process the incoming request.  */
+	  get_msg (client, &msig, sizeof (msig));
+
+	  if (msig.type == PCN_SIG_SHUTDOWN)
+	    {
+	      if (verbose)
+		printf ("Terminating popcorn_killd\n");
+
+	      exit (EXIT_SUCCESS);
+	    }
+
+	  if (verbose)
+	    printf ("Forwarding signal '%d' to pid '%d'\n", msig.sig, msig.pid);
+
+	  kill (msig.pid, msig.sig);
+
+	  close (client);
+
+	  continue;
+	}
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int c;
+  int options = 0;
+  char *hostaddr = NULL;
+  int sig = -1, pid = -1;
+  int sockfd;
+  uint32_t ip = 0;
+
+  /* Deactivate the RIO server.  */
+  pcn_rio_restart_disabled ();
+
+  while ((c = getopt (argc, argv, "cdki:hp:P:sS:v")) != -1)
+    switch (c)
+      {
+      case 'c':
+	options |= OPT_CLIENT;
+	break;
+
+      case 'd':
+	daemonize = 1;
+	break;
+
+      case 'k':
+	options |= OPT_KILL;
+	break;
+
+      case 'i':
+	hostaddr = strdup (optarg);
+	break;
+
+      case 'p':
+	port = atoi (optarg);
+	break;
+
+      case 'P':
+	pid = atoi (optarg);
+	break;
+
+      case 'S':
+	options |= OPT_SIGNAL;
+	sig = atoi (optarg);
+	break;
+
+      case 'v':
+	verbose = 1;
+	break;
+
+      case 'h':
+      default:
+	print_help (argv[0]);
+	exit (EXIT_SUCCESS);
+      }
+
+  if (hostaddr != NULL)
+    {
+      ip = inet_addr (hostaddr);
+
+      if (verbose)
+	printf ("ip = %x\n", ip);
+
+      if (ip == INADDR_NONE)
+	{
+	  printf ("Error: Invalid IP address\n");
+	  exit (EXIT_FAILURE);
+	}
+    }
+
+  if (options & OPT_KILL)
+    {
+      terminate_daemon ();
+      exit (EXIT_SUCCESS);
+    }
+  else if (options & OPT_SIGNAL)
+    {
+      if (ip != 0)
+	{
+	  forward_signal (sig, pid, ip);
+	  exit (EXIT_SUCCESS);
+	}
+
+      if (verbose)
+	printf ("Sending signal '%d' to pid '%d'\n", sig, pid);
+
+      kill (pid, sig);
+      exit (EXIT_SUCCESS);
+    }
+
+  if (daemonize && (fork () != 0))
+    exit (EXIT_SUCCESS);
+
+  sockfd = init_network ();
+
+  event_loop (sockfd);
+
+  return 0;
+}
diff --git a/remote_io/remote_io.h b/remote_io/remote_io.h
new file mode 100644
index 0000000000..c08ec611c7
--- /dev/null
+++ b/remote_io/remote_io.h
@@ -0,0 +1,174 @@
+#ifndef REMOTE_IO_H
+#define REMOTE_IO_H
+
+#include <stdarg.h>
+#include <stdint.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <signal.h>
+
+extern int pcn_remote_io_active;
+
+struct epoll_event;
+struct sigaction;
+struct pollfd;
+struct utsname;
+struct stat;
+struct kernel_sigaction;
+struct statfs;
+struct itimerval;
+
+struct pcn_msg_open;
+struct pcn_msg_hdr;
+struct pcn_msg_res;
+
+/* On a server process, pcn_server_sockfd represents the socket connection
+ * to the primary server if necessary. pcn_client_sockfd represents the
+ * connection to the client.
+ *
+ * On the local application, pcn_server_sockfd represents the socket
+ * connection to the local server, and pcn_client_sockfd is unused.
+ */
+//extern int pcn_server_sockfd;
+//extern int pcn_client_sockfd;
+//extern uint32_t pcn_local_ip;
+
+#define PCN_SERVER_INIT 1
+#define PCN_SERVER_READY 2
+
+/* RIO_DEBUG environment variable parameters: */
+#define RIO_DEBUG_ALL 1
+#define RIO_DEBUG_SERVER 2
+#define RIO_DEBUG_CLIENT 3
+
+#define PCN_SIG_RIO 34
+
+extern ssize_t pcn_read(int fd, void *buf, size_t count);
+extern ssize_t pcn_pread64(int fd, void *buf, size_t count, off_t offset);
+//extern ssize_t pcn_readv (int fd, const struct iovec *iov, int iovecnt);
+extern ssize_t pcn_write (int fd, const void *buf, size_t count);
+extern ssize_t pcn_writev (int fd, const struct iovec *iov, int iovecnt);
+extern ssize_t pcn_pwrite64 (int fd, const void *buf, size_t count,
+                             off_t offset);
+extern ssize_t pcn_pwritev64 (int fd, const struct iovec *iov, size_t count,
+                             off_t offset);
+extern int pcn_close(int fd);
+extern int pcn_openat(int dirfd, const char *pathname, int flags, mode_t mode);
+extern ssize_t pcn_fxstatat(int vers, int fd, const char *file,
+			    struct stat *st, int flag);
+extern void *pcn_mmap(void *addr, size_t length, int prot, int flags,
+                      int fd, off_t offset);
+extern int pcn_munmap(void *addr, size_t length);
+extern int pcn_epoll_create (int size);
+extern int pcn_epoll_ctl (int ver, int epfd, int op, int fd,
+			  struct epoll_event *event);
+extern int pcn_epoll_wait (int ver, int epfd, struct epoll_event *events,
+			   int maxevents, int timeout);
+extern int pcn_epoll_pwait (int ver, int epfd, struct epoll_event *events,
+			    int maxevents, int timeout, const sigset_t *sigmask);
+extern int pcn_poll (struct pollfd *fds, int nfds, int timeout);
+extern int pcn_ppoll (struct pollfd *fds, int nfds, const struct timespec *tp,
+		      const sigset_t *sigmask);
+extern int pcn_sigaction (int sig, const struct kernel_sigaction *act,
+			  struct kernel_sigaction *oacc, int size);
+extern int pcn_sigprocmask (int how, const sigset_t *set, sigset_t *oset);
+extern int pcn_kill (pid_t pid, int sig);
+extern int pcn_fallocate (int fd, int mode, off_t offset, off_t len);
+extern int pcn_fcntl (int fd, int mode, void *arg);
+extern int pcn_getcwd (char *buf, size_t size);
+extern int pcn_pipe (int pfds[2], int flags);
+extern int pcn_access (const char *pathname, int mode);
+extern int pcn_uname (struct utsname *buf);
+extern int pcn_dup (int fd);
+extern int pcn_dup2 (int oldfd, int newfd);
+extern int pcn_dup3 (int oldfd, int newfd, int flags);
+extern int pcn_getdents64 (int fd, void *buf, size_t nbytes);
+extern int pcn_chdir (const char *path);
+extern int pcn_chmod (const char *file, mode_t mode);
+extern int pcn_sync (int type, int fd);
+extern int pcn_ftruncate64 (int fd, off_t length);
+extern int pcn_truncate64 (const char *path, off_t length);
+extern int pcn_link (const char *from, const char *to);
+extern int pcn_unlink (const char *name);
+extern int pcn_symlink (const char *from, const char *to);
+extern ssize_t pcn_readlink (const char *path, char *buf, size_t len);
+extern int pcn_mkdir (const char *path, mode_t mode);
+extern int pcn_rmdir (const char *path);
+extern int pcn_rename (const char *old, const char *new);
+extern mode_t pcn_umask (mode_t mask);
+extern off_t pcn_lseek64 (int fd, off_t offset, int whence);
+extern int pcn_sync_file_range (int fd, off_t offset, off_t len,
+                                unsigned int flags);
+extern int pcn_statfs (const char *file, struct statfs *buf);
+extern int pcn_fstatfs (int fd, struct statfs *buf);
+extern int pcn_setitimer (int which, const struct itimerval *new,
+	                 struct itimerval *old);
+extern int pcn_getitimer (int which, struct itimerval *value);
+extern int pcn_signalfd (int fd, const sigset_t *mask, int flags);
+extern int pcn_execve (const char *path, char *const argv[], char *const envp[]);
+
+extern int pcn_socket (int domain, int type, int protocol);
+extern int pcn_sock_getname (int syscall, int fd, struct sockaddr *restrict addr,
+			     socklen_t *restrict len);
+extern int pcn_getsockopt (int fd, int level, int optname, const void *optval,
+			   socklen_t *len);
+extern int pcn_setsockopt (int fd, int level, int optname, const void *optval,
+			   int len);
+extern int pcn_bind (int sockfd, const void *addr, int addrlen);
+extern int pcn_listen (int sockfd, int backlog);
+extern int pcn_accept (int sockfd, void *addr, socklen_t *addrlen);
+extern int pcn_connect (int sockfd, const void *addr, int addrlen);
+extern ssize_t pcn_recvfrom (int sockfd, void *restrict buf, size_t len, int flags,
+                             struct sockaddr *restrict src_addr,
+                             socklen_t *addrlen);
+extern ssize_t pcn_recvmsg (int sockfd, struct msghdr *msg, int flags);
+extern ssize_t pcn_send (int fd, const void *buf, size_t count, int flags);
+extern ssize_t pcn_sendto (int fd, const void *buf, size_t count, int flags,
+                           const struct sockaddr *dest_addr, socklen_t addrlen);
+extern int pcn_select (int nfds, fd_set *readfds, fd_set *writefds,
+                       fd_set *exceptfds, struct timeval *timeout);
+extern int pcn_pselect (int nfds, fd_set *readfds, fd_set *writefds,
+                        fd_set *exceptfds, const struct timespec *timeout,
+                        const sigset_t *sigmask);
+
+extern int pcn_server_connect (uint32_t ip);
+extern void pcn_start_server (void);
+extern void pcn_migrate (void);
+extern void pcn_exec (void);
+extern void pcn_sigaction_forwarder (int sig, siginfo_t *info, void *data);
+extern int pcn_unload_signals (void);
+extern int pcn_restore_signals (void);
+extern void pcn_sig_rio_init (void);
+extern void pcn_setup_sigerror (int signo);
+
+extern int pcn_server_attach (int port);
+extern int pcn_server_fork (void);
+
+extern void pcn_migrate_disable (void);
+extern void pcn_migrate_enable (void);
+extern int pcn_rio_disconnect (void);
+extern void pcn_rio_restart_disabled (void);
+
+extern int rio_dbg_printf (const char *fmt, ...);
+extern int rio_dbg_fprintf (int fd, const char *fmt, ...);
+extern int rio_dbg_snprintf (char *str, size_t size, const char *fmt, ...);
+extern int rio_dbg_vfprintf (int fd, const char *restrict fmt, va_list arg);
+extern void rio_set_servername (void);
+extern void rio_disable_signals (void);
+extern void rio_enable_signals (void);
+extern int rio_signal_pending (void);
+extern int rio_debug (void);
+
+extern int rio_msg_id (void);
+extern int rio_msg_send_raw (int sockfd, void *data, int size);
+extern int rio_msg_send_iov (int fd, struct pcn_msg_hdr *hdr,
+                             struct iovec *payload, int cnt);
+extern int rio_msg_get (int sock, void *buf, int size);
+extern int rio_msg_get_robust (int *sock, void *buf, int size);
+extern int rio_msg_send (int fd, struct pcn_msg_hdr *hdr);
+extern void rio_msg_res (int fd, struct pcn_msg_res *res);
+extern int rio_msg_ack (int sockfd, struct pcn_msg_hdr *hdr, int res);
+
+extern void dump_pcn_data (void);
+
+#endif
diff --git a/remote_io/rio_common_dir.c b/remote_io/rio_common_dir.c
new file mode 100644
index 0000000000..9800c59a56
--- /dev/null
+++ b/remote_io/rio_common_dir.c
@@ -0,0 +1,170 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+#include "rio_common_dir.h"
+
+int
+pcn_common_dir (int syscall, int *mid, const char *path)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_res ack;
+  struct iovec payload[1];
+  int res;
+
+  *mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = syscall;
+  hdr.msg_id = *mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = strlen (path) + 1;
+  hdr.msg_errno = errno;
+
+  payload[0].iov_base = (void *)path;
+  payload[0].iov_len = hdr.msg_size;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 1);
+  if (res != sizeof (hdr) + hdr.msg_size)
+    lio_error ("%s: failed to send request\n", __FUNCTION__);
+
+  res = rio_msg_get (pcn_data->pcn_server_sockfd, &ack, sizeof (ack));
+  LIO_ASSERT (res == sizeof (ack), "corrupted response from server");
+
+  errno = ack.rio_errno;
+
+  return ack.res;
+}
+
+int
+rio_common_dir (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  void *path;
+  int res;
+
+  path = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, path, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  errno = hdr->msg_errno;
+
+  if (hdr->msg_kind == PCN_SYS_CHDIR)
+    ack.res = lio_chdir (path);
+  else if (hdr->msg_kind == PCN_SYS_RMDIR)
+    ack.res = lio_rmdir (path);
+  else
+    lio_error ("%s: unrecognized system call\n", __FUNCTION__);
+
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  if (hdr->msg_kind == PCN_SYS_CHDIR)
+    rio_dbg_printf ("%s[%u]: chdir -> path = %s -- res = %d, errno = %d\n",
+                    __FUNCTION__, hdr->msg_id, path, ack.res, ack.rio_errno);
+  else if (hdr->msg_kind == PCN_SYS_RMDIR)
+    rio_dbg_printf ("%s[%u]: rmdir -> path = %s -- res = %d, errno = %d\n",
+                    __FUNCTION__, hdr->msg_id, path, ack.res, ack.rio_errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  return res - sizeof (ack);
+}
+
+int
+pcn_common_dir_path2 (int syscall, int *mid, const char *a, const char *b)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_link msg;
+  struct iovec payload[3];
+  int res;
+  int l_a, l_b;
+
+  l_a = lio_strlen (a) + 1;
+  l_b = lio_strlen (b) + 1;
+
+  *mid = rio_msg_id ();
+
+  hdr.msg_type = PCN_TYPE_SYSCALL;
+  hdr.msg_kind = syscall;
+  hdr.msg_id = *mid;
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (msg);
+  hdr.msg_errno = errno;
+
+  msg.from_len = l_a;
+  msg.to_len = l_b;
+
+  payload[0].iov_base = &msg;
+  payload[0].iov_len = hdr.msg_size;
+  payload[1].iov_base = (void *)a;
+  payload[1].iov_len = l_a;
+  payload[2].iov_base = (void *)b;
+  payload[2].iov_len = l_b;
+
+  res = rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, payload, 3);
+
+  return res;
+}
+
+int
+rio_common_dir_path2 (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_link msg;
+  struct pcn_msg_res ack;
+  char *from, *to;
+  int res;
+
+  res = rio_msg_get (fd, &msg, sizeof (msg));
+  if (res != hdr->msg_size)
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  from = alloca (msg.from_len);
+  to = alloca (msg.to_len);
+
+  res = rio_msg_get (fd, from, msg.from_len);
+  if (res != msg.from_len)
+    lio_error ("%s: failed to receive FROM argument from client\n",
+               __FUNCTION__);
+
+  res = rio_msg_get (fd, to, msg.to_len);
+  if (res != msg.to_len)
+    lio_error ("%s: failed to receive TO argument from client\n",
+               __FUNCTION__);
+
+  errno = hdr->msg_errno;
+
+  if (hdr->msg_kind == PCN_SYS_LINK)
+    ack.res = lio_link (from, to);
+  else if (hdr->msg_kind == PCN_SYS_SYMLINK)
+    ack.res = lio_symlink (from, to);
+  else if (hdr->msg_kind == PCN_SYS_RENAME)
+    ack.res = lio_rename (from, to);
+  else
+    lio_error ("%s: unrecognized syscall\n", __FUNCTION__);
+
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  if (hdr->msg_kind == PCN_SYS_LINK)
+    rio_dbg_printf ("%s[%u]: link -> from = %s, to = %s -- res = %d, errno = %d\n",
+                    __FUNCTION__, hdr->msg_id, from, to, ack.res,
+                    ack.rio_errno);
+  else if (hdr->msg_kind == PCN_SYS_SYMLINK)
+    rio_dbg_printf ("%s[%u]: symlink -> from = %s, to = %s -- res = %d, errno = %d\n",
+                    __FUNCTION__, hdr->msg_id, from, to, ack.res,
+                    ack.rio_errno);
+  else if (hdr->msg_kind == PCN_SYS_RENAME)
+    rio_dbg_printf ("%s[%u]: rename -> from = %s, to = %s -- res = %d, errno = %d\n",
+                    __FUNCTION__, hdr->msg_id, from, to, ack.res,
+                    ack.rio_errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  return res - sizeof (ack);
+}
\ No newline at end of file
diff --git a/remote_io/rio_common_dir.h b/remote_io/rio_common_dir.h
new file mode 100644
index 0000000000..2e101ccd72
--- /dev/null
+++ b/remote_io/rio_common_dir.h
@@ -0,0 +1,13 @@
+#ifndef RIO_COMMON_DIR_H
+#define RIO_COMMON_DIR_H
+
+struct pcn_msg_hdr;
+
+extern int pcn_common_dir (int syscall, int *mid, const char *path);
+extern int pcn_common_dir_path2 (int syscall, int *mid, const char *a,
+                                 const char *b);
+
+extern int rio_common_dir (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_common_dir_path2 (struct pcn_msg_hdr *hdr, int fd);
+
+#endif
diff --git a/remote_io/rio_msg.c b/remote_io/rio_msg.c
new file mode 100644
index 0000000000..1c26983474
--- /dev/null
+++ b/remote_io/rio_msg.c
@@ -0,0 +1,169 @@
+#include <sysdep-cancel.h>
+#include <errno.h>
+#include <poll.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "message.h"
+#include "server.h"
+#include "local_io.h"
+
+int
+rio_msg_id (void)
+{
+  return pcn_data->rio_msg_idx++;
+}
+
+int
+rio_msg_send_raw (int sockfd, void *data, int size)
+{
+  int count = 0;
+  int res;
+
+//  if (pcn_data->pcn_client_sockfd)
+//    lio_dbg_printf ("%s: sending %d bytes to fd %d\n", __FUNCTION__, size, sockfd);
+
+  //rio_dbg_printf ("%s: transmitting %d bytes to sockfd %d\n", __FUNCTION__, size, sockfd);
+
+  do {
+    res = lio_write (sockfd, (char *)(data + count), size - count);
+
+    if (res < 0)
+      return res;
+
+    count += res;
+  } while (count < size);
+
+  return count;
+}
+
+static int
+do_rio_msg_send_iov (int fd, struct pcn_msg_hdr *hdr, struct iovec *payload, int cnt)
+{
+  int size = 0;
+  int i, res;
+  struct iovec out[cnt+1];
+
+  for (i = 0; i < cnt; i++)
+    size += payload[i].iov_len;
+
+  out[0].iov_base = hdr;
+  out[0].iov_len = sizeof (struct pcn_msg_hdr);
+
+  for (i = 1; i <= cnt; i++) {
+    out[i].iov_base = payload[i-1].iov_base;
+    out[i].iov_len = payload[i-1].iov_len;
+  }
+
+//  if (pcn_data->pcn_client_sockfd)
+//    lio_dbg_printf ("%s: sending %d bytes to fd %d\n", __FUNCTION__, hdr->msg_size, fd);
+
+//  rio_dbg_printf ("%s[%u]: sending message type=%u, kind=%u, size=%u\n",
+//		  __FUNCTION__, hdr->msg_id, hdr->msg_type, hdr->msg_kind, hdr->msg_size);
+
+  /* This write will terminate with a SIGPIPE if the connection
+     between the client and the host has closed unexpectedly.  */
+  res = lio_writev (fd, out, cnt + 1);
+
+//  rio_dbg_printf ("%s: sent %d bytes\n", __FUNCTION__, res);
+
+  return res;
+}
+
+int
+rio_msg_send_iov (int fd, struct pcn_msg_hdr *hdr, struct iovec *payload, int cnt)
+{
+  struct pcn_msg_res rio_res = { 0 };
+  int res = 0;
+
+  res = do_rio_msg_send_iov (fd, hdr, payload, cnt);
+
+  if (hdr->msg_async == PCN_SEND_SYNC) {
+    res = lio_read (fd, &rio_res, sizeof (rio_res));
+
+//    rio_dbg_printf ("%s[%u]: res = %u, errno = %x, id = %u, (%u / %u)\n",
+//		    __FUNCTION__, hdr->msg_id, rio_res.res, rio_res.rio_errno, rio_res.id,
+//		    res, sizeof (rio_res));
+
+    if (res == 0 || hdr->msg_id != rio_res.id)
+      lio_error ("%s: Corrupted response, res = %d / %d", __FUNCTION__,
+		 res, sizeof (rio_res));
+
+    errno = rio_res.rio_errno;
+    res = rio_res.res;
+  }
+
+  return res;
+}
+
+/* Read SIZE bytes from SOCK into BUF. SOCK is read until SIZE bytes
+   have been received or an error has been encounterd. */
+int
+rio_msg_get (int sock, void *buf, int size)
+{
+  int cnt = 0;
+  int res;
+
+  while (cnt < size)
+  {
+    res = lio_read (sock, &((char *)buf)[cnt], size - cnt);
+
+    if (res <= 0)
+      {
+	//rio_dbg_printf ("%s: error - lost data (%d -> %d/%d) - %d\n",
+	//	    __FUNCTION__, size, cnt, res, errno);
+	return res;
+      }
+
+      cnt += res;
+  }
+
+  return cnt;
+}
+
+int
+rio_msg_send (int fd, struct pcn_msg_hdr *hdr)
+{
+  struct pcn_msg_res rio_res;
+  int res;
+
+//  if (pcn_data->pcn_client_sockfd)
+//    lio_dbg_printf ("%s: sending %d bytes to fd %d\n", __FUNCTION__, hdr->msg_size, fd);
+
+  res = lio_write (fd, hdr, hdr->msg_size);
+  //rio_dbg_printf ("%s[%u]: sent %x bytes\n", __FUNCTION__, hdr->msg_id, res);
+
+  if (hdr->msg_async == PCN_SEND_SYNC)
+  {
+    res = lio_read (fd, &rio_res, sizeof (rio_res));
+
+//    rio_dbg_printf ("%s[%u]: res = %x, errno = %x\n",
+//		    __FUNCTION__, hdr->msg_id, rio_res.res, rio_res.rio_errno);
+
+    errno = rio_res.rio_errno;
+    res = rio_res.res;
+  }
+
+  return res;
+}
+
+/* This should eventually use the generic message sending framework
+   to handle ASYNC messages more gracefully.  */
+void
+rio_msg_res (int fd, struct pcn_msg_res *res)
+{
+  lio_write (fd, res, sizeof (*res));
+}
+
+int
+rio_msg_ack (int sockfd, struct pcn_msg_hdr *hdr, int res)
+{
+  struct pcn_msg_hdr ack;
+
+  ack.msg_kind = PCN_TYPE_CONTROL;
+  ack.msg_type = PCN_CTL_ACK;
+  ack.msg_id = hdr->msg_id;
+  ack.msg_size = res;
+
+  return lio_write (sockfd, &ack, sizeof (ack));
+}
diff --git a/remote_io/rio_print.c b/remote_io/rio_print.c
new file mode 100644
index 0000000000..868b204705
--- /dev/null
+++ b/remote_io/rio_print.c
@@ -0,0 +1,333 @@
+/* This file is a modified version of dl-minimal.c.  */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <sys/uio.h>
+#include <unistd.h>
+
+#include <elf/popcorn.h>
+#include "local_io.h"
+#include "remote_io.h"
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+const char _itoa_lower_digits_rio[16] = "0123456789abcdef";
+
+#if defined(__x86_64__) || defined(__aarch64__)
+#define NEED_L
+#endif
+
+#define RIO_PRINTBUF_SZ 512
+static char rio_printbuf[RIO_PRINTBUF_SZ];
+
+/* We always use _itoa instead of _itoa_word in ld.so since the former
+   also has to be present and it is never about speed when these
+   functions are used.  */
+char *
+pcn_itoa (unsigned long long int value, char *buflim, unsigned int base,
+       int upper_case)
+{
+  assert (! upper_case);
+
+  do
+    *--buflim = _itoa_lower_digits_rio[value % base];
+  while ((value /= base) != 0);
+
+  return buflim;
+}
+
+static int
+write_str (char *str, size_t size, struct iovec *iov, int niov)
+{
+  int ix, j, k;
+
+  for (ix = 0, j = 0; ix < size && j < niov; j++)
+    {
+      const char *buf = iov[j].iov_base;
+
+      for (k = 0; ix < size && k < iov[j].iov_len; k++, ix++)
+	str[ix] = buf[k];
+    }
+
+  if (ix < size)
+    str[ix] = '\0';
+
+  return ix;
+}
+
+//#pragma GCC optimize ("O0")
+/* Bare-bones printf implementation.  This function only knows about
+   the formats and flags needed and can handle only up to 64 stripes in
+   the output.  */
+static int
+pcn_dl_debug_vdprintf (int fd, int tag_p, int show_pid, char *str, size_t size,
+                       const char *fmt, va_list arg)
+{
+# define NIOVMAX 64
+  struct iovec iov[NIOVMAX];
+  int niov = 0;
+  const char *server_msg = "> pcn_server: ";
+  char pidbuf[20];
+
+  /* Print out [PID] prefix.  */
+  if (show_pid)
+    {
+      rio_dbg_snprintf (pidbuf, 20, "(%d) ", pcn_data->rio_my_pid);
+      iov[0].iov_base = pidbuf;
+      iov[0].iov_len = lio_strlen (pidbuf);
+      niov++;
+    }
+
+  if (pcn_mode == 1)
+    {
+      iov[niov].iov_base = (void *)server_msg;
+      iov[niov].iov_len = lio_strlen (server_msg);
+      niov++;
+    }
+
+  while (*fmt != '\0')
+    {
+      const char *startp = fmt;
+
+      /* Skip everything except % and \n (if tags are needed).  */
+      while (*fmt != '\0' && *fmt != '%' && (! tag_p || *fmt != '\n'))
+	++fmt;
+
+      /* Append constant string.  */
+      assert (niov < NIOVMAX);
+      if ((iov[niov].iov_len = fmt - startp) != 0)
+	iov[niov++].iov_base = (char *) startp;
+
+      if (*fmt == '%')
+	{
+	  /* It is a format specifier.  */
+	  char fill = ' ';
+	  int width = -1;
+	  int prec = -1;
+#ifdef NEED_L
+	  int long_mod = 0;
+#endif
+
+	  /* Recognize zero-digit fill flag.  */
+	  if (*++fmt == '0')
+	    {
+	      fill = '0';
+	      ++fmt;
+	    }
+
+	  /* See whether with comes from a parameter.  Note that no other
+	     way to specify the width is implemented.  */
+	  if (*fmt == '*')
+	    {
+	      width = va_arg (arg, int);
+	      ++fmt;
+	    }
+
+	  /* Handle precision.  */
+	  if (*fmt == '.' && fmt[1] == '*')
+	    {
+	      prec = va_arg (arg, int);
+	      fmt += 2;
+	    }
+
+	  /* Recognize the l modifier.  It is only important on some
+	     platforms where long and int have a different size.  We
+	     can use the same code for size_t.  */
+	  if (*fmt == 'l' || *fmt == 'Z')
+	    {
+#ifdef NEED_L
+	      long_mod = 1;
+#endif
+	      ++fmt;
+	    }
+
+	  switch (*fmt)
+	    {
+	      /* Integer formatting.  */
+            case 'd':
+	      {
+		long int num;
+                int inum;
+
+		/* We have to make a difference if long and int have a
+		   different size.  */
+                if (long_mod)
+                  num = va_arg (arg, unsigned long int);
+                else
+                  {
+                    inum = va_arg (arg, unsigned int);
+                    num = inum; // sign extend
+                  }
+
+                long int abs_num = num < 0 ? -num : num;
+
+		/* We use alloca() to allocate the buffer with the most
+		   pessimistic guess for the size.  Using alloca() allows
+		   having more than one integer formatting in a call.  */
+		char *buf = (char *) __builtin_alloca (3 * sizeof (long int));
+		char *endp = &buf[3 * sizeof (long int)];
+		char *cp = pcn_itoa (abs_num, endp, *fmt == 'x' ? 16 : 10, 0);
+
+                if (num < 0)
+                  *--cp = '-';
+
+		/* Pad to the width the user specified.  */
+		if (width != -1)
+		  while (endp - cp < width)
+		    *--cp = fill;
+
+		iov[niov].iov_base = cp;
+		iov[niov].iov_len = endp - cp;
+		++niov;
+	      }
+	      break;
+
+	    case 'u':
+	    case 'x':
+	      {
+		/* We have to make a difference if long and int have a
+		   different size.  */
+#ifdef NEED_L
+		unsigned long int num = (long_mod
+					 ? va_arg (arg, unsigned long int)
+					 : va_arg (arg, unsigned int));
+#else
+		unsigned long int num = va_arg (arg, unsigned int);
+#endif
+		/* We use alloca() to allocate the buffer with the most
+		   pessimistic guess for the size.  Using alloca() allows
+		   having more than one integer formatting in a call.  */
+		char *buf = (char *) __builtin_alloca (3 * sizeof (unsigned long int));
+		char *endp = &buf[3 * sizeof (unsigned long int)];
+		char *cp = pcn_itoa (num, endp, *fmt == 'x' ? 16 : 10, 0);
+
+		/* Pad to the width the user specified.  */
+		if (width != -1)
+		  while (endp - cp < width)
+		    *--cp = fill;
+
+		iov[niov].iov_base = cp;
+		iov[niov].iov_len = endp - cp;
+		++niov;
+	      }
+	      break;
+
+	    case 's':
+	      /* Get the string argument.  */
+	      iov[niov].iov_base = va_arg (arg, char *);
+	      iov[niov].iov_len = lio_strlen (iov[niov].iov_base);
+	      if (prec != -1)
+		iov[niov].iov_len = MIN ((size_t) prec, iov[niov].iov_len);
+	      ++niov;
+	      break;
+
+	    case '%':
+	      iov[niov].iov_base = (void *) fmt;
+	      iov[niov].iov_len = 1;
+	      ++niov;
+	      break;
+
+	    default:
+	      lio_error ("invalid format specifier\n");
+	    }
+	  ++fmt;
+	}
+      else if (*fmt == '\n')
+	{
+	  /* See whether we have to print a single newline character.  */
+	  if (fmt == startp)
+	    {
+	      iov[niov].iov_base = (char *) startp;
+	      iov[niov++].iov_len = 1;
+	    }
+	  else
+	    /* No, just add it to the rest of the string.  */
+	    ++iov[niov - 1].iov_len;
+
+	  /* Next line, print a tag again.  */
+	  tag_p = 1;
+	  ++fmt;
+	}
+    }
+
+  /* Finally write the result.  */
+  if (str != NULL)
+    return write_str (str, size, iov, niov);
+  else
+    {
+      /* Write diagnostics to a string, so that server and client
+	 messages don't overwrite one another.  */
+      int len = write_str (rio_printbuf, RIO_PRINTBUF_SZ, iov, niov);
+      return lio_write (fd, rio_printbuf, len);
+    }
+}
+
+/* Write to debug file.  */
+int
+rio_dbg_printf (const char *fmt, ...)
+{
+  va_list arg;
+  int ret;
+
+  if (!rio_debug ())
+    return 0;
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (pcn_data->rio_debug_fd, 0, 1, NULL, 0, fmt, arg);
+  va_end (arg);
+
+  return ret;
+}
+
+/* Write to debug file.  */
+int
+rio_dbg_fprintf (int fd, const char *fmt, ...)
+{
+  va_list arg;
+  int ret;
+
+  if (rio_debug ())
+    return 0;
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (fd, 0, 1, NULL, 0, fmt, arg);
+  va_end (arg);
+
+  return ret;
+}
+
+int
+rio_dbg_snprintf (char *str, size_t size, const char *fmt, ...)
+{
+  va_list arg;
+  int ret, t;
+
+  t = pcn_mode;
+  pcn_mode = 0;
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (-1, 0, 0, str, size, fmt, arg);
+  va_end (arg);
+
+  pcn_mode = t;
+
+  return ret;
+}
+
+int
+rio_dbg_vfprintf (int fd, const char *restrict fmt, va_list arg)
+{
+  return pcn_dl_debug_vdprintf (fd, 0, 1, NULL, 0, fmt, arg);
+}
+
+int
+lio_dbg_printf (const char *fmt, ...)
+{
+  va_list arg;
+  int ret;
+
+  va_start (arg, fmt);
+  ret = pcn_dl_debug_vdprintf (STDOUT_FILENO, 0, 1, NULL, 0, fmt, arg);
+  va_end (arg);
+
+  return ret;
+}
diff --git a/remote_io/rio_server.c b/remote_io/rio_server.c
new file mode 100644
index 0000000000..b320bb55b5
--- /dev/null
+++ b/remote_io/rio_server.c
@@ -0,0 +1,1110 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <ifaddrs.h>
+#include <net/if.h>
+
+#include <assert.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <sys/epoll.h>
+#include <fcntl.h>
+
+#include <stdarg.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <sys/prctl.h>
+
+#include <sys/wait.h>
+#include <signal.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "server.h"
+#include "local_io.h"
+#include "message.h"
+
+#define PCN_SERVER_INIT 1
+#define PCN_SERVER_READY 2
+#define PCN_RES_FORK 100
+#define PCN_MAX_EVENTS 3
+
+static int get_server_socket (void);
+static int do_pcn_server_connect (uint32_t ip);
+
+#define RIO_BUF_SZ 512
+
+void
+dump_pcn_data (void)
+{
+  int i, pos = 0;
+  char cmd[RIO_BUF_SZ];
+
+  pos += rio_dbg_snprintf (cmd, RIO_BUF_SZ, "%s", pcn_data->argv[0]);
+  for (i = 1; i < pcn_data->argc; i++)
+    pos += rio_dbg_snprintf (&cmd[pos], RIO_BUF_SZ-pos, " %s", pcn_data->argv[i]);
+
+  rio_dbg_printf ("%s: launching '%s'\n", __FUNCTION__, cmd);
+
+  rio_dbg_printf ("%s: pcn_entry = %lx, arg = %lx, argc = %d, argv = %lx, envp = %lx\n",
+		  __FUNCTION__, pcn_data->pcn_entry, pcn_data->arg,
+		  pcn_data->argc, pcn_data->argv, pcn_data->envp);
+  rio_dbg_printf ("%s: filename = %s, thread_pointer = %lx, tls_statc_block = %lx\n",
+		  __FUNCTION__, pcn_data->filename, pcn_data->thread_pointer,
+		  pcn_data->tls_static_block);
+  rio_dbg_printf ("%s: tls_init = %d, phnum = %d, pcn_data_size = %d, num_maps = %u\n",
+		  __FUNCTION__, pcn_data->tls_init, pcn_data->phnum,
+		  pcn_data->pcn_data_size, pcn_data->num_maps);
+  rio_dbg_printf ("%s: pcn_remote_io_active = %d, pcn_server_ip = %lx, pcn_server_port = %d\n",
+		  __FUNCTION__, pcn_data->pcn_remote_io_active,
+		  pcn_data->pcn_server_ip, (int)pcn_data->pcn_server_port);
+  rio_dbg_printf ("%s: pcn_server_sockfd = %d, pcn_client_sockfd = %d\n",
+		  __FUNCTION__, pcn_data->pcn_server_sockfd,
+		  pcn_data->pcn_client_sockfd);
+  rio_dbg_printf ("%s: pcn_listen_sockfd = %d, pcn_local_ip = %lx\n",
+		  __FUNCTION__, pcn_data->pcn_listen_sockfd,
+		  pcn_data->pcn_local_ip);
+  rio_dbg_printf ("%s: rio_migrate_pending = %d, rio_child_pid = %d, rio_debug = %d, pcn_break = %d, rio_msg_idx = %d\n",
+		  __FUNCTION__, pcn_data->rio_migrate_pending,
+		  pcn_data->rio_child_pid, pcn_data->rio_debug,
+		  pcn_data->pcn_break, pcn_data->rio_msg_idx);
+  rio_dbg_printf ("%s: rio_sigmask = %lx, pcn_storage = %s\n", __FUNCTION__,
+		  pcn_data->rio_sigmask, pcn_data->pcn_storage);
+  rio_dbg_printf ("%s: pcn_storage_shm = %s, pcn_storage_shm_len = %d\n", __FUNCTION__,
+                  pcn_data->pcn_storage_shm, pcn_data->pcn_storage_shm_len);
+}
+
+void
+pcn_server_init (void)
+{
+  char *debug, *dbg_file, *port;
+  char buf[RIO_BUF_SZ];
+
+  if ((debug = getenv ("RIO_DEBUG")) != NULL)
+    pcn_data->rio_debug = atoi (debug);
+  else
+    pcn_data->rio_debug = 0;
+
+  if (debug && (dbg_file = getenv ("RIO_DBG_FILE")))
+    {
+      rio_dbg_snprintf (buf, RIO_BUF_SZ, "%s.%d", dbg_file, getpid ());
+
+      pcn_data->rio_debug_fd = lio_open (buf, O_CREAT|O_WRONLY|O_TRUNC, 0644);
+      if (pcn_data->rio_debug_fd < 0)
+	lio_error ("%s: could not open RIO_OUTFILE='%s' for writing\n",
+		   __FUNCTION__, buf);
+    }
+  else
+    pcn_data->rio_debug_fd = STDOUT_FILENO;
+
+  if (getenv ("PCN_RIO_LOCAL"))
+    {
+      pcn_data->pcn_remote_io_active = 0;
+      pcn_data->pcn_server_sockfd = -1;
+      return;
+    }
+
+/*
+  if (getenv ("PCN_RIO_SERVER"))
+    {
+      // Attach to an existing server
+    }
+*/
+
+  pcn_data->pcn_remote_io_active = 0;
+  pcn_data->rio_msg_idx = 1000;
+  pcn_data->rio_num_maps = -1;
+  pcn_data->rio_my_pid = getpid ();
+  pcn_data->pcn_local_ip = pcn_get_ip ();
+
+  if ((port = getenv ("PCN_SERVER_PORT")) != NULL)
+    {
+      char *ip = getenv ("PCN_SERVER_IP");
+      pcn_data->pcn_server_port = atoi (port);
+      pcn_data->pcn_server_ip = atoi (ip);
+      pcn_data->pcn_remote_io_active = PCN_SERVER_READY;
+      pcn_data->pcn_server_sockfd = pcn_server_connect (0);
+    }
+  else
+    {
+      pcn_data->pcn_server_sockfd = do_pcn_server_connect (0);
+      pcn_data->pcn_remote_io_active = PCN_SERVER_INIT;
+    }
+
+  lio_rt_sigprocmask (SIG_BLOCK, NULL, (sigset_t *)&pcn_data->rio_sigmask,
+		      sizeof (long));
+  rio_dbg_printf ("pcn_server_sockfd = %u\n", pcn_data->pcn_server_sockfd);
+
+  if (pcn_data->rio_debug)
+    {
+      char ext[INET_ADDRSTRLEN];
+
+      inet_ntop (AF_INET, &pcn_data->pcn_server_ip, ext, INET_ADDRSTRLEN);
+      rio_dbg_printf ("%s: pcn_server_ip = %s, pcn_server_port = %d, pcn_server_sockfd = %d\n",
+		      __FUNCTION__, ext, pcn_data->pcn_server_port,
+		      pcn_data->pcn_server_sockfd);
+    }
+
+  //pcn_setup_sigerror (SIGSEGV);
+}
+
+/*
+ * At present, this function returns the first non-local IPv4 address
+ * on the machine calling it.  This may cause problems if the machine
+ * is multihomed.
+ */
+uint32_t
+pcn_get_ip (void)
+{
+  struct ifaddrs *myaddrs, *ifa;
+  void *in_addr;
+  uint32_t ip = 0;
+  uint32_t localhost = htonl (0x7f000001); /* 127.0.0.1  */
+  int t;
+
+  t = rio_disable ();
+  if(getifaddrs(&myaddrs) != 0)
+    {
+      perror("getifaddrs");
+      lio_exit (1);
+    }
+  rio_restore (t);
+
+  for (ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)
+    {
+      struct sockaddr_in *s4;
+
+      if (ifa->ifa_addr == NULL)
+	continue;
+      if (!(ifa->ifa_flags & IFF_UP))
+	continue;
+
+      if (ifa->ifa_addr->sa_family != AF_INET)
+	continue;
+
+      s4 = (struct sockaddr_in *)ifa->ifa_addr;
+      in_addr = &s4->sin_addr;
+      ip = *(long *) in_addr;
+
+      if (ip != localhost)
+	break;
+    }
+
+  t = rio_disable ();
+  freeifaddrs(myaddrs);
+  rio_restore (t);
+
+  return ip;
+}
+
+static int
+connect_to (uint32_t ip, uint16_t port)
+{
+  int sockfd, res;
+  struct addrinfo hints, *ai;
+  char s_addr[INET_ADDRSTRLEN], s_port[INET_ADDRSTRLEN];
+
+  memset (&hints, 0, sizeof hints);
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+
+  inet_ntop (AF_INET, &ip, s_addr, INET_ADDRSTRLEN);
+  snprintf (s_port, INET_ADDRSTRLEN, "%d", port);
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0) {
+    rio_dbg_printf ("getaddrinfo: %s\n", gai_strerror (res));
+    lio_exit (EXIT_FAILURE);
+  }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  if (pcn_data->rio_debug)
+    rio_dbg_printf ("connecting to %s:%s\n", s_addr, s_port);
+
+  sockfd = lio_socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      rio_disable ();
+      perror ("socket");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  if (lio_connect (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      rio_disable ();
+      perror ("connection failed");
+      rio_dbg_printf ("   -> %s:%s\n", s_addr, s_port);
+      lio_exit (EXIT_FAILURE);
+    }
+
+  return sockfd;
+}
+
+/* Fork the RIO server. The new RIO server will respond to the client
+   with the new port number, then unbind the exising port and listen
+   to messages on the new port number.  */
+static int
+do_fork_server (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct sockaddr_in sin;
+  socklen_t len = sizeof (sin);
+  int pid, sockfd, res = 0;
+  uint16_t port;
+
+  sockfd = get_server_socket ();
+  if (lio_getsockname(sockfd, (struct sockaddr *)&sin, &len) == -1)
+    {
+      rio_disable ();
+      perror("getsockname");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  port = ntohs (sin.sin_port);
+
+  pid = fork ();
+
+  if (pid == -1)
+    lio_error ("%s: fork failure\n", __FUNCTION__);
+  else if (pid > 0)
+    {
+      struct pcn_msg_res ack = { .id = hdr->msg_id, .res = port, .rio_errno = errno };
+      rio_msg_res (fd, &ack);
+
+      lio_close (sockfd);
+
+      rio_dbg_printf ("%s[%d]: forked port = %d, pid = %d\n",
+		      __FUNCTION__, hdr->msg_id, (int)port, pid);
+    }
+  else
+    {
+      /* New RIO server.  */
+      struct epoll_event e;
+
+      lio_close (pcn_data->rio_epollfd);
+      pcn_data->rio_epollfd = lio_epoll_create1 (0);
+      e.data.fd = sockfd;
+      e.events = EPOLLIN | EPOLLRDHUP | EPOLLHUP;
+      lio_epoll_ctl (pcn_data->rio_epollfd, EPOLL_CTL_ADD, sockfd, &e);
+
+      lio_close (fd);
+      lio_close (pcn_data->pcn_listen_sockfd);
+
+      pcn_data->rio_migrate_cnt = 0;
+      pcn_data->pcn_listen_sockfd = sockfd;
+      pcn_data->pcn_client_sockfd = 0;
+      pcn_data->pcn_server_port = port;
+      pcn_data->rio_my_pid = getpid ();
+      rio_dbg_printf ("%s[%d]: new server port = %d\n",
+		      __FUNCTION__, hdr->msg_id, (int)port);
+    }
+
+  res = PCN_RES_FORK;
+
+  return res;
+}
+
+void
+do_rio_server_migrate (struct pcn_msg_hdr *hdr, int fd)
+{
+  int status;
+
+  rio_msg_ack (fd, hdr, 0);
+  lio_epoll_ctl (pcn_data->rio_epollfd, EPOLL_CTL_DEL, fd, NULL);
+  lio_close (fd);
+
+  rio_dbg_printf ("%s: received migration request\n", __FUNCTION__);
+  pcn_data->rio_migrate_pending = 1;
+  pcn_data->rio_migrate_cnt++;
+  pcn_data->pcn_client_sockfd = -1;
+
+  if (pcn_data->rio_migrate_cnt == 1)
+    waitpid (pcn_data->rio_child_pid, &status, 0);
+}
+
+void
+do_rio_server_exec (void)
+{
+  rio_dbg_printf ("%s: received exec request\n", __FUNCTION__);
+  pcn_data->rio_migrate_pending = 1;
+  pcn_data->rio_migrate_cnt++;
+}
+
+void
+do_rio_server_attach (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res res = { .id = hdr->msg_id, .rio_errno = errno, .res = 0 };
+  int pid;
+
+  rio_msg_get (fd, &pid, sizeof (int));
+  rio_dbg_printf ("%s: attached to remote client -- pid = %d\n",
+		  __FUNCTION__, pid);
+  pcn_data->rio_child_pid = pid;
+  pcn_data->rio_migrate_pending = 0;
+  rio_set_servername ();
+  rio_msg_res (fd, &res);
+}
+
+static int
+do_control (struct pcn_msg_hdr *hdr, int fd)
+{
+  int res = 0;
+
+  if (pcn_data->pcn_local_ip != pcn_data->pcn_server_ip) {
+    lio_write (pcn_data->pcn_server_ip, hdr, sizeof (struct pcn_msg_hdr));
+    return res;
+  }
+
+  switch (hdr->msg_kind) {
+  case PCN_CTL_MIGRATE:
+    do_rio_server_migrate (hdr, fd);
+    break;
+
+  case PCN_CTL_ATTACH:
+    do_rio_server_attach (hdr, fd);
+    break;
+
+  case PCN_CTL_FORK:
+    res = do_fork_server (hdr, fd);
+    break;
+
+  case PCN_CTL_EXEC:
+    do_rio_server_exec ();
+    break;
+
+  case PCN_CTL_RESTART_DISABLED:
+    rio_restart_disabled ();
+    break;
+
+  default:
+    ;
+  }
+
+  return res;
+}
+
+static int
+do_syscall (struct pcn_msg_hdr *hdr, int fd)
+{
+  if (0 && pcn_data->rio_debug) {
+    char s_addr[INET_ADDRSTRLEN], l_addr[INET_ADDRSTRLEN];
+
+    inet_ntop (AF_INET, &pcn_data->pcn_server_ip, s_addr, INET_ADDRSTRLEN);
+    inet_ntop (AF_INET, &pcn_data->pcn_local_ip, l_addr, INET_ADDRSTRLEN);
+
+    rio_dbg_printf ("%s: %s -> %s\n", __FUNCTION__, s_addr, l_addr);
+  }
+
+  switch (hdr->msg_kind) {
+  case PCN_SYS_OPEN:
+    rio_get_open (hdr, fd);
+    break;
+
+  case PCN_SYS_CLOSE:
+    rio_get_close (hdr, fd);
+    break;
+
+  case PCN_SYS_WRITE:
+    rio_get_write (hdr, fd);
+    break;
+
+  case PCN_SYS_READ:
+  case PCN_SYS_PREAD:
+    rio_get_read (hdr, fd);
+    break;
+
+  case PCN_SYS_FXSTATAT:
+    rio_get_fxstatat (hdr, fd);
+    break;
+
+  case PCN_SYS_MMAP:
+    rio_get_mmap (hdr, fd);
+    break;
+
+  case PCN_SYS_MUNMAP:
+    rio_get_munmap (hdr, fd);
+    break;
+
+  case PCN_SYS_EPOLL_CREATE:
+    rio_get_epoll_create (hdr, fd);
+    break;
+
+  case PCN_SYS_EPOLL_CTL:
+    rio_get_epoll_ctl (hdr, fd);
+    break;
+
+  case PCN_SYS_EPOLL_WAIT:
+    rio_get_epoll_wait (hdr, fd);
+    break;
+
+  case PCN_SYS_FALLOCATE:
+    rio_get_fallocate (hdr, fd);
+    break;
+
+  case PCN_SYS_RT_SIGACTION:
+    rio_get_sigaction (hdr, fd);
+    break;
+
+  case PCN_SYS_FCNTL:
+    rio_get_fcntl (hdr, fd);
+    break;
+
+  case PCN_SYS_GETCWD:
+    rio_get_getcwd (hdr, fd);
+    break;
+
+  case PCN_SYS_PIPE:
+    rio_get_pipe (hdr, fd);
+    break;
+
+  case PCN_SYS_SOCKET:
+    rio_get_socket (hdr, fd);
+    break;
+
+  case PCN_SYS_GETSOCKOPT:
+    rio_get_getsockopt (hdr, fd);
+    break;
+
+  case PCN_SYS_SETSOCKOPT:
+    rio_get_setsockopt (hdr, fd);
+    break;
+
+  case PCN_SYS_BIND:
+    rio_get_bind (hdr, fd);
+    break;
+
+  case PCN_SYS_LISTEN:
+    rio_get_listen (hdr, fd);
+    break;
+
+  case PCN_SYS_ACCEPT:
+    rio_get_accept (hdr, fd);
+    break;
+
+  case PCN_SYS_CONNECT:
+    rio_get_connect (hdr, fd);
+    break;
+
+  case PCN_SYS_POLL:
+  case PCN_SYS_PPOLL:
+    rio_get_poll (hdr, fd);
+    break;
+
+  case PCN_SYS_ACCESS:
+    rio_get_access (hdr, fd);
+    break;
+
+  case PCN_SYS_UNAME:
+    rio_get_uname (hdr, fd);
+    break;
+
+  case PCN_SYS_GETPEERNAME:
+  case PCN_SYS_GETSOCKNAME:
+    rio_get_sock_getname (hdr, fd);
+    break;
+
+  case PCN_SYS_RECVFROM:
+    rio_get_recvfrom (hdr, fd);
+    break;
+
+  case PCN_SYS_RECVMSG:
+    rio_get_recvmsg (hdr, fd);
+    break;
+
+  case PCN_SYS_SEND:
+    rio_get_send (hdr, fd);
+    break;
+
+  case PCN_SYS_SENDTO:
+    rio_get_sendto (hdr, fd);
+    break;
+
+  case PCN_SYS_DUP:
+  case PCN_SYS_DUP2:
+  case PCN_SYS_DUP3:
+    rio_get_dup (hdr, fd);
+    break;
+
+  case PCN_SYS_GETDENTS64:
+    rio_get_getdents64 (hdr, fd);
+    break;
+
+  case PCN_SYS_CHDIR:
+    rio_get_chdir (hdr, fd);
+    break;
+
+  case PCN_SYS_CHMOD:
+    rio_get_chmod (hdr, fd);
+    break;
+
+  case PCN_SYS_FDATASYNC:
+  case PCN_SYS_FSYNC:
+    rio_get_sync (hdr, fd);
+    break;
+
+  case PCN_SYS_FTRUNCATE64:
+    rio_get_ftruncate64 (hdr, fd);
+    break;
+
+  case PCN_SYS_TRUNCATE64:
+    rio_get_truncate64 (hdr, fd);
+    break;
+
+  case PCN_SYS_LINK:
+    rio_get_link (hdr, fd);
+    break;
+
+  case PCN_SYS_UNLINK:
+    rio_get_unlink (hdr, fd);
+    break;
+
+  case PCN_SYS_SYMLINK:
+    rio_get_symlink (hdr, fd);
+    break;
+
+  case PCN_SYS_READLINK:
+    rio_get_readlink (hdr, fd);
+    break;
+
+  case PCN_SYS_MKDIR:
+    rio_get_mkdir (hdr, fd);
+    break;
+
+  case PCN_SYS_RMDIR:
+    rio_get_rmdir (hdr, fd);
+    break;
+
+  case PCN_SYS_RENAME:
+    rio_get_rename (hdr, fd);
+    break;
+
+  case PCN_SYS_UMASK:
+    rio_get_umask (hdr, fd);
+    break;
+
+  case PCN_SYS_LSEEK:
+    rio_get_lseek64 (hdr, fd);
+    break;
+
+  case PCN_SYS_SYNC_FILE_RANGE:
+    rio_get_sync_file_range (hdr, fd);
+    break;
+
+  case PCN_SYS_KILL:
+    rio_get_kill (hdr, fd);
+    break;
+
+  case PCN_SYS_EPOLL_PWAIT:
+    rio_get_epoll_pwait (hdr, fd);
+    break;
+
+  case PCN_SYS_SELECT:
+    rio_get_select (hdr, fd);
+    break;
+
+  case PCN_SYS_PSELECT:
+    rio_get_pselect (hdr, fd);
+    break;
+
+  case PCN_SYS_PWRITE:
+    rio_get_write (hdr, fd);
+    break;
+
+  case PCN_SYS_STATFS:
+    rio_get_statfs (hdr, fd);
+    break;
+
+  case PCN_SYS_FSTATFS:
+    rio_get_fstatfs (hdr, fd);
+    break;
+
+  case PCN_SYS_SETITIMER:
+    rio_get_setitimer (hdr, fd);
+    break;
+
+  case PCN_SYS_GETITIMER:
+    rio_get_getitimer (hdr, fd);
+    break;
+
+  case PCN_SYS_SIGNALFD:
+    rio_get_signalfd (hdr, fd);
+    break;
+
+  default:
+    ;
+  }
+
+  return 0;
+}
+
+/* Returns 1 if a client has been dropped.  */
+static int
+process_message (int fd)
+{
+  struct pcn_msg_hdr hdr;
+  int res;
+
+  res = lio_read (fd, &hdr, sizeof (hdr));
+
+  if (res == 0) {
+    if (!pcn_data->rio_migrate_pending) {
+      rio_dbg_printf ("client hung up... terminating\n");
+      lio_exit (EXIT_SUCCESS);
+    }
+
+    rio_dbg_printf ("client hung up\n");
+
+    return 1;
+  }
+
+  if (res < sizeof (hdr))
+    lio_error ("something went wrong - malformed message (%u)\n", fd);
+
+  switch (hdr.msg_type) {
+  case PCN_TYPE_CONTROL:
+    res = do_control (&hdr, fd);
+    break;
+
+  case PCN_TYPE_SYSCALL:
+    res = do_syscall (&hdr, fd);
+    break;
+
+  default:
+    lio_error ("unexpected message type: %u\n", hdr.msg_type);
+    ;
+  }
+
+  return res;
+}
+
+static int
+rio_establish_connection (void)
+{
+  struct sockaddr_storage remoteaddr;
+  socklen_t addrlen = sizeof (remoteaddr);
+  struct epoll_event e;
+
+  pcn_data->pcn_client_sockfd = lio_accept (pcn_data->pcn_listen_sockfd,
+					    (struct sockaddr *)&remoteaddr,
+					    &addrlen);
+
+  if (pcn_data->pcn_client_sockfd < 0)
+    {
+      rio_disable ();
+      perror ("failed to accept client");
+      lio_exit (EXIT_FAILURE);
+    }
+  else {
+    char buf[INET_ADDRSTRLEN];
+    struct sockaddr_in *sin = (struct sockaddr_in *)&remoteaddr;
+
+    if (pcn_data->rio_debug) {
+      inet_ntop (remoteaddr.ss_family, &sin->sin_addr, buf,
+		 INET_ADDRSTRLEN);
+      rio_dbg_printf ("%s: accepted client %s, fd = %d\n", __FUNCTION__, buf,
+                      pcn_data->pcn_client_sockfd);
+    }
+
+    e.data.fd = pcn_data->pcn_client_sockfd;
+    e.events = EPOLLIN | EPOLLRDHUP | EPOLLHUP;
+    lio_epoll_ctl (pcn_data->rio_epollfd, EPOLL_CTL_ADD, e.data.fd, &e);
+    pcn_data->rio_migrate_pending = 0;
+  }
+
+  return pcn_data->pcn_client_sockfd;
+}
+
+void
+rio_client_hangup (int sockfd)
+{
+  assert (sockfd == pcn_data->pcn_client_sockfd);
+  // terminate server if client necessary
+  // FIXME: this is detected by receiving 0 bytes
+
+  if (pcn_data->rio_debug)
+    rio_dbg_printf ("client disconnected... shutting down\n");
+
+  lio_exit (EXIT_SUCCESS);
+}
+
+static void
+remote_io_server (void)
+{
+  /* There are at most two socket descriptors to keep track of:
+   *   1: The listener socket
+   *   2: The socket to the client
+   *
+   * The listener socket is planced in pfds[0]. The socket to the
+   * client will be placed in pfds[1].
+   */
+  struct epoll_event events[PCN_MAX_EVENTS] = { 0 }, e;
+  int epfd;
+
+  pcn_data->pcn_local_ip = pcn_get_ip ();
+
+  epfd = lio_epoll_create1 (0);
+  pcn_data->rio_epollfd = epfd;
+
+  e.events = EPOLLIN | EPOLLRDHUP | EPOLLHUP;
+  e.data.fd = pcn_data->pcn_listen_sockfd;
+  lio_epoll_ctl (epfd, EPOLL_CTL_ADD, e.data.fd, &e);
+
+  while (1) {
+    int migration_cnt = pcn_data->rio_migrate_cnt;
+    int poll_count;
+    int i;
+
+    /* Eventually, this should wait on multiple events, but because the
+       forwarded epoll, poll, and select system calls are interruptible,
+       this is going to require more coordination.  */
+    poll_count = lio_epoll_wait (epfd, events, 1, -1);
+
+    if (poll_count == -1 && pcn_data->rio_child_pid == -100)
+      pcn_data->rio_child_pid = -1;
+    else if (poll_count == -1)
+      {
+	/* A signal may have been forwarded, so retry.  */
+	if (errno == EINTR)
+	  continue;
+
+	rio_disable ();
+	perror ("epoll_wait");
+	lio_error ("%s: epoll_wait failure\n", __FUNCTION__);
+      }
+
+    for (i = 0; i < poll_count; i++) {
+      if (events[i].events & (EPOLLHUP | EPOLLRDHUP)) {
+	rio_client_hangup (events[i].data.fd);
+      } else if (events[i].events & EPOLLIN) {
+	int cfd = events[i].data.fd;
+	int res;
+
+	if (cfd != pcn_data->pcn_listen_sockfd) {
+	  res = process_message (cfd);
+
+	  if (res == 1) {
+            LIO_ASSERT (cfd == pcn_data->pcn_client_sockfd,
+                        "Unexpected client");
+
+	    pcn_data->pcn_client_sockfd = -1;
+	    e.data.fd = cfd;
+	    lio_epoll_ctl (epfd, EPOLL_CTL_DEL, cfd, &e);
+            lio_close (cfd);
+	  } else if (res == PCN_RES_FORK) {
+	    //lio_spin ();
+	    break;
+	  } else if (migration_cnt != pcn_data->rio_migrate_cnt) {
+	    rio_dbg_printf ("%s: migration detected\n", __FUNCTION__);
+	    pcn_data->pcn_client_sockfd = events[i].data.fd;
+	    e.data.fd = events[i].data.fd;
+	    lio_epoll_ctl (epfd, EPOLL_CTL_ADD, e.data.fd, &e);
+	    break;
+	  }
+
+	  continue;
+	}
+
+	rio_establish_connection ();
+      }
+    }
+  }
+
+  if (pcn_data->pcn_server_ip != pcn_data->pcn_local_ip)
+    ; // coordinate shutdown
+  lio_exit (EXIT_SUCCESS);
+}
+
+int
+get_server_socket (void)
+{
+  struct addrinfo hints, *ai;
+  int res, state, sockfd;
+  char buf[INET_ADDRSTRLEN], *s_addr = NULL, *s_port = NULL;
+
+  inet_ntop (AF_INET, &pcn_data->pcn_server_ip, buf, sizeof (buf));
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  state = rio_disable ();
+  s_addr = buf;
+  s_port = NULL;
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0) {
+    rio_dbg_printf ("getaddrinfo: %s\n", gai_strerror (res));
+    lio_exit (EXIT_FAILURE);
+  }
+  rio_restore (state);
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = lio_socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      rio_disable ();
+      perror ("socket");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  if (lio_bind (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      rio_disable ();
+      lio_close (sockfd);
+      perror ("bind");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  if (lio_listen (sockfd, 2) == -1)
+    {
+      rio_disable ();
+      perror ("listen");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  freeaddrinfo (ai);
+
+  return sockfd;
+}
+
+/*
+ * Connect to the I/O server.
+ *
+ * A Popcorn application may be launched on machine A and
+ * checkpoint/restored onto a machine B. Note that machines A and B
+ * may be the same machine, e.g. Application launched on A, migrates
+ * over to B, then migrates back to A.
+ *
+ * A Popcorn application has at most two servers, a server running on
+ * the local host and the primary server running on the machine that
+ * originally launched the Popcorn application. The secondary server
+ * on a remote machine is necessary to handle signal forwarding
+ * without introducing additional threads into the Popcorn
+ * application. Communication between the Popcorn application and a
+ * server running on the same machine is conducted via local network.
+ *
+ * A new server is spawned in two cases:
+ *   1) When the Popcorn application is first launched on Machine A.
+ *   2) When the Popcorn application has migrated to Machine B != A.
+ *
+ * This function is responsible for setting up a server if necessary.
+ * It returns a socket descriptor to the local server.
+ */
+int
+do_pcn_server_connect (uint32_t ip)
+{
+  int sockfd = -1;
+  struct sockaddr_in sin;
+  socklen_t len = sizeof (sin);
+  int state;
+  uint32_t myip = pcn_get_ip ();
+
+  dump_pcn_data ();
+  rio_dbg_printf ("entering %s\n", __FUNCTION__);
+  //rio_dbg_printf ("%s: myip = %lx\n", __FUNCTION__, myip);
+
+  if (pcn_data->pcn_remote_io_active == PCN_SERVER_READY)
+    return connect_to (pcn_data->pcn_server_ip,
+		       pcn_data->pcn_server_port);
+
+  /* Disable the secondary server after migration.  */
+  pcn_data->pcn_remote_io_active = PCN_SERVER_READY;
+  pcn_data->pcn_server_ip = myip;
+  pcn_data->pcn_local_ip = myip;
+
+  sockfd = get_server_socket ();
+
+  if (lio_getsockname(sockfd, (struct sockaddr *)&sin, &len) == -1)
+    {
+      rio_disable ();
+      perror("getsockname");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  pcn_data->pcn_server_port = ntohs (sin.sin_port);
+
+  state = rio_disable ();
+  pcn_data->rio_child_pid = fork ();
+
+  if (pcn_data->rio_child_pid != 0) {
+    rio_set_servername ();
+
+    pcn_mode = 1;
+
+    /* Don't want to foward system calls on the server.  */
+    pcn_data->pcn_remote_io_active = 0;
+
+    rio_forward_signals ();
+    rio_fd_init_special ();
+
+    /* Run the application on the fork'ed process so that CRIU
+       does not attempt to suspend the server. Eventually, this
+       might need to use a standalone server.  */
+
+    pcn_data->pcn_listen_sockfd = sockfd;
+    remote_io_server ();   /* Never return.  */
+  } else {
+    pcn_sig_rio_init ();
+    pcn_data->rio_my_pid = getpid ();
+  }
+
+  rio_restore (state);
+  lio_close (sockfd);
+
+  /* Close STDIN so that the server can use it.  */
+  lio_close (STDIN_FILENO);
+
+  /* Return a socket to the server running on the local machine.  */
+  return connect_to (pcn_data->pcn_server_ip,
+		     pcn_data->pcn_server_port);
+}
+
+int
+pcn_server_connect (uint32_t ip)
+{
+  char buf[INET_ADDRSTRLEN];
+  struct pcn_msg_hdr hdr;
+  struct iovec payload;
+  int pid = getpid ();
+
+  hdr.msg_type = PCN_TYPE_CONTROL;
+  hdr.msg_kind = PCN_CTL_ATTACH;
+  hdr.msg_id = rio_msg_id ();
+  hdr.msg_async = PCN_SEND_SYNC;
+  hdr.msg_size = sizeof (hdr);
+
+  payload.iov_base = &pid;
+  payload.iov_len = sizeof (pid);
+
+  pcn_data->pcn_remote_io_active = PCN_SERVER_READY;
+
+  rio_disable_signals ();
+  pcn_data->pcn_local_ip = pcn_get_ip ();
+  inet_ntop (AF_INET, &pcn_data->pcn_server_ip, buf, INET_ADDRSTRLEN);
+  pcn_data->pcn_server_sockfd = do_pcn_server_connect (pcn_data->pcn_server_ip);
+  rio_msg_send_iov (pcn_data->pcn_server_sockfd, &hdr, &payload, 1);
+  rio_enable_signals ();
+
+  rio_dbg_printf ("pcn remote server = %s:%u, connected with fd = %d\n", buf,
+		  pcn_data->pcn_server_port, pcn_data->pcn_server_sockfd);
+
+  return pcn_data->pcn_server_sockfd;
+}
+
+int
+pcn_server_attach (int port)
+{
+  lio_close (pcn_data->pcn_server_sockfd);
+  pcn_data->rio_my_pid = getpid ();
+  rio_dbg_printf ("%s: port = %d\n", __FUNCTION__, port);
+  pcn_data->pcn_server_port = port;
+  return pcn_server_connect (0);
+}
+
+/* Launch a server without forking a new process for testing purposes.  */
+void
+pcn_start_server (void)
+{
+  uint32_t myip = pcn_get_ip ();
+  int res, sockfd = -1;
+  struct addrinfo hints, *ai;
+  uint16_t port = pcn_data->pcn_server_port;
+  char buf[INET_ADDRSTRLEN], *s_addr = NULL, *s_port = NULL;
+
+  memset (&hints, 0, sizeof (hints));
+  hints.ai_family = AF_INET;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  snprintf (buf, INET_ADDRSTRLEN, "%d", pcn_data->pcn_server_port);
+  s_port = buf;
+
+  if ((res = getaddrinfo (s_addr, s_port, &hints, &ai)) != 0) {
+    rio_dbg_printf ("getaddrinfo: %s\n", gai_strerror (res));
+    exit (EXIT_FAILURE);
+  }
+
+  assert (ai != NULL && ai->ai_family == AF_INET);
+
+  sockfd = lio_socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+  if (sockfd < 0)
+    {
+      perror ("socket");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  if (lio_bind (sockfd, ai->ai_addr, ai->ai_addrlen) == -1)
+    {
+      rio_disable ();
+      lio_close (sockfd);
+      perror ("bind");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  if (pcn_data->pcn_server_ip == 0)
+    {
+      pcn_data->pcn_server_ip = myip;
+      pcn_data->pcn_server_port = port;
+    }
+
+  if (lio_listen (sockfd, 2) == -1)
+    {
+      rio_disable ();
+      perror ("listen");
+      lio_exit (EXIT_FAILURE);
+    }
+
+  freeaddrinfo (ai);
+
+  pcn_data->pcn_listen_sockfd = sockfd;
+
+  remote_io_server ();
+}
+
+/* Similar to rio_msg_get, but allow the client allow the client to
+   disconnect and reconect, hence updating sockfd.  */
+int
+rio_msg_get_robust (int *sockfd, void *buf, int size)
+{
+  struct epoll_event events[PCN_MAX_EVENTS];
+
+  while (1) {
+    int poll_count;
+    int i;
+
+    /* Eventually, this should wait on multiple events, but because the
+       forwarded epoll, poll, and select system calls are interruptible,
+       this is going to require more coordination.  */
+    poll_count = lio_epoll_wait (pcn_data->rio_epollfd, events, 1, -1);
+
+    if (poll_count == -1)
+      {
+	/* A signal may have been forwarded, so retry.  */
+	if (errno == EINTR)
+	  continue;
+
+	rio_disable ();
+	perror ("epoll_wait");
+	lio_error ("%s: poll failure\n", __FUNCTION__);
+      }
+
+    for (i = 0; i < poll_count; i++) {
+      if (events[i].events & (EPOLLHUP | EPOLLRDHUP)) {
+	rio_client_hangup (events[i].data.fd);
+      } else if (events[i].events & EPOLLIN) {
+	if (events[i].data.fd != pcn_data->pcn_listen_sockfd)
+	  return rio_msg_get (*sockfd, buf, size);
+
+	*sockfd = rio_establish_connection ();
+      }
+    }
+  }
+
+  return -1;
+}
diff --git a/remote_io/rio_signals.c b/remote_io/rio_signals.c
new file mode 100644
index 0000000000..ad2c76ed77
--- /dev/null
+++ b/remote_io/rio_signals.c
@@ -0,0 +1,209 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <errno.h>
+#include <termios.h>
+#include <limits.h>
+#include <assert.h>
+
+#include <kernel_sigaction.h>
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static long rio_sigmask;
+
+void
+rio_disable_signals (void)
+{
+  int t = ++pcn_data->rio_active_calls;
+  unsigned long mask = ULONG_MAX;
+
+  if (t > 1)
+    return;
+
+  lio_rt_sigprocmask (SIG_BLOCK, (sigset_t *)&mask,
+		      (sigset_t *)&rio_sigmask, sizeof (long));
+}
+
+void
+rio_enable_signals (void)
+{
+  int t = --pcn_data->rio_active_calls;
+
+  if (t > 0)
+    return;
+
+  lio_rt_sigprocmask (SIG_SETMASK, (sigset_t *)&rio_sigmask,
+		      NULL, sizeof (long));
+
+#if 0
+  rio_dbg_printf ("%s: old_mask = %lx, new_mask = %lx\n",
+		  __FUNCTION__, old, pcn_data->rio_sigmask);
+#endif
+}
+
+void
+rio_signal_forwarder (int sig, siginfo_t *si, void *arg)
+{
+  struct pcn_msg_signal msg;
+  struct sockaddr addr = { 0 };
+  struct sockaddr_in *client;
+  socklen_t addrlen = sizeof (struct sockaddr_in);
+  uint32_t myip = pcn_data->pcn_server_ip;
+  uint32_t lip = 0x100007f; /* 127.0.0.1  */
+  uint32_t cip;
+  int sockfd;
+
+  /* Check if there is a pending mild and the RIO server received a SIGCHLD.
+     The SIGCHLD indicates that criu dumped and killed off the client.  */
+  if (sig == SIGCHLD && pcn_data->rio_migrate_pending)
+    {
+      int status;
+
+      waitpid (-1, &status, 0);
+
+      return;
+    }
+
+  if (pcn_data->rio_migrate_pending)
+    {
+      rio_dbg_printf ("%s: ignoring signal '%d' for pending migration\n",
+		      __FUNCTION__, sig);
+      return;
+    }
+
+  lio_getpeername (pcn_data->pcn_client_sockfd, &addr, &addrlen);
+  client = (struct sockaddr_in *)&addr;
+
+  cip = *(long *)&(client->sin_addr);
+
+  //dump_pcn_data ();
+
+  if (cip == myip || cip == lip)
+    {
+      rio_dbg_printf ("%s: not forwarding signal '%d'to local process group\n",
+		      __FUNCTION__, sig);
+      return;
+    }
+
+  if (rio_debug ())
+    {
+      char cbuf[INET_ADDRSTRLEN], sbuf[INET_ADDRSTRLEN];
+
+      lio_inet_ntop (AF_INET, &cip, cbuf, INET_ADDRSTRLEN);
+      lio_inet_ntop (AF_INET, &myip, sbuf, INET_ADDRSTRLEN);
+
+      rio_dbg_printf ("%s: forwarding signal '%u' to pid '%u' with IP '%s' (myip = %s)\n",
+		      __FUNCTION__, sig, pcn_data->rio_child_pid, cbuf, sbuf);
+    }
+
+  msg.pid = pcn_data->rio_child_pid;
+  msg.sig = sig;
+  msg.type = PCN_SIG_KILL;
+
+  sockfd = lio_socket (AF_INET, SOCK_STREAM, 0);
+  if (sockfd < 0)
+    {
+      rio_dbg_printf ("%s: error: errno = %d\n", __FUNCTION__, errno);
+      lio_exit (EXIT_FAILURE);
+    }
+
+  client->sin_family = AF_INET;
+  client->sin_port = htons (POPCORN_KILLD_PORT);
+
+  if (connect (sockfd, client, sizeof (struct sockaddr_in)) == -1)
+    {
+      rio_dbg_printf ("%s: error: connection failed, dropping signal %d -- errno = %d\n",
+		      __FUNCTION__, sig, errno);
+      lio_close (sockfd);
+      return;
+    }
+
+  lio_write (sockfd, &msg, sizeof (msg));
+  lio_close (sockfd);
+}
+
+static void
+do_sigchld (int sig, siginfo_t *si, void *arg)
+{
+  int status;
+
+  // FWD
+  //int pid = lio_wait4 (-1, &status, 0, NULL);
+  lio_wait4 (-1, &status, 0, NULL);
+
+  /* There might be multiple children, i.e. when the RIO server forks.  */
+  //assert (pid == pcn_data->rio_child_pid);
+  //pcn_data->rio_child_pid = -100;
+}
+
+void rio_sig_forward_mask (unsigned long mask)
+{
+  struct sigaction sa, *rsa;
+  int i;
+
+  if (pcn_data->rio_sigaction == NULL)
+    pcn_data->rio_sigaction = lio_malloc (sizeof (struct sigaction) * 64);
+
+  rsa = (struct sigaction *)pcn_data->rio_sigaction;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = SA_SIGINFO;
+
+  /* Don't call lio_rt_sigaction directly, because glibc
+     needs to set sa_restorer.  */
+
+  for (i = 0; i < 64; i++)
+    {
+      if ((mask & (1<<i)) == 0)
+	continue;
+
+      if (i+1 == SIGCHLD)
+	{
+	  sa.sa_sigaction = do_sigchld;
+	  continue;
+	}
+      else
+	sa.sa_sigaction = rio_signal_forwarder;
+
+      sigaction (i+1, &sa, &rsa[i]);
+    }
+}
+
+void
+rio_forward_signals (void)
+{
+  rio_sig_forward_mask (-1L);
+}
+
+void
+rio_sig_restore_mask (unsigned long mask)
+{
+  struct sigaction *rsa = pcn_data->rio_sigaction;
+  int i;
+
+  for (i = 0; i < 64; i++)
+    {
+      if ((mask & (1<<i)) == 0)
+	continue;
+
+      if (i+1 == SIGCHLD)
+	continue;
+
+      sigaction (i+1, &rsa[i], NULL);
+    }
+}
+
+int
+rio_signal_pending (void)
+{
+  unsigned long sigmask = 0;
+
+  lio_sigpending ((sigset_t *)&sigmask);
+
+  return sigmask;
+}
diff --git a/remote_io/rio_sys_accept.c b/remote_io/rio_sys_accept.c
new file mode 100644
index 0000000000..b70e9416cb
--- /dev/null
+++ b/remote_io/rio_sys_accept.c
@@ -0,0 +1,50 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_accept (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_bind *msg;
+  socklen_t len;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res < hdr->msg_size)
+    lio_error ("%s[%u]: failed to receive accept message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  len = msg->addrlen;
+  errno = hdr->msg_errno;
+  msg->sockfd = lio_accept_raw (msg->sockfd, (void *)msg->addr,
+				&len);
+  msg->addrlen = len;
+  msg->rio_errno = errno;
+
+  if (msg->sockfd >= 0)
+    rio_fd_open_special (msg->sockfd, RIO_FD_ACCEPT);
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %d\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->addr,
+		  msg->addrlen);
+
+  rio_msg_send_raw (fd, msg, hdr->msg_size);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_access.c b/remote_io/rio_sys_access.c
new file mode 100644
index 0000000000..eefb472b85
--- /dev/null
+++ b/remote_io/rio_sys_access.c
@@ -0,0 +1,46 @@
+/* open system call forwarding -- open, creat, and openat  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_access (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_open *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+
+  res.res = rio_msg_get (fd, msg, hdr->msg_size);
+
+  errno = hdr->msg_errno;
+  res.res = lio_access (msg->pathname, msg->mode);
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  rio_fd_open (res.res, msg->flags, msg->mode, msg->pathname);
+
+  rio_dbg_printf ("%s[%u]: pathname = %s, mode = %x -> res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg->pathname, msg->mode,
+	      res.res, res.rio_errno);
+
+  free (msg);
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_bind.c b/remote_io/rio_sys_bind.c
new file mode 100644
index 0000000000..c83a564845
--- /dev/null
+++ b/remote_io/rio_sys_bind.c
@@ -0,0 +1,47 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_bind (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_bind *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive bind message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_bind_raw (msg->sockfd, (void *)msg->addr, msg->addrlen);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %d\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->addr,
+		  msg->addrlen);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_chdir.c b/remote_io/rio_sys_chdir.c
new file mode 100644
index 0000000000..7a0b275180
--- /dev/null
+++ b/remote_io/rio_sys_chdir.c
@@ -0,0 +1,15 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+#include "rio_common_dir.h"
+
+int
+rio_get_chdir (struct pcn_msg_hdr *hdr, int fd)
+{
+  return rio_common_dir (hdr, fd);
+}
diff --git a/remote_io/rio_sys_chmod.c b/remote_io/rio_sys_chmod.c
new file mode 100644
index 0000000000..38d147167b
--- /dev/null
+++ b/remote_io/rio_sys_chmod.c
@@ -0,0 +1,36 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_chmod (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_chmod *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s: failed to receive message from client (%d -> %d, errno = %d)\n",
+               __FUNCTION__, hdr->msg_size, res, errno);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_chmod (msg->file, msg->mode);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: file = %s, mode = %x -- res = %d, errno = %d\n",
+                  __FUNCTION__, hdr->msg_id, msg->file, msg->mode,
+                  ack.res, ack.rio_errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  return res - sizeof (ack);
+}
diff --git a/remote_io/rio_sys_close.c b/remote_io/rio_sys_close.c
new file mode 100644
index 0000000000..bd7861f483
--- /dev/null
+++ b/remote_io/rio_sys_close.c
@@ -0,0 +1,57 @@
+/* open system call forwarding -- open, creat, and openat  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_close (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_close msg;
+  struct pcn_msg_res res;
+  struct fdinfo *fdp;
+  struct file_info *fi;
+  int rclose;
+
+  rio_msg_get (fd, &msg, sizeof (msg));
+
+  lio_assert_empty_socket (fd);
+
+  fdp = rio_fd_find (msg.fd);
+  if (fdp == NULL)
+    lio_error ("%s[%u]: ERROR: missing data for fd = %u\n",
+	       __FUNCTION__, hdr->msg_id, msg.fd);
+
+  fi = fdp->fi;
+
+  if (fi->type == RIO_FD_SIGNALFD)
+    rio_sig_forward_mask (fi->arg);
+
+  errno = hdr->msg_errno;
+  rclose = lio_close (msg.fd);
+
+  rio_dbg_printf ("%s[%u]: closing '%s', fd = %d (refcount = %d) -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, fi->name, fdp->fd, fi->refcount, rclose, errno);
+
+  res.rio_errno = errno;
+  res.res = rclose;
+  res.id = hdr->msg_id;
+
+  rio_fd_close (fdp, fd, hdr->msg_id);
+  rio_msg_res (fd, &res);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_connect.c b/remote_io/rio_sys_connect.c
new file mode 100644
index 0000000000..9e8793c92f
--- /dev/null
+++ b/remote_io/rio_sys_connect.c
@@ -0,0 +1,47 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_connect (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_bind *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive bind message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_connect (msg->sockfd, (void *)msg->addr, msg->addrlen);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, addr = %lx, addrlen = %u -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg->sockfd, msg->addr,
+	      msg->addrlen, ack.res, errno);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_dup.c b/remote_io/rio_sys_dup.c
new file mode 100644
index 0000000000..e3e40b4941
--- /dev/null
+++ b/remote_io/rio_sys_dup.c
@@ -0,0 +1,74 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_dup (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  int oldfd, newfd, flags = 0;
+  struct fdinfo *pfd;
+
+  rio_msg_get (fd, &oldfd, sizeof (int));
+  
+  errno = hdr->msg_errno;
+
+  switch (hdr->msg_kind)
+    {
+      case PCN_SYS_DUP:
+        ack.res = lio_dup (oldfd);
+        break;
+
+      case PCN_SYS_DUP2:
+      case PCN_SYS_DUP3:
+        rio_msg_get (fd, &newfd, sizeof (int));
+
+        if (hdr->msg_kind == PCN_SYS_DUP3)
+          rio_msg_get (fd, &flags, sizeof (int));
+
+        /* Close dup_fd if it is already open for dup2. */
+        pfd = rio_fd_find (newfd);
+        if (pfd)
+          {
+            lio_close (newfd);
+            rio_fd_close (pfd, fd, hdr->msg_id);
+          }
+
+        if (hdr->msg_kind == PCN_SYS_DUP2)
+          ack.res = lio_dup2 (oldfd, newfd);
+        else
+          ack.res = lio_dup3 (oldfd, newfd, flags);
+        break;
+
+      default:
+        lio_error ("%s: unexpected syscall", __FUNCTION__);
+    }
+
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_fd_dup (oldfd, ack.res);
+
+  if (hdr->msg_kind == PCN_SYS_DUP)
+    rio_dbg_printf ("%s[%u]: fd = %d -- res = %d\n",
+		    __FUNCTION__, hdr->msg_id, oldfd, ack.res);
+  else
+    rio_dbg_printf ("%s[%u]: oldfd = %d, newfd = %d, flags = %d -- res = %d\n",
+		    __FUNCTION__, hdr->msg_id, oldfd, newfd, flags, ack.res);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_epoll.c b/remote_io/rio_sys_epoll.c
new file mode 100644
index 0000000000..51423ba994
--- /dev/null
+++ b/remote_io/rio_sys_epoll.c
@@ -0,0 +1,195 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/epoll.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_epoll_create (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res res;
+
+  errno = hdr->msg_errno;
+  res.res = lio_epoll_create1 (0);
+  res.rio_errno = errno;
+
+  if (res.res >= 0)
+    rio_fd_open_special (res.res, RIO_FD_EPOLL);
+
+  rio_dbg_printf ("%s[%u]: epfd = %ld, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, res.res, res.rio_errno);
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return res.res;
+}
+
+int
+rio_get_epoll_ctl (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_epoll *msg;
+  struct pcn_msg_res res;
+  struct epoll_event e;
+
+  msg = alloca (sizeof (struct pcn_msg_epoll) + sizeof (struct epoll_event));
+
+  rio_msg_get (fd, msg, sizeof (struct pcn_msg_epoll));
+  res.res = rio_msg_get (fd, &e, sizeof (e));
+
+  errno = hdr->msg_errno;
+  res.res = __do_epoll_ctl (msg->ver, msg->epfd, msg->arg1, msg->arg2, &e);
+
+  res.id = hdr->msg_id;
+  res.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: epfd = %u, op = %x, fd = %u, ver = %u -> %ld\n",
+	      __FUNCTION__, hdr->msg_id, msg->epfd, msg->arg1, msg->arg2,
+	      msg->ver, res.res);
+
+  rio_msg_res (fd, &res);
+
+  return res.res;
+}
+
+static int
+rio_epoll_interval (int *t, int *t_end)
+{
+  if (*t_end == -1)
+    {
+      *t = RIO_POLL_INTERVAL_MS;
+      return 0;
+    }
+
+  if (*t_end - RIO_POLL_INTERVAL_MS > 0)
+    {
+      *t_end -= RIO_POLL_INTERVAL_MS;
+      *t = RIO_POLL_INTERVAL_MS;
+      return 0;
+    }
+
+  *t = *t_end;
+  return 1;
+}
+
+static int
+do_rio_epoll_pwait (int *fd, int ver, int epfd, struct epoll_event *events,
+		   int maxevents, int timeout, const sigset_t *sigmask)
+{
+  int t, t_end;
+  int status, res;
+
+  t_end = timeout;
+
+  do {
+    int finished = rio_epoll_interval (&t, &t_end);
+    status = PCN_POLL_RESUME;
+
+    rio_dbg_printf ("%s: INTERVAL finished = %d [%d ms]\n", __FUNCTION__, finished, t);
+
+    res = __do_epoll_pwait (ver, epfd, events, maxevents, t, sigmask);
+
+    rio_dbg_printf ("%s: res = %d\n", __FUNCTION__, res);
+
+    if (finished || res > 0 || res == -1)
+      {
+	status = PCN_POLL_RIO_COMPLETE;
+	rio_msg_send_raw (*fd, &status, sizeof (status));
+	break;
+      }
+    else if (res == 0)
+      {
+	status = PCN_POLL_RIO_ONGOING;
+	rio_msg_send_raw (*fd, &status, sizeof (status));
+	status = do_rio_poll (fd);
+      }
+
+    rio_dbg_printf ("%s: status = %d\n", __FUNCTION__, status);
+  } while (status == PCN_POLL_RESUME);
+
+  if (status == PCN_POLL_STOP)
+    {
+      errno = EINTR;
+      res = -1;
+    }
+
+  return res;
+}
+
+int
+rio_get_epoll_wait (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_epoll msg;
+  struct pcn_msg_res res;
+  struct epoll_event *events;
+
+  res.res = rio_msg_get (fd, &msg, hdr->msg_size);
+
+  events = malloc (sizeof (struct epoll_event) * msg.arg1);
+
+  errno = hdr->msg_errno;
+  res.res = do_rio_epoll_pwait (&fd, msg.ver, msg.epfd, events, msg.arg1,
+				msg.arg2, NULL);
+
+  res.id = hdr->msg_id;
+  res.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: epfd = %d, maxevents = %d, timeout = %d, ver = %d -> %ld\n",
+	      __FUNCTION__, hdr->msg_id, msg.epfd, msg.arg1, msg.arg2,
+	      msg.ver, res.res);
+
+  rio_msg_res (fd, &res);
+
+  if (res.res > 0)
+    rio_msg_send_raw (fd, events, res.res * sizeof (struct epoll_event));
+
+  free (events);
+
+  return res.res;
+}
+
+int
+rio_get_epoll_pwait (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_epoll_pwait msg;
+  struct pcn_msg_res res;
+  struct epoll_event *events;
+  long l_sigmask;
+  sigset_t *sigmask;
+
+  res.res = rio_msg_get (fd, &msg, hdr->msg_size);
+
+  events = malloc (sizeof (struct epoll_event) * msg.maxevents);
+
+  l_sigmask = msg.sigmask;
+  if (l_sigmask == -1)
+    sigmask = NULL;
+  else
+    sigmask = (sigset_t *)&l_sigmask;
+
+  errno = hdr->msg_errno;
+  res.res = do_rio_epoll_pwait (&fd, msg.ver, msg.epfd, events, msg.maxevents,
+				msg.timeout, sigmask);
+
+  res.id = hdr->msg_id;
+  res.rio_errno = errno;
+
+  rio_msg_res (fd, &res);
+
+  rio_dbg_printf ("%s[%u]: epfd = %u, maxevents = %d, timeout = %d, sigmask = %lx, ver = %u -> %ld\n",
+	      __FUNCTION__, hdr->msg_id, msg.epfd, msg.maxevents,
+	      msg.timeout, msg.sigmask, msg.ver, res.res);
+
+  if (res.res > 0)
+    rio_msg_send_raw (fd, events, res.res * sizeof (struct epoll_event));
+
+  free (events);
+
+  return res.res;
+}
diff --git a/remote_io/rio_sys_fallocate.c b/remote_io/rio_sys_fallocate.c
new file mode 100644
index 0000000000..e88a848757
--- /dev/null
+++ b/remote_io/rio_sys_fallocate.c
@@ -0,0 +1,42 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_fallocate (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_fallocate msg;
+  struct pcn_msg_res res;
+
+  res.res = rio_msg_get (fd, &msg, hdr->msg_size);
+
+  errno = hdr->msg_errno;
+  res.res = lio_fallocate (msg.fd, msg.mode, msg.offset, msg.len);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, mode = %u, offset = %lx, len = %u -- res = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg.fd, msg.mode, msg.offset,
+	      msg.len, res.res);
+
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  rio_msg_send_raw (fd, &res, sizeof (res));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_fcntl.c b/remote_io/rio_sys_fcntl.c
new file mode 100644
index 0000000000..de24529a58
--- /dev/null
+++ b/remote_io/rio_sys_fcntl.c
@@ -0,0 +1,44 @@
+/* fcntl system call forwarding.  At present, the RIO server
+   only supports F_GETFL, F_SETFL, and F_GETFD. */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_fcntl (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_fcntl msg;
+  struct pcn_msg_res res;
+
+  res.res = rio_msg_get (fd, &msg, hdr->msg_size);
+
+  errno = hdr->msg_errno;
+  res.res = lio_fcntl (msg.fd, msg.cmd, msg.arg);
+
+  rio_dbg_printf ("%s[%u]: fd = %u, cmd = %x, arg = %lx -- res = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg.fd, msg.cmd, msg.fd,
+	      res.res);
+
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  rio_msg_send_raw (fd, &res, sizeof (res));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_fxstatat.c b/remote_io/rio_sys_fxstatat.c
new file mode 100644
index 0000000000..13bedba939
--- /dev/null
+++ b/remote_io/rio_sys_fxstatat.c
@@ -0,0 +1,74 @@
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_fxstatat (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_fxstatat *msg = malloc (hdr->msg_size);
+  struct pcn_msg_fxstatat res;
+  struct fdinfo *pfd;
+  INTERNAL_SYSCALL_DECL (err);
+  struct stat kst;
+
+  res.fd = rio_msg_get (fd, msg, hdr->msg_size);
+
+  pfd = rio_fd_find (msg->fd);
+
+//  rio_dbg_printf ("%s[%u]: received fxstatat, size = %d\n",
+//	      __FUNCTION__, hdr->msg_id, hdr->msg_size);
+
+  if (pfd != NULL)
+    rio_dbg_printf ("%s[%u]: fd = %u, size = %u, flag = %x, file = '%s' (%s)\n",
+		__FUNCTION__, hdr->msg_id, msg->fd, msg->size, msg->flag,
+		msg->pathname, pfd->fi->name);
+  else
+    rio_dbg_printf ("%s[%u]: fd = %u, size = %u, flag = %x, file = '%s'\n",
+		__FUNCTION__, hdr->msg_id, msg->fd, msg->size, msg->flag,
+		msg->pathname);
+
+  errno = hdr->msg_errno;
+  res.flag = __do_fxstatat (_STAT_VER, msg->fd, msg->pathname, &kst,
+			    msg->flag);
+  res.fd = errno;
+  res.size = sizeof (struct pcn_msg_fxstatat);
+
+  //rio_dbg_printf ("%s[%u]: res = %d, errno = %d\n", __FUNCTION__, hdr->msg_id, res.flag, res.fd);
+  rio_dbg_printf ("%s[%u]: dev = %x, ino = %x, mode = %u, nlink = %x uid = %x, gid = %x, "
+		  "rdev = %x, size = %u, blksize = %x, blocks = %u, "
+                  "res = %d, errno = %d\n",
+		  __FUNCTION__, hdr->msg_id, kst.st_dev, kst.st_ino,
+		  kst.st_mode, kst.st_nlink, kst.st_uid, kst.st_gid,
+		  kst.st_rdev, kst.st_size, kst.st_blksize, kst.st_blocks,
+                  res.flag, res.fd);
+
+  res.st_dev = kst.st_dev;
+  res.st_ino = kst.st_ino;
+  res.st_mode = kst.st_mode;
+  res.st_nlink = kst.st_nlink;
+  res.st_uid = kst.st_uid;
+  res.st_gid = kst.st_gid;
+  res.st_rdev = kst.st_rdev;
+  res.st_size = kst.st_size;
+  res.st_blksize = kst.st_blksize;
+  res.st_blocks = kst.st_blocks;
+  res.st_atim = kst.st_atim;
+  res.st_mtim = kst.st_mtim;
+  res.st_ctim = kst.st_ctim;
+
+  lio_write (fd, &res, sizeof (struct pcn_msg_fxstatat));
+
+  free (msg);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_getcwd.c b/remote_io/rio_sys_getcwd.c
new file mode 100644
index 0000000000..b2e6711b72
--- /dev/null
+++ b/remote_io/rio_sys_getcwd.c
@@ -0,0 +1,42 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_getcwd (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_read *msg;
+  int size = sizeof (struct pcn_msg_read) + hdr->msg_size;
+  int res;
+
+  msg = alloca (size);
+
+  errno = hdr->msg_errno;
+  msg->cnt = lio_getcwd (msg->buf, hdr->msg_size);
+  msg->fd = errno;
+
+  res = rio_msg_send_raw (fd, msg, sizeof (struct pcn_msg_read) + msg->cnt);
+  LIO_ASSERT (res == sizeof (struct pcn_msg_read) + msg->cnt,
+              "corrupted response from client");
+
+  rio_dbg_printf ("%s[%u]: pathname = '%s' -- res = %ld\n",
+		  __FUNCTION__, hdr->msg_id, msg->buf, msg->cnt);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_getdents.c b/remote_io/rio_sys_getdents.c
new file mode 100644
index 0000000000..dedc26c6c2
--- /dev/null
+++ b/remote_io/rio_sys_getdents.c
@@ -0,0 +1,38 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_getdents64 (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_getdents msg;
+  struct pcn_msg_res ack;
+  void *buf;
+  int res;
+
+  res = rio_msg_get (fd, &msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive accept message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  buf = alloca (msg.nbytes);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_getdents64 (msg.fd, buf, msg.nbytes);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: fd = %d, nbytes = %d -- res = %d, errno = %d\n",
+                  __FUNCTION__, hdr->msg_id, msg.fd, msg.nbytes,
+                  ack.res, ack.rio_errno);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+  rio_msg_send_raw (fd, buf, msg.nbytes);
+
+  return res - sizeof (msg.nbytes);
+}
diff --git a/remote_io/rio_sys_getitimer.c b/remote_io/rio_sys_getitimer.c
new file mode 100644
index 0000000000..e905748235
--- /dev/null
+++ b/remote_io/rio_sys_getitimer.c
@@ -0,0 +1,38 @@
+#include <errno.h>
+#include <alloca.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_getitimer (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  struct itimerval value;
+  int which, res;
+
+  res = rio_msg_get (fd, &which, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_getitimer (which, &value);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: which = %d, value = { [%ld, %ld], [%ld, %ld] } -- res = %d, errno = %d\n",
+                  __FUNCTION__, hdr->msg_id, which, value.it_interval.tv_sec,
+                  value.it_interval.tv_usec, value.it_value.tv_sec,
+                  value.it_value.tv_usec, res, errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  rio_msg_send_raw (fd, &value, sizeof (struct itimerval));
+
+  return res - sizeof (ack);
+}
diff --git a/remote_io/rio_sys_kill.c b/remote_io/rio_sys_kill.c
new file mode 100644
index 0000000000..a6db102c36
--- /dev/null
+++ b/remote_io/rio_sys_kill.c
@@ -0,0 +1,38 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/epoll.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+/* TODO: Handle the multi-process set, where client process is sending
+   a signal to another process in its process group after both of them
+   have migrated to a different machine.  */
+
+int
+rio_get_kill (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_signal msg;
+  struct pcn_msg_res res;
+
+  rio_msg_get (fd, &msg, sizeof (msg));
+
+  errno = hdr->msg_errno;
+
+  res.res = lio_kill (msg.pid, msg.sig);
+  res.id = hdr->msg_id;
+  res.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: signal = %d, pid = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg.sig, msg.pid);
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return res.res;
+}
diff --git a/remote_io/rio_sys_link.c b/remote_io/rio_sys_link.c
new file mode 100644
index 0000000000..84c7397b22
--- /dev/null
+++ b/remote_io/rio_sys_link.c
@@ -0,0 +1,94 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+#include "rio_common_dir.h"
+
+int
+rio_get_link (struct pcn_msg_hdr *hdr, int fd)
+{
+  return rio_common_dir_path2 (hdr, fd);
+}
+
+int
+rio_get_unlink (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  char *name;
+  int res;
+
+  name = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, name, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_unlink (name);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: name = %s -- res = %d, errno = %d\n",
+                  __FUNCTION__, hdr->msg_id, name, ack.res,
+                  ack.rio_errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  return res - sizeof (ack);
+}
+
+int
+rio_get_symlink (struct pcn_msg_hdr *hdr, int fd)
+{
+  return rio_common_dir_path2 (hdr, fd);
+}
+
+int
+rio_get_readlink (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_readlink msg;
+  struct pcn_msg_res ack;
+  char *path, *buf;
+  int res;
+
+  res = rio_msg_get (fd, &msg, sizeof (msg));
+  if (res != sizeof (msg))
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  buf = alloca (msg.bufsz);
+  path = alloca (msg.path_len);
+
+  res = rio_msg_get (fd, path, msg.path_len);
+  if (res != msg.path_len)
+    lio_error ("%s: failed to receive PATH from client\n", __FUNCTION__);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_readlink (path, buf, msg.bufsz);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  if (ack.res == -1)
+    {
+      rio_dbg_printf ("%s[%u]: path = %s, len = %d -- res = %d, errno = %d\n",
+                      __FUNCTION__, hdr->msg_id, path, msg.path_len,
+                      ack.res, errno);
+      res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+      return res;
+    }
+
+  rio_dbg_printf ("%s[%u]: path = %s, len = %d -- res = %d, buf = %s, errno = %d\n",
+                  __FUNCTION__, hdr->msg_id, path, msg.path_len, ack.res,
+                  buf, errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+  if (res != sizeof (ack))
+    lio_error ("%s: failed to send response to client\n", __FUNCTION__);
+
+  res = rio_msg_send_raw (fd, buf, ack.res);
+
+  return res - ack.res;
+}
diff --git a/remote_io/rio_sys_listen.c b/remote_io/rio_sys_listen.c
new file mode 100644
index 0000000000..c248d54c7a
--- /dev/null
+++ b/remote_io/rio_sys_listen.c
@@ -0,0 +1,45 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_listen (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_listen msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  res = rio_msg_get (fd, &msg, sizeof (msg));
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive listen message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_listen (msg.sockfd, msg.backlog);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, backlog = %u -- res = %d\n",
+		  __FUNCTION__, hdr->msg_id, msg.sockfd, msg.backlog,
+		  ack.res);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_lseek.c b/remote_io/rio_sys_lseek.c
new file mode 100644
index 0000000000..1276311239
--- /dev/null
+++ b/remote_io/rio_sys_lseek.c
@@ -0,0 +1,36 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_lseek64 (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_lseek msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  res = rio_msg_get (fd, &msg, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s[%u]: failed to receive lseek message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_lseek64 (msg.fd, msg.offset, msg.whence);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: fd = %d, offset = %ld, whence = %d -- res = %d, errno = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg.fd, msg.offset, msg.whence,
+                  ack.res, errno);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_mkdir.c b/remote_io/rio_sys_mkdir.c
new file mode 100644
index 0000000000..50afe6463e
--- /dev/null
+++ b/remote_io/rio_sys_mkdir.c
@@ -0,0 +1,35 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_mkdir (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_mkdir *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_mkdir (msg->path, msg->mode);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: path = %s, mode = %x -- res = %d, errno = %d\n",
+                  __FUNCTION__, hdr->msg_id, msg->path, msg->mode,
+                  ack.res, ack.rio_errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  return res - sizeof (ack);
+}
diff --git a/remote_io/rio_sys_mmap.c b/remote_io/rio_sys_mmap.c
new file mode 100644
index 0000000000..4978e8ac47
--- /dev/null
+++ b/remote_io/rio_sys_mmap.c
@@ -0,0 +1,124 @@
+/* The Remote I/O Server doesn't actually need to mmap any files. Instead
+   it just delagates the mapping to the client. The server only needs to ensure
+   that the client hasa local copy of the mmap'ed file. On munmap, if the mmap
+   has PROT_WRITE and is not anonymous, the server's copy of the file must be
+   updated.  */
+
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+/* This is a simple counter that gets incremented / decremented as an mmaped
+   filed is cached locally for the client in the .cache-<pid> directory.
+   Eventually, this caching scheme could be improved, by letting multiple
+   processes share read-only files and by consistnecy checking (hashsum) of
+   the local files to ensure that the contents haven't changed between runs.  */
+//static int rio_mmap_cache = 0;
+
+int
+rio_get_mmap (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_mmap msg;
+  struct pcn_msg_hdr ack;
+  struct fdinfo *cfd; // Requested fd by the client
+  struct file_info *pfi;
+  int size;
+
+  rio_dbg_printf ("%s[%u]: received mmap, size = %d\n",
+	      __FUNCTION__, hdr->msg_id, hdr->msg_size);
+
+  size = rio_msg_get (fd, &msg, sizeof (struct pcn_msg_mmap));
+  if (size != hdr->msg_size - sizeof (struct pcn_msg_hdr))
+    {
+      rio_dbg_printf ("%s[%u]: only received %d of %d bytes\n",
+		  __FUNCTION__, hdr->msg_id, size, hdr->msg_size);
+      lio_exit (EXIT_FAILURE);
+    }
+
+  cfd = rio_fd_find (msg.fd);
+  if (cfd == NULL)
+    lio_error ("%s[%u]: could not locate file descriptor '%u'\n",
+	       __FUNCTION__, hdr->msg_id, msg.fd);
+
+  pfi = cfd->fi;
+
+  /* Check if the file has already been opened up locally for
+      a different mapping.  */
+  if (pfi->refcount > 1 && pfi->lname != NULL)
+    rio_msg_ack (fd, hdr, cfd->fd);
+  else
+    rio_file_copy (fd, hdr->msg_id, cfd);
+
+  rio_dbg_printf ("%s[%u]: mapping fd = %u, length = %u, flag = %x, file = '%s' -> '%s', refcount = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.fd, msg.length, pfi->flags,
+	      pfi->name, pfi->lname, pfi->refcount);
+
+  // Instruct client to open up local file
+  pfi->refcount++;
+
+  if (!(msg.flags & MAP_PRIVATE) && (msg.prot & PROT_WRITE))
+    pfi->status |= RIO_FD_DIRTY;
+
+  /* Receive the actuall mapping from the client and add
+     it to the mmap tree  */
+  size = rio_msg_get (fd, &msg.addr, sizeof msg.addr);
+  rio_mmap_add (pfi, msg.addr, msg.length, msg.prot, msg.flags);
+
+//  int count;
+//  ioctl (fd, FIONREAD, &count);
+//  rio_dbg_printf ("%s[%u]: pending message bytes = %u\n",
+//		  __FUNCTION__, hdr->msg_id, count);
+
+  //lio_assert_empty_socket (fd);
+
+  ack.msg_id = hdr->msg_id;
+  ack.msg_type = PCN_TYPE_CONTROL;
+  ack.msg_kind = PCN_CTL_ACK;
+  ack.msg_async = PCN_SEND_NORET;
+  ack.msg_size = sizeof (ack);
+  rio_msg_send (fd, &ack);
+
+  return 0;
+}
+
+int
+rio_get_munmap (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_mmap msg;
+  struct mmapinfo *mi;
+  int size;
+
+  //rio_dbg_printf ("%s: received mmap, size = %d\n", __FUNCTION__, hdr->msg_size);
+
+  size = rio_msg_get (fd, &msg, hdr->msg_size);
+  if (size != hdr->msg_size)
+    {
+      rio_dbg_printf ("%s[%u]: only received %d of %d bytes\n",
+		  __FUNCTION__, hdr->msg_id, size, hdr->msg_size);
+      lio_exit (EXIT_FAILURE);
+    }
+
+  //rio_dbg_printf ("%s: unmapping address %lx\n", __FUNCTION__, msg.addr);
+
+  mi = rio_mmap_find (msg.addr);
+  if (mi == NULL)
+    lio_error ("%s: invalid address %lx\n", __FUNCTION__, msg.addr);
+
+  rio_mmap_close (mi, fd, hdr->msg_id);
+  rio_msg_ack (fd, hdr, 0);
+
+  rio_dbg_printf ("%s[%u]: unmapping addr = %lx, length = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.addr, msg.length);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_open.c b/remote_io/rio_sys_open.c
new file mode 100644
index 0000000000..ee1684ddcb
--- /dev/null
+++ b/remote_io/rio_sys_open.c
@@ -0,0 +1,46 @@
+/* open system call forwarding -- open, creat, and openat  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_open (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_open *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+
+  res.res = rio_msg_get (fd, msg, hdr->msg_size);
+
+  errno = hdr->msg_errno;
+  res.res = lio_openat (msg->dirfd, msg->pathname, msg->flags, msg->mode);
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  rio_fd_open (res.res, msg->flags, msg->mode, msg->pathname);
+
+  rio_dbg_printf ("%s[%u]: pathname = %s, flags = %x, mode = %x, dirfd = %d -- fd = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg->pathname, msg->flags,
+	      msg->mode, msg->dirfd, res.res, res.rio_errno);
+
+  free (msg);
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_pipe.c b/remote_io/rio_sys_pipe.c
new file mode 100644
index 0000000000..049ac2790b
--- /dev/null
+++ b/remote_io/rio_sys_pipe.c
@@ -0,0 +1,45 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_pipe (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_pipe msg;
+  int newpipe[2] = { -1, -1 };
+  int flags = hdr->msg_size;
+
+  errno = hdr->msg_errno;
+  msg.res = lio_pipe2 (newpipe, flags);
+  msg._errno = errno;
+  
+  msg.pfds[0] = newpipe[0];
+  msg.pfds[1] = newpipe[1];
+
+  rio_fd_open_special (newpipe[0], RIO_FD_PIPE);
+  rio_fd_open_special (newpipe[1], RIO_FD_PIPE);
+
+  rio_dbg_printf ("%s[%u]: flags = %x, pdfs = [%d, %d] -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, flags, msg.pfds[0], msg.pfds[1],
+	      msg.res, msg._errno);
+
+  rio_msg_send_raw (fd, &msg, sizeof (msg));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_poll.c b/remote_io/rio_sys_poll.c
new file mode 100644
index 0000000000..d48bb62773
--- /dev/null
+++ b/remote_io/rio_sys_poll.c
@@ -0,0 +1,143 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+#include <time.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static const sigset_t sigzero = { 0 };
+
+int
+do_rio_poll (int *fd)
+{
+  struct pcn_msg_hdr hdr;
+
+  //lio_spin ();
+
+  do {
+    rio_msg_get_robust (fd, &hdr, sizeof (hdr));
+
+    if (hdr.msg_type == PCN_TYPE_POLL)
+      break;
+
+    LIO_ASSERT (hdr.msg_type == PCN_TYPE_CONTROL,
+                "unexpected syscall interrupting a poll");
+
+    if (hdr.msg_kind == PCN_CTL_MIGRATE)
+      {
+        do_rio_server_migrate (&hdr, *fd);
+        *fd = -1;
+      }
+    else if (hdr.msg_kind == PCN_CTL_ATTACH)
+      do_rio_server_attach (&hdr, *fd);
+    else
+      lio_error ("%s: Unexpected CTL message\n", __FUNCTION__);
+
+    rio_dbg_printf ("%s: type = %d, kind = %d\n", __FUNCTION__, hdr.msg_type, hdr.msg_kind);
+  } while (hdr.msg_type != PCN_TYPE_POLL);
+
+  return hdr.msg_kind;
+}
+
+int
+rio_get_poll (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_poll *msg;
+  int res, nfds, status;
+  struct timespec *tp = NULL, t, t_end;
+  sigset_t *sigmask, smask;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive poll message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  nfds = msg->nfds;
+  t.tv_sec = msg->tv_sec;
+  t.tv_nsec = msg->tv_nsec;
+
+  rio_poll_init_time (&t, &t_end);
+//  lio_dbg_printf ("%s: [%ld, %ld] -> [%ld, %ld]\n", __FUNCTION__,
+//                  t.tv_sec, t.tv_nsec, t_end.tv_sec, t_end.tv_nsec);
+
+  errno = hdr->msg_errno;
+
+  /* WARNING: This might result in a slightly shorter time interval than the
+     user requested. This is because of the time is calculated as the difference
+     between rio_poll_init_time and whatever the granularity of
+     RIO_POLL_INTERVAL_S is. But given that system calls are atomic, this ought
+     to be OK.  */
+
+  do {
+    int finished = rio_poll_interval (&t, &t_end);
+    status = PCN_POLL_RESUME;
+
+    rio_dbg_printf ("%s: INTERVAL finished = %d [%ld, %ld]\n", __FUNCTION__, finished,
+                    t.tv_sec, t.tv_nsec);
+
+    if (hdr->msg_kind == PCN_SYS_POLL)
+//      res = lio_poll ((struct pollfd *)msg->fds,
+//		      nfds, t.tv_sec * 1000 + t.tv_nsec);
+      res = lio_ppoll ((struct pollfd *)msg->fds, nfds, &t, NULL);
+    else
+      {
+	tp = (t.tv_sec == -1) ? NULL : &t;
+
+	if (memcmp (&msg->sigmask, &sigzero, sizeof (sigset_t)) == 0)
+	  sigmask = NULL;
+	else
+	  {
+	    lio_memcpy (&smask, &msg->sigmask, sizeof smask);
+	    sigmask = &smask;
+	  }
+
+	res = lio_ppoll ((struct pollfd *)msg->fds, nfds, tp, sigmask);
+
+	if (memcmp (&msg->sigmask, &sigzero, sizeof (sigset_t)) != 0)
+	  lio_memcpy (&msg->sigmask, &smask, sizeof smask);
+      }
+
+    if (finished || res > 0)
+      {
+        status = PCN_POLL_RIO_COMPLETE;
+        rio_msg_send_raw (fd, &status, sizeof (status));
+        break;
+      }
+    else if (res == 0)
+      {
+        status = PCN_POLL_RIO_ONGOING;
+        rio_msg_send_raw (fd, &status, sizeof (status));
+        status = do_rio_poll (&fd);
+      }
+  } while (status == PCN_POLL_RESUME);
+
+  //lio_dbg_printf ("%s: status = %d\n", __FUNCTION__, status);
+
+  msg->nfds = res;
+  msg->tv_sec = status == PCN_POLL_STOP ? EINTR : errno;
+
+  rio_dbg_printf ("%s[%u]: kind = %s, nfds = %u, timeout = %d -- res = %d, errno = %d\n",
+		  __FUNCTION__, hdr->msg_id,
+		  hdr->msg_kind == PCN_SYS_POLL ? "PCN_SYS_POLL" : "PCN_SYS_PPOLL",
+		  nfds, t.tv_sec, res, msg->tv_sec);
+
+  rio_msg_send_raw (fd, msg, hdr->msg_size);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_read.c b/remote_io/rio_sys_read.c
new file mode 100644
index 0000000000..926f328e02
--- /dev/null
+++ b/remote_io/rio_sys_read.c
@@ -0,0 +1,58 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_read (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_read *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+  void *buf;
+
+  res.res = rio_msg_get (fd, msg, hdr->msg_size);
+
+  buf = (char *) malloc (msg->cnt);
+
+  errno = hdr->msg_errno;
+  if (hdr->msg_kind == PCN_SYS_READ)
+    res.res = lio_read (msg->fd, buf, msg->cnt);
+  else
+    res.res = lio_pread (msg->fd, buf, msg->cnt, msg->offset);
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  if (hdr->msg_kind == PCN_SYS_READ)
+    rio_dbg_printf ("%s[%u]: read fd = %u, count = %u -- res = %d, errno = %d\n",
+		__FUNCTION__, hdr->msg_id, msg->fd, msg->cnt, res.res,
+		res.rio_errno);
+  else
+    rio_dbg_printf ("%s[%u]: pread fd = %u, count = %u, offset = %u -- res = %d, errno = %d\n",
+		__FUNCTION__, hdr->msg_id, msg->fd, msg->cnt, msg->offset,
+		res.res, res.rio_errno);
+
+  rio_msg_send_raw (fd, &res, sizeof (res));
+
+  if (res.res > 0)
+    rio_msg_send_raw (fd, buf, res.res);
+
+  free (buf);
+  free (msg);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_recv.c b/remote_io/rio_sys_recv.c
new file mode 100644
index 0000000000..891c0ff62a
--- /dev/null
+++ b/remote_io/rio_sys_recv.c
@@ -0,0 +1,103 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_recvfrom (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_recvfrom msg;
+  struct sockaddr_storage addr;
+  socklen_t addrlen = { 0 };
+  void *buf;
+
+  rio_msg_get (fd, &msg, hdr->msg_size);
+
+  buf = (char *) alloca (msg.len);
+
+  errno = hdr->msg_errno;
+
+  /* Maybe handle the case where msg.src_addr == NULL?  */
+  msg.len = lio_recvfrom (msg.sockfd, buf, msg.len, msg.flags,
+			  (struct sockaddr *)&addr, &addrlen);
+  msg.rio_errno = errno;
+
+  msg.addrlen = addrlen;
+  memcpy (&msg.src_addr, &addr, msg.addrlen);
+
+  rio_dbg_printf ("%s[%u]: received %ld bytes from fd %u -- addrlen = %ld, errno = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.len, msg.sockfd,
+	      msg.addrlen, msg.rio_errno);
+
+  rio_msg_send_raw (fd, &msg, sizeof (msg));
+
+  if (msg.len > 0)
+    rio_msg_send_raw (fd, buf, msg.len);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_recvmsg (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_recvmsg msg;
+  struct iovec payload[1];
+  struct msghdr msghdr;
+  void *buf, *control = NULL;
+
+  rio_msg_get (fd, &msg, hdr->msg_size);
+
+  if (msg.msg_controllen > 0)
+    {
+      control = alloca (msg.msg_controllen);
+      rio_msg_get (fd, control, msg.msg_controllen);
+    }
+
+  buf = (char *) alloca (msg.msg_iovsize);
+  payload[0].iov_base = buf;
+  payload[0].iov_len = msg.msg_iovsize;
+
+  msghdr.msg_name = &msg.msg_name;
+  msghdr.msg_namelen = msg.msg_namelen;
+  msghdr.msg_iov = payload;
+  msghdr.msg_iovlen = 1;
+  msghdr.msg_control = control;
+  msghdr.msg_controllen = msg.msg_controllen;
+  msghdr.msg_flags = msg.msg_flags;
+
+  errno = hdr->msg_errno;
+  msg.msg_iovsize = lio_recvmsg (msg.sockfd, &msghdr, msg.flags);
+  msg.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: received %ld bytes from fd %u, "
+	      "flags = %x, msg_flags = %x -- msg_controllen = %u, errno = %u\n",
+	      __FUNCTION__, hdr->msg_id, msg.msg_iovsize, msg.sockfd,
+	      msg.flags, msg.msg_flags, msg.msg_controllen, msg.rio_errno);
+
+  rio_msg_send_raw (fd, &msg, sizeof (msg));
+
+  if (msg.msg_controllen > 0)
+    rio_msg_send_raw (fd, control, msg.msg_controllen);
+
+  if (msg.msg_iovsize > 0)
+    rio_msg_send_raw (fd, buf, msg.msg_iovsize);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_rename.c b/remote_io/rio_sys_rename.c
new file mode 100644
index 0000000000..ffc08da98e
--- /dev/null
+++ b/remote_io/rio_sys_rename.c
@@ -0,0 +1,7 @@
+#include "rio_common_dir.h"
+
+int
+rio_get_rename (struct pcn_msg_hdr *hdr, int fd)
+{
+  return rio_common_dir_path2 (hdr, fd);
+}
diff --git a/remote_io/rio_sys_rmdir.c b/remote_io/rio_sys_rmdir.c
new file mode 100644
index 0000000000..202105b2c5
--- /dev/null
+++ b/remote_io/rio_sys_rmdir.c
@@ -0,0 +1,7 @@
+#include "rio_common_dir.h"
+
+int
+rio_get_rmdir (struct pcn_msg_hdr *hdr, int fd)
+{
+  return rio_common_dir (hdr, fd);
+}
diff --git a/remote_io/rio_sys_select.c b/remote_io/rio_sys_select.c
new file mode 100644
index 0000000000..b7796407e2
--- /dev/null
+++ b/remote_io/rio_sys_select.c
@@ -0,0 +1,212 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static void
+populate_ifds (fd_set *ifds, fd_set *pfds[3], void *r, void *w, void *e,
+	       unsigned char args)
+{
+  if (get_arg (args, 1))
+    {
+      memcpy (&ifds[0], r, sizeof (fd_set));
+      pfds[0] = &ifds[0];
+    }
+  else
+    pfds[0] = NULL;
+
+  if (get_arg (args, 2))
+    {
+      memcpy (&ifds[1], w, sizeof (fd_set));
+      pfds[1] = &ifds[1];
+    }
+  else
+    pfds[1] = NULL;
+
+  if (get_arg (args, 3))
+    {
+      memcpy (&ifds[2], e, sizeof (fd_set));
+      pfds[2] = &ifds[2];
+    }
+  else
+    pfds[2] = NULL;
+}
+
+static void
+pack_ifds_ack (fd_set *pfds[3], void *r, void *w, void *e)
+{
+  if (pfds[0])
+    memcpy (r, pfds[0], sizeof (fd_set));
+
+  if (pfds[1])
+    memcpy (w, pfds[1], sizeof (fd_set));
+
+  if (pfds[2])
+    memcpy (r, pfds[0], sizeof (fd_set));
+}
+
+static int
+do_rio_select (int *fd, int nfds, fd_set *restrict readfds,
+               fd_set *restrict writefds, fd_set *restrict exceptfds,
+               struct timespec *restrict timeout,
+               const sigset_t *restrict sigmask)
+{
+  struct timespec t, t_end;
+  int status, res;
+  fd_set orig_fds[3];
+
+  if (readfds)
+    lio_memcpy (&orig_fds[0], readfds, sizeof (fd_set));
+  if (writefds)
+    lio_memcpy (&orig_fds[1], writefds, sizeof (fd_set));
+  if (exceptfds)
+    lio_memcpy (&orig_fds[2], exceptfds, sizeof (fd_set));
+
+  rio_poll_init_time (timeout, &t_end);
+
+  do {
+    int finished = rio_poll_interval (&t, &t_end);
+    status = PCN_POLL_RESUME;
+
+    rio_dbg_printf ("%s: INTERVAL finished = %d [%ld, %ld]\n", __FUNCTION__, finished,
+                    t.tv_sec, t.tv_nsec);
+
+    res = lio_pselect (nfds, readfds, writefds, exceptfds, &t, sigmask);
+
+    if (finished || res > 0)
+      {
+        status = PCN_POLL_RIO_COMPLETE;
+        rio_msg_send_raw (*fd, &status, sizeof (status));
+        break;
+      }
+    else if (res == 0)
+      {
+        status = PCN_POLL_RIO_ONGOING;
+        rio_msg_send_raw (*fd, &status, sizeof (status));
+        status = do_rio_poll (fd);
+      }
+
+    if (readfds)
+      lio_memcpy (readfds, &orig_fds[0], sizeof (fd_set));
+    if (writefds)
+      lio_memcpy (writefds, &orig_fds[1], sizeof (fd_set));
+    if (exceptfds)
+      lio_memcpy (exceptfds, &orig_fds[2], sizeof (fd_set));
+  } while (status == PCN_POLL_RESUME);
+
+  if (status == PCN_POLL_STOP)
+    {
+      errno = EINTR;
+      res = -1;
+    }
+
+  return res;
+}
+
+int
+rio_get_pselect (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_pselect msg;
+  struct pcn_msg_select_res ack;
+  fd_set ifds[3], *pfds[3];
+  struct timespec ts, *pts;
+  long sigmask;
+  const sigset_t *pmask;
+  int res;
+
+  res = rio_msg_get (fd, &msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive bind message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  populate_ifds (ifds, pfds, &msg.readfds, &msg.writefds,
+		&msg.exceptfds, msg.args);
+
+  if (get_arg (msg.args, 4))
+    {
+      memcpy (&ts, &msg.ts, sizeof (struct timespec));
+      pts = &ts;
+    }
+  else
+    pts = NULL;
+
+  if (get_arg (msg.args, 5))
+    {
+      sigmask = msg.sigmask;
+      pmask = (sigset_t *)&sigmask;
+    }
+  else
+    pmask = NULL;
+
+  errno = hdr->msg_errno;
+  ack.res = do_rio_select (&fd, msg.nfds, pfds[0], pfds[1], pfds[2], pts, pmask);
+  ack.rio_errno = errno;
+
+  pack_ifds_ack (pfds, &ack.readfds, &ack.writefds, &ack.exceptfds);
+
+  rio_dbg_printf ("%s[%u]: nfds = %d, readfds = %ls, writefds = %lx execpfds = %lx, timeout = %lx, sigmask = %lx -- res = %d\n",
+		  __FUNCTION__, hdr->msg_id, msg.nfds, pfds[0], pfds[1],
+		  pfds[2], pts, pmask, res);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_select (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_select msg;
+  struct pcn_msg_select_res ack;
+  fd_set ifds[3], *pfds[3];
+  struct timespec ts, *pts;
+  int res;
+
+  res = rio_msg_get (fd, &msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive bind message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  populate_ifds (ifds, pfds, &msg.readfds, &msg.writefds,
+		&msg.exceptfds, msg.args);
+
+  if (get_arg (msg.args, 4))
+    {
+      ts.tv_sec = msg.tv.tv_sec;
+      ts.tv_nsec = msg.tv.tv_usec * 1000;
+      pts = &ts;
+    }
+  else
+    pts = NULL;
+
+  errno = hdr->msg_errno;
+  ack.res = do_rio_select (&fd, msg.nfds, pfds[0], pfds[1], pfds[2], pts, NULL);
+  ack.rio_errno = errno;
+
+  pack_ifds_ack (pfds, &ack.readfds, &ack.writefds, &ack.exceptfds);
+
+  rio_dbg_printf ("%s[%u]: nfds = %d, readfds = %lx, writefds = %lx execpfds = %lx, timeout = %lx -- res = %d\n",
+		  __FUNCTION__, hdr->msg_id, msg.nfds, pfds[0], pfds[1],
+		  pfds[2], pts, ack.res);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_send.c b/remote_io/rio_sys_send.c
new file mode 100644
index 0000000000..f7fab632bb
--- /dev/null
+++ b/remote_io/rio_sys_send.c
@@ -0,0 +1,87 @@
+/* writev system call forwarding.
+ *
+ * Eventually, this needs to be agnostic to the C library...
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_send (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_send *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+  int mfd;
+  long mcount;
+
+  res.res = rio_msg_get (fd, msg, hdr->msg_size);
+  mfd = msg->sockfd;
+  mcount = msg->len;
+
+  errno = hdr->msg_errno;
+  res.res = lio_send (mfd, msg->buf, mcount, msg->flags);
+ 
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: fd = %u, count = %u, flags = %d -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, mfd, mcount, msg->flags,
+              res.res, res.rio_errno);
+
+  free (msg);
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+
+int
+rio_get_sendto (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_sendto *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+  int mfd;
+  long mcount;
+
+  res.res = rio_msg_get (fd, msg, hdr->msg_size);
+  mfd = msg->sockfd;
+  mcount = msg->len;
+
+  errno = hdr->msg_errno;
+
+  if (msg->addrlen == 0)
+   res.res = lio_sendto (mfd, msg->buf, mcount, msg->flags, NULL, 0);
+  else
+   res.res = lio_sendto (mfd, msg->buf, msg->len, msg->flags,
+                         (struct sockaddr *)&msg->dest_addr, msg->addrlen);
+
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: fd = %u, count = %u, flags = %d, addrlen = %d -- res = %d, errno = %d\n",
+	      __FUNCTION__, hdr->msg_id, mfd, mcount, msg->flags,
+              msg->addrlen, res.res, res.rio_errno);
+
+  free (msg);
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_setitimer.c b/remote_io/rio_sys_setitimer.c
new file mode 100644
index 0000000000..7391d77616
--- /dev/null
+++ b/remote_io/rio_sys_setitimer.c
@@ -0,0 +1,50 @@
+#include <errno.h>
+#include <alloca.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_setitimer (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_setitimer msg;
+  struct pcn_msg_res ack;
+  struct itimerval new, *p_new, *p_old;
+  int res;
+
+  res = rio_msg_get (fd, &msg, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  if (get_arg (msg.null_args, 1))
+    p_new = NULL;
+  else
+    {
+      memcpy (&new, &msg.new, sizeof (struct itimerval));
+      p_new = &new;
+    }
+
+  if (get_arg (msg.null_args, 2))
+    p_old = NULL;
+
+  errno = hdr->msg_errno;
+  ack.res = lio_setitimer (msg.which, p_new, p_old);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: which = %d, new = %lx, old = %lx -- res = %d, errno = %d\n",
+                  __FUNCTION__, hdr->msg_id, msg.which, p_new, p_old,
+                  ack.res, ack.rio_errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  if (get_arg (msg.null_args, 2) == 0)
+    rio_msg_send_raw (fd, p_old, sizeof (struct itimerval));
+
+  return res - sizeof (ack);
+}
diff --git a/remote_io/rio_sys_sigaction.c b/remote_io/rio_sys_sigaction.c
new file mode 100644
index 0000000000..61774876b1
--- /dev/null
+++ b/remote_io/rio_sys_sigaction.c
@@ -0,0 +1,53 @@
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/epoll.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+static void
+register_signal (int sig)
+{
+  struct sigaction sa;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = rio_signal_forwarder;
+  sa.sa_flags = SA_SIGINFO;
+
+  /* Don't call lio_rt_sigaction directly, because glibc
+     needs to set sa_restorer.  */
+  sigaction (sig, &sa, NULL);
+}
+
+int
+rio_get_sigaction (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_signal msg;
+  struct pcn_msg_res res;
+
+  rio_msg_get (fd, &msg, sizeof (msg));
+
+  register_signal (msg.sig);
+
+  errno = hdr->msg_errno;
+
+  //dump_pcn_data ();
+
+  rio_dbg_printf ("%s[%u]: signal = %d, pid = %d\n",
+	      __FUNCTION__, hdr->msg_id, msg.sig, msg.pid);
+
+  res.id = hdr->msg_id;
+  res.rio_errno = 0;
+  res.res = 0;
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+
+  return res.res;
+}
diff --git a/remote_io/rio_sys_signalfd.c b/remote_io/rio_sys_signalfd.c
new file mode 100644
index 0000000000..ec915ca660
--- /dev/null
+++ b/remote_io/rio_sys_signalfd.c
@@ -0,0 +1,57 @@
+#include <errno.h>
+#include <alloca.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_signalfd (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_signalfd msg;
+  struct pcn_msg_res ack;
+  struct fdinfo *fdi = NULL;
+  unsigned long mask;
+  int res;
+
+  res = rio_msg_get (fd, &msg, sizeof (msg));
+  if (res != sizeof (msg))
+    lio_error ("%s: failed to receive message from client\n", __FUNCTION__);
+
+  if (msg.fd != -1)
+    {
+      fdi = rio_fd_find (msg.fd);
+      LIO_ASSERT (fdi != NULL, "missing RIO file descriptor handle for signalfd");
+
+      /* Restore the default RIO signal forwarder.  */
+      rio_sig_restore_mask (fdi->fi->arg);
+    }
+
+  mask = msg.sigmask;
+
+  /* Restore the signal handlers for the new mask, too.  */
+  rio_sig_restore_mask (mask);
+  lio_rt_sigprocmask (SIG_BLOCK, (sigset_t *)&mask, NULL, sizeof (long));
+
+  errno = hdr->msg_errno;
+  ack.res = lio_signalfd (msg.fd, (sigset_t *)&mask, msg.flags);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  if (fdi == NULL)
+    fdi = rio_fd_open_special (ack.res, RIO_FD_SIGNALFD);
+
+  fdi->fi->arg = mask;
+
+  rio_dbg_printf ("%s[%u]: fd = %d, mask = %lx, flags = %d -- res = %ld, errno = %d\n",
+		  __FUNCTION__, hdr->msg_id, msg.fd, mask,
+		  msg.flags, ack.res, errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  return res - sizeof (ack);
+}
diff --git a/remote_io/rio_sys_sock_getname.c b/remote_io/rio_sys_sock_getname.c
new file mode 100644
index 0000000000..f4fcacb65c
--- /dev/null
+++ b/remote_io/rio_sys_sock_getname.c
@@ -0,0 +1,59 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_sock_getname (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_getpeername *msg = alloca (hdr->msg_size);
+  int sock;
+  socklen_t addrlen;
+  const char *sysname = NULL;
+
+  rio_msg_get (fd, msg, hdr->msg_size);
+
+  sock = msg->sockfd;
+  addrlen = msg->addrlen;
+  errno = hdr->msg_errno;
+
+  if (hdr->msg_kind == PCN_SYS_GETPEERNAME)
+    {
+      sysname = "getpeername";
+      msg->sockfd = lio_getpeername (msg->sockfd, (struct sockaddr *)msg->addr,
+                                     &addrlen);
+    }
+  else
+    {
+      LIO_ASSERT (hdr->msg_kind == PCN_SYS_GETSOCKNAME, "unexpected syscal");
+      sysname = "getsockname";
+      msg->sockfd = lio_getsockname (msg->sockfd, (struct sockaddr *)msg->addr,
+                                     &addrlen);
+    }
+    
+  msg->rio_errno = errno;
+  msg->addrlen = addrlen;
+
+  rio_dbg_printf ("%s[%u]: syscall = %s, socket = %u, msg_size = %u -- res = %u, errno = %u\n",
+	      __FUNCTION__, hdr->msg_id, sysname, hdr->msg_size,
+	      sock, msg->sockfd, msg->rio_errno);
+
+  rio_msg_send_raw (fd, msg, hdr->msg_size);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_socket.c b/remote_io/rio_sys_socket.c
new file mode 100644
index 0000000000..ed3bf5d0a9
--- /dev/null
+++ b/remote_io/rio_sys_socket.c
@@ -0,0 +1,116 @@
+/* read system call forwarding  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_socket (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_socket msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  res = rio_msg_get (fd, &msg, sizeof (msg));
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive socket message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_socket (msg.domain, msg.type, msg.protocol);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  if (ack.res >= 0)
+    rio_fd_open_special (ack.res, RIO_FD_SOCKET);
+
+  rio_dbg_printf ("%s[%u]: domain = %x, type = %x, protocol = %x -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg.domain, msg.type,
+		  msg.protocol, ack.res);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_setsockopt (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_sockopt *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive sockopt message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_setsockopt (msg->sockfd, msg->level, msg->optname,
+			    msg->optval, msg->optlen);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->level,
+		  msg->optname, ((int *)(msg->optval))[0], msg->optlen,
+		  ack.res);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_getsockopt (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_sockopt *msg;
+  socklen_t len;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res < sizeof (msg))
+    lio_error ("%s[%u]: failed to receive sockopt message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  len = msg->optlen;
+
+  errno = hdr->msg_errno;
+  res = lio_getsockopt (msg->sockfd, msg->level, msg->optname,
+			msg->optval, &len);
+
+  msg->optlen = len;
+  msg->sockfd = res;
+  msg->level = errno;
+
+  rio_dbg_printf ("%s[%u]: sockfd = %u, level = %u, optname = %u, optval = %x, len = %u -- res = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->sockfd, msg->level,
+		  msg->optname, ((int *)(msg->optval))[0], msg->optlen,
+		  res);
+
+  rio_msg_send_raw (fd, msg, hdr->msg_size);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_statfs.c b/remote_io/rio_sys_statfs.c
new file mode 100644
index 0000000000..3fc2c73f09
--- /dev/null
+++ b/remote_io/rio_sys_statfs.c
@@ -0,0 +1,77 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_statfs (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  struct statfs buf;
+  char *fname = alloca (hdr->msg_size);
+  int res;
+
+  res = rio_msg_get (fd, fname, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s[%u]: failed to receive filename\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_statfs (fname, &buf);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: file = %s, buf = %lx -- res = %d, errno = %d, "
+                  "f_type = %lx, f_bsize = %ld, f_blocks = %ld, f_bfree = %ld, "
+                  "f_bavail = %ld, f_files = %ld, f_ffree = %ld, f_fsid = %lx, "
+                  "f_namelen = %ld, f_frsize = %ld, f_flags = %ld\n",
+		  __FUNCTION__, hdr->msg_id, fname, &buf, ack.res, errno,
+                  buf.f_type, buf.f_bsize, buf.f_blocks, buf.f_bfree,
+                  buf.f_bavail, buf.f_files, buf.f_ffree, buf.f_fsid,
+                  buf.f_namelen, buf.f_frsize, buf.f_flags);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+  rio_msg_send_raw (fd, &buf, sizeof (struct statfs));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_fstatfs (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  struct statfs buf;
+  int arg_fd, res;
+
+  res = rio_msg_get (fd, &arg_fd, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s[%u]: failed to receive filename\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_fstatfs (arg_fd, &buf);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: fd = %d, buf = %lx -- res = %d, errno = %d, "
+                  "f_type = %lx, f_bsize = %ld, f_blocks = %ld, f_bfree = %ld, "
+                  "f_bavail = %ld, f_files = %ld, f_ffree = %ld, f_fsid = %lx, "
+                  "f_namelen = %ld, f_frsize = %ld, f_flags = %ld\n",
+		  __FUNCTION__, hdr->msg_id, arg_fd, &buf, ack.res, errno,
+                  buf.f_type, buf.f_bsize, buf.f_blocks, buf.f_bfree,
+                  buf.f_bavail, buf.f_files, buf.f_ffree, buf.f_fsid,
+                  buf.f_namelen, buf.f_frsize, buf.f_flags);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+  rio_msg_send_raw (fd, &buf, sizeof (struct statfs));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_sync.c b/remote_io/rio_sys_sync.c
new file mode 100644
index 0000000000..6bdf9a518a
--- /dev/null
+++ b/remote_io/rio_sys_sync.c
@@ -0,0 +1,56 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_sync (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  int res, sfd;
+
+  res = rio_msg_get (fd, &sfd, sizeof (int));
+  if (res != sizeof (int))
+    lio_error ("%s[%u]: failed to receive accept message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+
+  switch (hdr->msg_kind) {
+    case PCN_SYS_FDATASYNC:
+      ack.res = lio_fdatasync (sfd);
+      break;
+
+    case PCN_SYS_FSYNC:
+      ack.res = lio_fsync (sfd);
+        break;
+
+    default:
+      lio_error ("%s: invalid type %d\n", __FUNCTION__, hdr->msg_kind);
+    }
+
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  switch (hdr->msg_kind) {
+    case PCN_SYS_FDATASYNC:
+      rio_dbg_printf ("%s[%u]: type = fdatasync, fd = %d -- res = %d, errno = %d\n",
+                      __FUNCTION__, hdr->msg_id, sfd, ack.res, ack.rio_errno);
+        break;
+
+    case PCN_SYS_FSYNC:
+      rio_dbg_printf ("%s[%u]: type = fsync, fd = %d -- res = %d, errno = %d\n",
+                      __FUNCTION__, hdr->msg_id, sfd, ack.res, ack.rio_errno);
+        break;
+
+    default:
+      lio_error ("%s: invalid type %d\n", __FUNCTION__, hdr->msg_id);
+    }
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  return res - sizeof (ack);
+}
\ No newline at end of file
diff --git a/remote_io/rio_sys_sync_file_range.c b/remote_io/rio_sys_sync_file_range.c
new file mode 100644
index 0000000000..c01b920c36
--- /dev/null
+++ b/remote_io/rio_sys_sync_file_range.c
@@ -0,0 +1,36 @@
+#include <errno.h>
+#include <alloca.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_sync_file_range (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_sync_file_range msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  res = rio_msg_get (fd, &msg, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s[%u]: failed to receive lseek message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_sync_file_range (msg.fd, msg.offset, msg.len, msg.flags);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: fd = %d, offset = %ld, len = %ld, flags = %d -- res = %u, errno = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg.fd, msg.offset, msg.len,
+                  msg.flags, ack.res, errno);
+
+  rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_truncate.c b/remote_io/rio_sys_truncate.c
new file mode 100644
index 0000000000..0041c97b11
--- /dev/null
+++ b/remote_io/rio_sys_truncate.c
@@ -0,0 +1,66 @@
+#include <alloca.h>
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_ftruncate64 (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_ftruncate msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  res = rio_msg_get (fd, &msg, sizeof msg);
+  if (res != sizeof (msg))
+    lio_error ("%s[%u]: failed to receive accept message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_ftruncate64 (msg.fd, msg.length);
+  ack.rio_errno = errno;\
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: fd = %d, length = %ld -- res = %u, errno = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg.fd, msg.length,
+                  ack.res, ack.rio_errno);
+
+  rio_msg_send_raw (fd, &ack, sizeof ack);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
+
+int
+rio_get_truncate64 (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_truncate *msg;
+  struct pcn_msg_res ack;
+  int res;
+
+  msg = alloca (hdr->msg_size);
+
+  res = rio_msg_get (fd, msg, hdr->msg_size);
+  if (res != hdr->msg_size)
+    lio_error ("%s[%u]: failed to receive accept message\n",
+	       __FUNCTION__, hdr->msg_id);
+
+  errno = hdr->msg_errno;
+  ack.res = lio_truncate (msg->path, msg->length);
+  ack.rio_errno = errno;\
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: path = %s, length = %ld -- res = %u, errno = %u\n",
+		  __FUNCTION__, hdr->msg_id, msg->path, msg->length,
+                  ack.res, ack.rio_errno);
+
+  rio_msg_send_raw (fd, &ack, sizeof ack);
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_umask.c b/remote_io/rio_sys_umask.c
new file mode 100644
index 0000000000..6751ce2871
--- /dev/null
+++ b/remote_io/rio_sys_umask.c
@@ -0,0 +1,29 @@
+#include <errno.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_umask (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_res ack;
+  int res;
+
+  errno = hdr->msg_errno;
+  ack.res = lio_umask (hdr->msg_size);
+  ack.rio_errno = errno;
+  ack.id = hdr->msg_id;
+
+  rio_dbg_printf ("%s[%u]: mask = %x -- res = %u, errno = %u\n",
+		  __FUNCTION__, hdr->msg_id, hdr->msg_size, ack.res,
+		  errno);
+
+  res = rio_msg_send_raw (fd, &ack, sizeof (ack));
+
+  //lio_assert_empty_socket (fd);
+
+  return res - sizeof (ack);
+}
diff --git a/remote_io/rio_sys_uname.c b/remote_io/rio_sys_uname.c
new file mode 100644
index 0000000000..d673adf22f
--- /dev/null
+++ b/remote_io/rio_sys_uname.c
@@ -0,0 +1,45 @@
+#include <string.h>
+#include <sys/utsname.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+int
+rio_get_uname (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_msg_uname msg;
+  struct utsname buf;
+  int res;
+
+  errno = hdr->msg_errno;
+  msg.rio_res = lio_uname (&buf);
+  msg.rio_errno = errno;
+
+  rio_dbg_printf ("%s[%u]: sysname = %s, nodename = %s, release = %s, "
+		  "version = %s, machine = %s, domainname = %s -- "
+		  "res = %d, errno = %d\n",
+		  __FUNCTION__, hdr->msg_id, buf.sysname, buf.nodename,
+		  buf.release, buf.version, buf.machine, buf.domainname,
+		  msg.rio_res, msg.rio_errno);
+
+  memcpy (msg.sysname, buf.sysname, PCN_UNAME_LEN);
+  memcpy (msg.nodename, buf.nodename, PCN_UNAME_LEN);
+  memcpy (msg.release, buf.release, PCN_UNAME_LEN);
+  memcpy (msg.version, buf.version, PCN_UNAME_LEN);
+  memcpy (msg.machine, buf.machine, PCN_UNAME_LEN);
+  memcpy (msg.domainname, buf.domainname, PCN_UNAME_LEN);
+
+  res = rio_msg_send_raw (fd, &msg, sizeof (msg));
+  LIO_ASSERT (res == sizeof (msg), "corrupted response from client");
+
+  //lio_assert_empty_socket (fd);
+
+  return 0;
+}
diff --git a/remote_io/rio_sys_write.c b/remote_io/rio_sys_write.c
new file mode 100644
index 0000000000..4e3db0404d
--- /dev/null
+++ b/remote_io/rio_sys_write.c
@@ -0,0 +1,62 @@
+/* writev system call forwarding.
+ *
+ * Eventually, this needs to be agnostic to the C library...
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "message.h"
+#include "server.h"
+
+#include <ldsodefs.h>
+
+void
+rio_get_write (struct pcn_msg_hdr *hdr, int fd)
+{
+  struct pcn_write_msg *msg = malloc (hdr->msg_size);
+  struct pcn_msg_res res;
+  int mfd;
+  long mcount, offset;
+
+  res.res = rio_msg_get (fd, msg, hdr->msg_size);
+  mfd = msg->fd;
+  mcount = msg->size;
+  offset = msg->offset;
+
+  errno = hdr->msg_errno;
+
+  if (hdr->msg_kind == PCN_SYS_WRITE)
+    res.res = lio_write (mfd, msg->buf, mcount);
+  else if (hdr->msg_kind == PCN_SYS_PWRITE)
+    res.res = lio_pwrite (mfd, msg->buf, mcount, offset);
+  else
+    lio_error ("%s: unexpected write type %d", __FUNCTION__, hdr->msg_kind);
+
+  free (msg);
+
+  res.rio_errno = errno;
+  res.id = hdr->msg_id;
+
+  if (hdr->msg_kind == PCN_SYS_WRITE)
+    rio_dbg_printf ("%s[%u]: WRITE: fd = %u, count = %ld -- res = %d, errno = %d\n",
+	            __FUNCTION__, hdr->msg_id, mfd, mcount, res.res,
+                    res.rio_errno);
+  else if (hdr->msg_kind == PCN_SYS_PWRITE)
+    rio_dbg_printf ("%s[%u]: PWRITE: fd = %u, count = %ld, offset = %ld -- res = %d, errno = %d\n",
+	            __FUNCTION__, hdr->msg_id, mfd, mcount, offset, res.res,
+                    res.rio_errno);
+
+  rio_msg_res (fd, &res);
+
+  //lio_assert_empty_socket (fd);
+}
diff --git a/remote_io/rio_util.c b/remote_io/rio_util.c
new file mode 100644
index 0000000000..2956206bef
--- /dev/null
+++ b/remote_io/rio_util.c
@@ -0,0 +1,201 @@
+#include <sys/prctl.h>
+#include <elf/popcorn.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "server.h"
+#include "message.h"
+
+static char **pcn_orig_argv;
+
+static void
+move_environ (void)
+{
+  char *endp = NULL, *new_envp;
+  long size;
+  int i, len;
+
+  /* Determine the total size of environment variables. */
+  for (i = 0; pcn_data->envp[i] != NULL; i++)
+    endp = pcn_data->envp[i] + lio_strlen (pcn_data->envp[i]);
+
+  size = (uintptr_t) endp - (uintptr_t) pcn_data->envp[0];
+  new_envp = lio_malloc (size);
+
+  /* Update environ.  */
+  for (i = 0, endp = new_envp; pcn_data->envp[i] != NULL; i++)
+    {
+      len = lio_strlen (pcn_data->envp[i]);
+      lio_memcpy (endp, pcn_data->envp[i], len);
+      pcn_data->envp[i] = endp;
+      endp += len;
+    }
+}
+
+void
+rio_set_servername (void)
+{
+  static int sname_offset = 0;
+  char servername[16]; // Limit set by prctl
+  int len = lio_strlen (pcn_data->argv[0]);
+  int i;
+
+  /* Backup argv.  */
+  pcn_orig_argv = lio_malloc (sizeof (char *) * pcn_data->argc);
+  for (i = 0; i < pcn_data->argc; i++)
+    pcn_orig_argv[i] = lio_strdup (pcn_data->argv[i]);
+
+  if (sname_offset == 0)
+    {
+      move_environ ();
+      sname_offset = len;
+    }
+
+  rio_dbg_snprintf (servername, 16, "[RIO %u]", pcn_data->rio_child_pid);
+  lio_memcpy (pcn_data->argv[0] + sname_offset, servername,
+              lio_strlen (servername)+1);
+  lio_prctl (PR_SET_NAME, (unsigned long) servername);
+}
+
+int
+rio_disable (void)
+{
+  int t = pcn_data->pcn_remote_io_active;
+
+  pcn_data->pcn_remote_io_active = 0;
+
+  return t;
+}
+
+void
+rio_restore (int t)
+{
+  pcn_data->pcn_remote_io_active = t;
+}
+
+int
+rio_debug (void)
+{
+  switch (pcn_data->rio_debug)
+    {
+      case RIO_DEBUG_ALL: return 1;
+      case RIO_DEBUG_SERVER: return pcn_mode == 1;
+      case RIO_DEBUG_CLIENT: return pcn_mode == 0;
+      default: return 0;
+    }
+}
+
+void
+rio_poll_init_time (struct timespec *t_dur, struct timespec *t_end)
+{
+  struct timespec cur;
+
+  if (t_dur == NULL || t_dur->tv_sec == -1)
+    {
+      t_end->tv_sec = -1;
+      t_end->tv_nsec = 0;
+      return;
+    }
+
+  clock_gettime (CLOCK_REALTIME, &cur);
+  t_end->tv_sec = t_dur->tv_sec + cur.tv_sec;
+  t_end->tv_nsec = t_dur->tv_nsec + cur.tv_nsec;
+}
+
+/* Return 1 if the timer as expired, zero otherwise.  */
+int
+rio_poll_interval (struct timespec *t_next, struct timespec *t_end)
+{
+  struct timespec cur, diff;
+
+  if (t_end == NULL || t_end->tv_sec == -1)
+    {
+      t_next->tv_sec = RIO_POLL_INTERVAL_S;
+      t_next->tv_nsec = RIO_POLL_INTERVAL_NS;
+      return 0;
+    }
+
+    clock_gettime (CLOCK_REALTIME, &cur);
+    cur.tv_sec += RIO_POLL_INTERVAL_S;
+
+    diff.tv_sec = t_end->tv_sec - cur.tv_sec;
+    diff.tv_nsec = t_end->tv_nsec - cur.tv_nsec;
+
+    if (diff.tv_nsec < 0)
+      {
+        diff.tv_sec--;
+        diff.tv_nsec += 1000000000L;
+      }
+
+    if (diff.tv_sec < 0)
+      {
+        t_next->tv_sec = 0;
+        t_next->tv_nsec = 1;
+        return 1;
+      }
+    else if (diff.tv_sec <= RIO_POLL_INTERVAL_S)
+      {
+        t_next->tv_sec = diff.tv_sec;
+        t_next->tv_nsec = diff.tv_nsec;
+      }
+    else
+      {
+        t_next->tv_sec = RIO_POLL_INTERVAL_S;
+        t_next->tv_nsec = RIO_POLL_INTERVAL_NS;
+      }
+
+  return 0;
+}
+
+void
+rio_poll (struct pcn_msg_hdr *hdr)
+{
+  int status;
+
+  while (1)
+    {
+      rio_msg_get (pcn_data->pcn_server_sockfd, &status, sizeof (int));
+      rio_dbg_printf ("%s: received %d\n", __FUNCTION__, status);
+
+      if (status == PCN_POLL_RIO_COMPLETE)
+	break;
+      else if (rio_signal_pending ())
+	{
+          rio_dbg_printf ("%s: detected a signal\n", __FUNCTION__);
+	  hdr->msg_kind = PCN_POLL_STOP;
+	  rio_msg_send (pcn_data->pcn_server_sockfd, hdr);
+          break;
+	}
+      else
+	{
+	  rio_enable_signals ();
+	  check_migrate (NULL, NULL);
+	  rio_disable_signals ();
+
+	  hdr->msg_kind = PCN_POLL_RESUME;
+	  rio_msg_send (pcn_data->pcn_server_sockfd, hdr);
+	}
+    }
+}
+
+/* At present, rio_restart_disabled is expected to be called before the main
+   application migrates to a different machine.  */
+void
+rio_restart_disabled (void)
+{
+  const char *envp[] = { "PCN_RIO_LOCAL=1", NULL };
+  int res, i;
+
+  for (i = 0; i < pcn_data->argc; i++)
+    rio_dbg_printf ("%s: argv[%d] = %s\n", __FUNCTION__, i, pcn_orig_argv[i]);
+
+  /* Wait for the RIO client to hang up.  */
+  wait (&i);
+
+  res =  lio_execve (pcn_orig_argv[0], pcn_orig_argv, (char **const) envp);
+
+  if (res < 0)
+    lio_error ("%s: execve failed\n", __FUNCTION__);
+}
diff --git a/remote_io/rio_vma.c b/remote_io/rio_vma.c
new file mode 100644
index 0000000000..edcf4a5f19
--- /dev/null
+++ b/remote_io/rio_vma.c
@@ -0,0 +1,549 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+#include <elf/popcorn.h>
+#include "remote_io.h"
+#include "local_io.h"
+#include "server.h"
+#include "message.h"
+
+#define __USE_GNU 1
+#include <search.h>
+
+void *rio_fd_root = NULL;
+void *rio_fd_closed = NULL;
+void *rio_mmap_root = NULL;
+static int rio_fd_init = 0;
+
+static int
+fdinfo_cmp_fn (const void *l, const void *r)
+{
+  const struct fdinfo *ll = l;
+  const struct fdinfo *rr = r;
+
+  return ll->fd - rr->fd;
+}
+
+static int
+mmapinfo_cmp_fn (const void *l, const void *r)
+{
+  const struct mmapinfo *ll = l;
+  const struct mmapinfo *rr = r;
+
+  return (long)ll->addr - (long)rr->addr;
+}
+
+void
+rio_fd_init_special (void)
+{
+  /* Initialize special file descriptors for STDIN, STDOUT, and STDERR.
+     This needs to be done late, because otherwise, libc functions, such as
+     malloc may not be available yet.  */
+  if (__glibc_unlikely (!rio_fd_init))
+    {
+      rio_fd_open_special (0, RIO_FD_STDIN);
+      rio_fd_open_special (1, RIO_FD_STDOUT);
+      rio_fd_open_special (2, RIO_FD_STDERR);
+      rio_fd_init = 1;
+    }
+}
+
+struct fdinfo *
+rio_fd_open (int fd, int flags, mode_t mode, char *name)
+{
+  struct fdinfo *fdp;
+  struct fdinfo **t;
+  struct file_info *fi;
+
+  if (fd < 0)
+    return NULL;
+
+  fdp = (struct fdinfo *) malloc (sizeof (struct fdinfo));
+  fi = malloc (sizeof (struct file_info));
+
+  fi->refcount = 1;
+  fi->flags = flags;
+  fi->mode = mode;
+  fi->status = 0;
+  fi->name = strdup (name);
+  fi->lname = NULL;
+  fi->type = RIO_FD_FILE;
+  fi->arg = 0;
+
+  fdp->fd = fd;
+  fdp->fi = fi;
+
+  t = tsearch (fdp, &rio_fd_root, fdinfo_cmp_fn);
+  if (t == NULL)
+    {
+      rio_dbg_printf ("%s: failed to access rio_fd_root\n", __FUNCTION__);
+      lio_exit (EXIT_FAILURE);
+    }
+
+//    rio_dbg_printf ("%s: fd = %u, flags = %u, mode = %u, name = %s\n",
+//		  __FUNCTION__, (*t)->fd, (*t)->fi->flags, (*t)->fi->mode, (*t)->fi->name);
+
+  return fdp;
+}
+
+struct fdinfo *
+rio_fd_open_special (int fd, int type)
+{
+  struct fdinfo *fdp = (struct fdinfo *) malloc (sizeof (struct fdinfo));
+  struct fdinfo **t;
+  struct file_info *fi = malloc (sizeof (struct file_info));
+
+  fi->refcount = 1;
+  fi->flags = 0;
+  fi->mode = 0;
+  fi->status = 0;
+  fi->name = NULL;
+  fi->lname = NULL;
+  fi->type = type;
+  fi->arg = 0;
+
+  switch (type)
+    {
+      case RIO_FD_SOCKET:
+	fi->name = "SOCKET";
+	break;
+
+      case RIO_FD_EPOLL:
+	fi->name = "EPOLL";
+	break;
+
+      case RIO_FD_ACCEPT:
+	fi->name = "ACCEPT";
+	break;
+
+      case RIO_FD_DUP:
+	fi->name = "DUP";
+	break;
+
+      case RIO_FD_PIPE:
+	fi->name = "PIPE";
+	break;
+
+      case RIO_FD_MMAP:
+	fi->name = "MMAP";
+	break;
+
+      case RIO_FD_STDIN:
+	fi->name = "STDIN";
+	break;
+
+      case RIO_FD_STDOUT:
+	fi->name = "STDOUT";
+	break;
+
+      case RIO_FD_STDERR:
+	fi->name = "STDERR";
+	break;
+
+      default:
+	fi->name = "SPECIAL";
+    }
+
+  fdp->fd = fd;
+  fdp->fi = fi;
+
+  t = tsearch (fdp, &rio_fd_root, fdinfo_cmp_fn);
+  if (t == NULL)
+    {
+      rio_dbg_printf ("%s: failed to access rio_fd_root\n", __FUNCTION__);
+      lio_exit (EXIT_FAILURE);
+    }
+
+//  rio_dbg_printf ("%s: fd = %u, flags = %u, mode = %u, name = %s\n",
+//		  __FUNCTION__, (*t)->fd, (*t)->fi->flags,
+//		  (*t)->fi->mode, (*t)->fi->name);
+
+  return fdp;
+}
+
+void
+rio_fd_dup (int orig_fd, int dup_fd)
+{
+  struct fdinfo *orig_pfd, *dup_pfd, **t;
+  struct file_info *fi;
+
+  orig_pfd = rio_fd_find (orig_fd);
+  LIO_ASSERT (orig_pfd != NULL, "unrecognized fd");
+  fi = orig_pfd->fi;
+
+  dup_pfd = malloc (sizeof (struct file_info));
+
+  dup_pfd->fd = dup_fd;
+  dup_pfd->fi = fi;
+
+  t = tsearch (dup_pfd, &rio_fd_root, fdinfo_cmp_fn);
+  if (t == NULL)
+    {
+      rio_dbg_printf ("%s: failed to access rio_fd_root\n", __FUNCTION__);
+      lio_exit (EXIT_FAILURE);
+    }
+
+  fi->refcount++;
+}
+
+struct fdinfo *
+rio_fd_find (int fd)
+{
+  struct fdinfo t, **res;
+
+  t.fd = fd;
+  res = tfind (&t, &rio_fd_root, fdinfo_cmp_fn);
+
+/*
+  if (res != NULL)
+    rio_dbg_printf ("%s: fd = %u, name = %s\n", __FUNCTION__, fd, (*res)->name);
+  else
+    rio_dbg_printf ("%s: fd = %u, missing\n", __FUNCTION__, fd);
+*/
+
+  return res == NULL ? NULL : *res;
+}
+
+void
+rio_fd_rm (struct fdinfo *fd)
+{
+  //rio_dbg_printf ("%s: fd = %u, name = %s\n", __FUNCTION__, fd->fd, fd->name);
+  tdelete (fd, &rio_fd_root, fdinfo_cmp_fn);
+}
+
+void
+rio_fd_close (struct fdinfo *pfd, int sockfd, int mid)
+{
+  struct file_info *pfi = pfd->fi;
+
+//  rio_dbg_printf ("%s: closing %d @ %lx\n", __FUNCTION__, pfd->fd, pfi);
+
+  rio_fd_rm (pfd);
+  free (pfd);
+
+  if (--pfi->refcount == 0)
+    {
+      if (pfi->refcount == 0 && (pfi->status & RIO_FD_DIRTY))
+	rio_file_sync (sockfd, mid, pfi);
+
+      if (pfi->type == RIO_FD_FILE && pfi->name)
+        free ((char *)pfi->name);
+
+      if (pfi->lname)
+        free ((char *)pfi->lname);
+
+      free (pfi);
+    }
+}
+
+void
+rio_mmap_close (struct mmapinfo *pmi, int sockfd, int mid)
+{
+  struct file_info *pfi = pmi->fi;
+
+  rio_mmap_rm (pmi);
+  free (pmi);
+
+  if (--pfi->refcount == 0)
+    {
+      if (pfi->refcount == 0 && (pfi->status & RIO_FD_DIRTY))
+	rio_file_sync (sockfd, mid, pfi);
+
+      free (pfi);
+    }
+}
+
+
+struct mmapinfo *
+rio_mmap_add (struct file_info *pfi, void *addr, int len, int prot, int flags)
+{
+  struct mmapinfo *mp = malloc (sizeof (struct mmapinfo));
+  struct mmapinfo **t;
+
+  mp->fi = pfi;
+  mp->addr = addr;
+  mp->len = len;
+  mp->prot = prot;
+  mp->flags = flags;
+
+  t = tsearch (mp, &rio_mmap_root, mmapinfo_cmp_fn);
+
+  rio_dbg_printf ("%s: inserting map @ %lx\n", __FUNCTION__, addr);
+
+  assert (*t == mp);
+
+  return NULL;
+}
+
+struct mmapinfo *
+rio_mmap_find (void *addr)
+{
+  struct mmapinfo t;
+
+  t.addr = addr;
+
+  return *(struct mmapinfo **)tsearch (&t, &rio_mmap_root, mmapinfo_cmp_fn);
+}
+
+void
+rio_mmap_rm (struct mmapinfo *map)
+{
+  tdelete (map, &rio_mmap_root, mmapinfo_cmp_fn);
+}
+
+/* File I/O Operations.  */
+
+/* This function cannot be linked with ld-linux, because it contains
+   too may libc dependencies.  */
+static const char *
+rio_temp_file_name (const char *fname)
+{
+  const char *base, *t;
+  char *res;
+  int l1, l2;
+
+  for (base = t = fname; *t != '\0'; t++)
+    if (*t == '/')
+      {
+	base = t+1;
+      }
+
+  /* Eventually the filename will need to be somewhat randomized.  */
+  //asprintf (&pfd->lname, "%s/%s.%d", pcn_data->pcn_storage, fname, rand());
+  //asprintf (&res, "%s/%s", pcn_data->pcn_storage, base);
+  l1 = lio_strlen (pcn_data->pcn_storage);
+  l2 = lio_strlen (base);
+  res = malloc (l1 + l2 + 2);
+  rio_dbg_snprintf (res, l1 + l2 + 2, "%s/%s", pcn_data->pcn_storage, base);
+
+  return res;
+}
+
+/* Open a file locally on the client.  */
+#if 0
+static int
+rio_copy_file_local (int sockfd, int mid, struct fdinfo *pfd)
+{
+  struct pcn_msg_io_open iop = {0};
+  struct iovec payload[2];
+  int res;
+
+  if (pfd->lname != NULL)
+    return pfd->fd;
+
+  rio_init_tmpdir ();
+
+  pfd->lname = rio_temp_file_name (pfd->name);
+
+  /* Check if a cached copy of the file already exists,
+     and remove it if present.  */
+
+  rio_maybe_zap_file (pfd->lname);
+
+  /* Create a hardlink of the file.  */
+  res = lio_link (pfd->name, pfd->lname);
+
+  rio_dbg_printf ("%s[%u]: linking %s -> %s (%d)\n",
+		  __FUNCTION__, mid, pfd->name, pfd->lname, res);
+
+  // Now open the file
+
+  iop.open.dirfd = pfd->fd;
+  iop.open.flags = pfd->flags;
+  iop.open.mode = pfd->mode;
+  iop.hdr.msg_size = sizeof (struct pcn_msg_open) + strlen (pfd->lname) + 1;
+  iop.hdr.msg_id = mid;
+  iop.hdr.msg_kind = PCN_SYS_OPEN;
+  iop.hdr.msg_type = PCN_TYPE_RES;
+
+  rio_dbg_printf ("%s[%u]: res = { dirfd = %d, flags = %d, mode = %d }\n",
+	      __FUNCTION__, mid, iop.open.dirfd, iop.open.flags, iop.open.mode);
+
+  payload[0].iov_base = &iop;
+  payload[0].iov_len = sizeof (iop);
+  payload[1].iov_base = pfd->lname;
+  payload[1].iov_len = strlen (pfd->lname) + 1;
+
+  res = lio_writev (sockfd, payload, 2);
+  rio_dbg_printf ("%s[%u]: sent %u bytes for struct iop\n",
+	      __FUNCTION__, mid, res);
+
+  return pfd->fd;
+}
+#endif
+
+static int
+rio_copy_file_remote (int fd, int mid, struct fdinfo *pfd)
+{
+  struct pcn_msg_io_open iop = {0};
+  struct pcn_msg_io_data iod = {0};
+  struct pcn_msg_hdr ack;
+  struct iovec payload[2];
+  struct stat st;
+  struct file_info *pfi = pfd->fi;
+  int res, sent;
+  off_t offset = 0;
+
+  if (pfi->lname)
+    return pfd->fd;
+
+  pfi->lname = rio_temp_file_name (pfi->name);
+
+  /* Instruct the client to expect to receive a file.  */
+  iop.hdr.msg_kind = PCN_SYS_OPEN;
+  iop.hdr.msg_type = PCN_TYPE_RES;
+  iop.hdr.msg_id = mid;
+  iop.hdr.msg_size = sizeof (struct pcn_msg_open) + lio_strlen (pfi->lname) + 1;
+
+  iop.open.dirfd = -pfd->fd;
+  iop.open.flags = pfi->flags;
+  iop.open.mode = pfi->mode;
+
+  payload[0].iov_base = &iop;
+  payload[0].iov_len = sizeof (iop);
+  payload[1].iov_base = (void *)pfi->lname;
+  payload[1].iov_len = lio_strlen (pfi->lname) + 1;
+
+/*
+  rio_dbg_printf ("%s: iop.hdr.msg_kind = %u\n", __FUNCTION__, iop.hdr.msg_kind);
+  rio_dbg_printf ("%s: iop.hdr.msg_type = %u\n", __FUNCTION__, iop.hdr.msg_type);
+  rio_dbg_printf ("%s: iop.hdr.msg_id = %u\n", __FUNCTION__, iop.hdr.msg_id);
+  rio_dbg_printf ("%s: iop.hdr.msg_size = %u\n", __FUNCTION__, iop.hdr.msg_size);
+*/
+
+  rio_dbg_printf ("%s[%u]: open = { dirfd = %d, flags = %u, mode = %u, pathname = %s, size = %d }\n",
+		  __FUNCTION__, mid, iop.open.dirfd, iop.open.flags, iop.open.mode,
+		  pfi->lname, st.st_size);
+
+  res = lio_writev (fd, payload, 2);
+
+  rio_msg_get (fd, &ack, sizeof (ack));
+
+  /* Send the file over the wire.  */
+  lio_fstat (pfd->fd, &st);
+
+  iod.hdr.msg_kind = PCN_SYS_READ;
+  iod.hdr.msg_type = PCN_TYPE_RES;
+  iod.hdr.msg_id = mid;
+  iod.hdr.msg_size = sizeof (struct pcn_msg_read);
+  iod.data.fd = pfd->fd;
+  iod.data.cnt = st.st_size;
+
+  lio_write (fd, &iod, sizeof (iod));
+
+  sent = 0;
+
+  while (sent < st.st_size)
+    {
+      res = lio_sendfile (fd, pfd->fd, &offset, st.st_size - sent);
+
+      if (res < 0)
+	lio_error ("failed to send file\n");
+
+      sent += res;
+    }
+
+  rio_dbg_printf ("%s[%u]: sent file '%s', size = '%u' bytes\n",
+		  __FUNCTION__, mid, pfi->lname, sent);
+
+  ack.msg_id = mid;
+  ack.msg_type = PCN_TYPE_CONTROL;
+  ack.msg_kind = PCN_CTL_ACK;
+  ack.msg_async = PCN_SEND_NORET;
+  ack.msg_size = sizeof (ack);
+
+  rio_msg_send (fd, &ack);
+
+  return pfd->fd;
+}
+
+/* Create a local copy of a file residing on the host to the remote.  */
+int
+rio_file_copy (int fd, int mid, struct fdinfo *pfd)
+{
+//  if (pd->pcn_server_ip == pd->pcn_local_ip)
+//    return rio_copy_file_local (fd, mid, pfd);
+//  else
+    return rio_copy_file_remote (fd, mid, pfd);
+}
+
+int
+rio_file_sync_remote (int sockfd, int mid, struct file_info *pfi)
+{
+  struct pcn_msg_hdr hdr;
+  struct pcn_msg_hdr fin;
+  struct iovec args;
+  struct stat st;
+  void *addr;
+  int fd, recv, res;
+
+  hdr.msg_kind = PCN_TYPE_CONTROL;
+  hdr.msg_type = PCN_CTL_SYNC;
+  hdr.msg_id = mid;
+  hdr.msg_async = PCN_SEND_NORET;
+  hdr.msg_size = strlen (pfi->lname) + 1;
+
+  args.iov_base = (void *)pfi->lname;
+  args.iov_len = hdr.msg_size;
+
+  rio_msg_send_iov (sockfd, &hdr, &args, 1);
+
+  fd = lio_open (pfi->name, O_CREAT | O_RDWR, pfi->mode);
+  if (fd < 0)
+    lio_error ("%s: failed to open file '%s'\n", __FUNCTION__, pfi->name);
+
+  lio_fstat (fd, &st);
+  rio_dbg_printf ("%s[%u]: syncing remote file '%s', size = %u bytes\n",
+		  __FUNCTION__, mid, pfi->name, st.st_size);
+
+  addr = lio_mmap (NULL, st.st_size, PROT_WRITE, MAP_SHARED, fd, 0);
+  if (addr == (void *)-1)
+    lio_error ("%s: failed to mmap '%s'\n", __FUNCTION__, pfi->name);
+
+  recv = 0;
+  while (recv < st.st_size)
+    {
+      res = lio_read (sockfd, addr + recv, st.st_size - recv);
+
+      if (res < 0)
+	lio_error ("%s[%u]: failed to receive file, res = %u\n",
+		   __FUNCTION__, mid, res);
+
+      recv += res;
+      rio_dbg_printf ("%s[%u]: received %u bytes (%u)\n",
+		      __FUNCTION__, mid, recv, res);
+    }
+
+  lio_munmap (addr, st.st_size);
+  lio_close (fd);
+
+  fin.msg_id = mid;
+  fin.msg_type = PCN_TYPE_CONTROL;
+  fin.msg_kind = PCN_CTL_ACK;
+  fin.msg_async = PCN_SEND_NORET;
+  fin.msg_size = sizeof (fin);
+
+  //rio_msg_send (sockfd, &fin);
+
+  return st.st_size;
+}
+
+/* Synchronize a copy of file represented by PFI, by transferring
+   the client's version of the file back to the server. This function
+   defers syncronization until the file's reference count has reached
+   zero. Eventually, this could be optimized by only copying the part
+   of the file that has been modifed.  */
+int
+rio_file_sync (int sockfd, int mid, struct file_info *pfi)
+{
+  if (pfi->refcount > 0)
+    return 0;
+
+  return rio_file_sync_remote (sockfd, mid, pfi);
+}
diff --git a/remote_io/server.h b/remote_io/server.h
new file mode 100644
index 0000000000..399db9c805
--- /dev/null
+++ b/remote_io/server.h
@@ -0,0 +1,185 @@
+#ifndef SERVER_H
+#define SERVER_H
+
+#include <stdint.h>
+#include <signal.h>
+
+struct pcn_msg_hdr;
+
+/* TCP Port (KILLD) for popcorn_killd.  */
+#define POPCORN_KILLD_PORT 54553
+
+// See /proc/self/limits for the actual limit
+#define RIO_MAX_OPENED_FILES 1024
+
+#define RIO_FD_OPENED  (1 << 0)
+#define RIO_FD_DIRTY (1 << 1)
+
+/* Name of the directory for stashing local copy of mmap'ed filed.  */
+#define PCN_TMP_DIR ".pcn"
+
+#define RIO_FD_FILE 1
+#define RIO_FD_SOCKET 2
+#define RIO_FD_EPOLL 3
+#define RIO_FD_ACCEPT 4
+#define RIO_FD_DUP 5
+#define RIO_FD_PIPE 6
+#define RIO_FD_SIGNALFD 7
+#define RIO_FD_MMAP 8
+#define RIO_FD_SHM 9
+#define RIO_FD_STDIN 10
+#define RIO_FD_STDOUT 11
+#define RIO_FD_STDERR 12
+
+#define RIO_POLL_INTERVAL_S 1
+#define RIO_POLL_INTERVAL_MS 1000
+#define RIO_POLL_INTERVAL_NS 0
+
+// Are NAME and LNAME supposed to be malloc'ed?
+struct file_info {
+  mode_t mode;
+  int refcount;
+  int flags;
+  unsigned int status;
+  unsigned int type;
+  unsigned long arg;
+  const char *name; /* Name of the original file.  */
+  const char *lname; /* Name of the locally cached file.  */
+};
+
+/* Might need also need to keep track of the parent process so that
+   if the application client forks, the rio_server can jump to its parent
+   fdinfo map and search for the FD there.  A negative FD indicates that
+   a file has been closed, but may still be mapped.  */
+struct fdinfo {
+  int fd;
+  struct file_info *fi;
+};
+
+struct mmapinfo {
+  struct file_info *fi;
+  void *addr;
+  long len;
+  int prot;
+  int flags;
+};
+
+struct stat;
+struct pollfd;
+struct pcn_msg_open;
+struct pcn_msg_hdr;
+struct pcn_msg_res;
+
+extern struct fdinfo *rio_fd;
+extern struct mmapinfo *rio_mmap;
+
+// Need to add cleanup functions (rio_fd_destroy/rio_mmap_destroy)
+extern struct fdinfo *rio_fd_open (int fd, int flags, mode_t mode, char *name);
+extern struct fdinfo *rio_fd_open_special (int fd, int type);
+extern struct fdinfo *rio_fd_find (int fd);
+extern void rio_fd_close (struct fdinfo *fd, int sockfd, int mid);
+extern void rio_fd_dup (int orig_fd, int dup_fd);
+extern void rio_fd_init_special (void);
+extern void rio_fd_rm (struct fdinfo *fd);
+
+extern struct mmapinfo *rio_mmap_add (struct file_info *pfi, void *addr,
+                                      int len, int prot, int flags);
+extern struct mmapinfo *rio_mmap_find (void *addr);
+extern void rio_mmap_rm (struct mmapinfo *map);
+extern void rio_mmap_close (struct mmapinfo *pmi, int sockfd, int mid);
+
+extern int rio_file_create (int fd);
+extern int rio_file_rm (int fd);
+
+extern int rio_file_copy (int sockfd, int mid, struct fdinfo *pfd);
+extern int rio_file_sync (int sockfd, int mid, struct file_info *pfi);
+
+extern void rio_poll_init_time (struct timespec *t_dur, struct timespec *t_end);
+extern int rio_poll_interval (struct timespec *t_cur, struct timespec *t_end);
+extern int do_rio_poll (int *fd);
+extern void rio_poll (struct pcn_msg_hdr *hdr);
+
+extern uint32_t pcn_get_ip (void);
+extern int rio_get_read (struct pcn_msg_hdr *hdr, int fd);
+extern void rio_get_write (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_open (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_close (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_fxstatat (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_fallocate (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_mmap (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_munmap (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_epoll_create (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_epoll_ctl (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_epoll_wait (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_epoll_pwait (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_poll (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_sigaction (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_fcntl (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_getcwd (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_socket (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_bind (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_getsockopt (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_setsockopt (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_listen (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_pipe (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_accept (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_connect (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_pread (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_access (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_uname (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_sock_getname (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_recvfrom (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_recvmsg (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_send (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_sendto (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_dup (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_getdents64 (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_chdir (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_chmod (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_sync (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_ftruncate64 (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_truncate64 (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_link (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_unlink (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_symlink (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_readlink (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_mkdir (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_rmdir (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_rename (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_umask (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_lseek64 (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_sync_file_range (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_kill (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_select (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_pselect (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_statfs (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_fstatfs (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_setitimer (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_getitimer (struct pcn_msg_hdr *hdr, int fd);
+extern int rio_get_signalfd (struct pcn_msg_hdr *hdr, int fd);
+
+extern int rio_get_file (struct pcn_msg_open *msg, int fd);
+extern int rio_send_file (struct pcn_msg_hdr *hdr);
+extern void rio_init_tmpdir (void);
+extern void rio_maybe_zap_file (const char *fname);
+extern void rio_forward_signals (void);
+extern void rio_signal_forwarder (int sig, siginfo_t *si, void *arg);
+extern void rio_sig_forward_mask (unsigned long mask);
+extern void rio_sig_restore_mask (unsigned long mask);
+
+extern int __do_fxstatat(int vers, int fd, const char *file, struct stat *st,
+			 int flag);
+
+extern int rio_disable (void);
+extern void rio_restore (int);
+
+extern void do_rio_server_migrate (struct pcn_msg_hdr *, int);
+extern void do_rio_server_attach (struct pcn_msg_hdr *hdr, int fd);
+
+extern void rio_client_hangup (int sockfd);
+extern void rio_restart_disabled (void);
+
+extern void check_migrate (void *, void *);
+libc_hidden_proto (check_migrate)
+
+#endif
diff --git a/remote_io/test-1.c b/remote_io/test-1.c
new file mode 100644
index 0000000000..b1e67c0314
--- /dev/null
+++ b/remote_io/test-1.c
@@ -0,0 +1,87 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64-popcorn-linux-gnu/sysroot/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64-popcorn-linux-gnu/sysroot/lib/ t.c
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+struct mmap_entries {
+  unsigned long start, size;
+};
+
+extern void _dl_rio_print_dso ();
+extern struct mmap_entries *_dl_rio_get_mmap_entries ();
+
+char msg[] = "munmap complete: ";
+char msg_fail[] = "failed\n";
+char msg_succ[] = "succeeded\n";
+
+int
+do_munmap (unsigned long addr, unsigned long len)
+{
+  int ret;
+
+  asm volatile ("syscall"
+		: "=a" (ret)
+		: "0"(SYS_munmap), "D"(addr), "S"(len));
+
+  return ret;
+}
+
+int
+do_write (int fd, unsigned long addr, unsigned long len)
+{
+  int ret;
+
+  asm volatile ("syscall"
+		: "=a" (ret)
+		: "0"(SYS_write), "D"(fd), "S"(addr), "d"(len)
+		: "rcx", "r11", "memory");
+
+  return ret;
+}
+
+int
+main ()
+{
+  struct mmap_entries *me;
+  unsigned long size;
+  int i, ret, len[3];
+  int ps = sysconf(_SC_PAGE_SIZE);
+
+  printf ("pid = %d\n", getpid ());
+
+  _dl_rio_print_dso ();
+
+  me = _dl_rio_get_mmap_entries ();
+
+  len[0] = strlen (msg);
+  len[1] = strlen (msg_fail);
+  len[2] = strlen (msg_succ);
+
+  for (i = 0; me[i].size != 0; i++)
+    {
+      //ret = syscall (SYS_munmap, me[i].start, me[i].size);
+      //ret = mprotect (&me[i].start, me[i].size, PROT_READ);
+
+      do_munmap (me[i].start, me[1].size);
+      do_write (1, msg, len[0]);
+
+      if (ret)
+	do_write (1, msg_fail, len[1]);
+      else
+	do_write (1, msg_succ, len[2]);
+
+//      if (ret)
+//	{
+//	  perror ("munmap");
+//	  printf ("  %lx - %d\n", me[i].start, me[i].size);
+//	}
+    }
+
+  while (i != 0)
+    ;
+
+  return 0;
+}
diff --git a/remote_io/test-access.c b/remote_io/test-access.c
new file mode 100644
index 0000000000..8ff6d702f1
--- /dev/null
+++ b/remote_io/test-access.c
@@ -0,0 +1,16 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-access.c -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-access.c -g
+
+#include <stdio.h>
+#include <unistd.h>
+
+int
+main ()
+{
+  int res = access (__FILE__, F_OK);
+
+  printf ("Access '%s' = %d\n", __FILE__, res);
+
+  return 0;
+}
diff --git a/remote_io/test-close-special.c b/remote_io/test-close-special.c
new file mode 100644
index 0000000000..b481aea550
--- /dev/null
+++ b/remote_io/test-close-special.c
@@ -0,0 +1,9 @@
+#include <stdio.h>
+#include <unistd.h>
+
+int
+main ()
+{
+  close (STDERR_FILENO);
+  return 0;
+}
diff --git a/remote_io/test-dgram-client.c b/remote_io/test-dgram-client.c
new file mode 100644
index 0000000000..f5b21c77ea
--- /dev/null
+++ b/remote_io/test-dgram-client.c
@@ -0,0 +1,69 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-dgram-client.c -g -o tdc.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-dgram-client.c -g -o tdc.a64.exe
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+
+#include <string.h>
+
+#define PORT 3124
+
+int
+main (int argc, char *argv[])
+{
+  int sockfd, n, res;
+  struct sockaddr_in sa;
+
+  if (argc < 3)
+    {
+      fprintf(stderr,"Usage: %s hostname \"message\"\n", argv[0]);
+      exit(0);
+    }
+
+  sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+
+  if (sockfd < 0)
+    {
+      perror("ERROR opening socket");
+      exit(1);
+    }
+
+  //server = gethostbyname (argv[1]);
+  //if (server == NULL)
+  //  {
+  //    fprintf (stderr,"ERROR, no such host\n");
+  //    exit (EXIT_FAILURE);
+  //  }
+
+  res = inet_pton (AF_INET, argv[1], &sa.sin_addr);
+  if (res != 1)
+    {
+      fprintf (stderr, "ERROR: no such host\n");
+      exit (EXIT_FAILURE);
+    }
+
+  sa.sin_port = htons (PORT);
+
+  n = sendto (sockfd, argv[2], strlen (argv[2]), 0,
+	      (struct sockaddr *)&sa, sizeof (sa));
+
+  if (n < 0)
+    {
+      perror ("ERROR writing to socket");
+      fprintf (stderr, "errno = %d\n", errno);
+      exit (1);
+    }
+
+  close (sockfd);
+
+  printf ("sent> %s\n", argv[2]);
+
+  return 0;
+}
diff --git a/remote_io/test-dgram-recvmsg.c b/remote_io/test-dgram-recvmsg.c
new file mode 100644
index 0000000000..0305b439a9
--- /dev/null
+++ b/remote_io/test-dgram-recvmsg.c
@@ -0,0 +1,92 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-dgram-recvmsg.c -g -o tdr.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-dgram-recvmsg.c -g -o tdr.a64.exe
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <string.h>
+
+#define PORT 3124
+
+int
+main (int argc, char *argv[])
+{
+  int sockfd, len;
+  char hdr[4], payload[256], ip[INET6_ADDRSTRLEN];
+  struct sockaddr_in saddr, caddr, *s;
+  struct sockaddr_storage addr;
+  struct iovec iov[2];
+  struct msghdr mhdr;
+  struct cmsghdr chdr;
+  int n;
+
+  bzero (&mhdr, sizeof mhdr);
+  bzero (&chdr, sizeof chdr);
+
+  sockfd = socket (AF_INET, SOCK_DGRAM, 0);
+
+  if (sockfd < 0)
+    {
+      perror("ERROR opening socket");
+      exit(1);
+    }
+
+  bzero ((char *) &saddr, sizeof (saddr));
+
+  saddr.sin_family = AF_INET;
+  saddr.sin_addr.s_addr = INADDR_ANY;
+  saddr.sin_port = htons(PORT);
+
+  if (bind(sockfd, (struct sockaddr *) &saddr, sizeof (saddr)) < 0)
+    {
+      perror("ERROR on binding");
+      exit(1);
+    }  
+
+  bzero (hdr, 4);
+  bzero (payload, 256);
+
+  iov[0].iov_base = hdr;
+  iov[0].iov_len = 4;
+  iov[1].iov_base = payload;
+  iov[1].iov_len = 256;
+
+  mhdr.msg_iov = iov;
+  mhdr.msg_iovlen = 2;
+  mhdr.msg_name = &addr;
+  mhdr.msg_namelen = sizeof addr;
+  mhdr.msg_control = &chdr;
+  mhdr.msg_controllen = sizeof chdr;
+  mhdr.msg_flags = 0;
+ 
+  n = recvmsg (sockfd, &mhdr, 0);
+
+  len = sizeof (addr);
+  getpeername (sockfd, (struct sockaddr *)&addr, &len);
+  s = (struct sockaddr_in *)&addr;
+  inet_ntop (AF_INET, &s->sin_addr, ip, INET6_ADDRSTRLEN);
+  
+  if (n < 0)
+    {
+      perror("ERROR reading from socket");
+      exit(1);
+    }
+
+  printf ("%s:%d> [%s] %s\n", ip, ntohs(s->sin_port), hdr, payload);
+
+  if (n < 0)
+    {
+      perror("ERROR writing to socket");
+      exit(1);
+    }
+
+  return 0;
+}
diff --git a/remote_io/test-directories.c b/remote_io/test-directories.c
new file mode 100644
index 0000000000..2d7ae8bf48
--- /dev/null
+++ b/remote_io/test-directories.c
@@ -0,0 +1,59 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-directories.c -o tdir.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-directories.c -o tdir.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+void
+print_dir_contents (char *dirname)
+{
+  DIR *dir;
+  struct dirent *de;
+
+  printf ("%s:\n", dirname);
+
+  dir = opendir (dirname);
+
+  while ((de = readdir (dir)) != NULL)
+    printf ("\t%s\n", de->d_name);
+
+  closedir (dir);
+}
+
+int
+main ()
+{
+  struct stat st;
+  mode_t m;
+  char newdir[] = "tmp.abc";
+
+  stat (__FILE__, &st);
+  m = st.st_mode;
+  printf ("mode of %s: %o -> ", __FILE__, m);
+
+  chmod (__FILE__, m & 0700);
+
+  stat (__FILE__, &st);
+  printf ("%o -> ", st.st_mode);
+
+  chmod (__FILE__, m);
+
+  stat (__FILE__, &st);
+  m = st.st_mode;
+  printf ("%o\n", st.st_mode);
+
+  mkdir (newdir, 0755);
+  print_dir_contents (newdir);
+  rmdir (newdir);
+
+  chdir ("..");
+  print_dir_contents (".");
+
+  return 0;
+}
diff --git a/remote_io/test-dup-2.c b/remote_io/test-dup-2.c
new file mode 100644
index 0000000000..6f340755d7
--- /dev/null
+++ b/remote_io/test-dup-2.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+
+#define N 1000
+
+int
+main ()
+{
+  int fd[N], i;
+
+  for (i = 0; i < N; i++)
+    fd[i] = dup(STDERR_FILENO);
+
+  close (STDERR_FILENO);
+
+  for (i = 0; i < N; i++)
+    close (fd[i]);
+
+  return 0;
+}
diff --git a/remote_io/test-dup.c b/remote_io/test-dup.c
new file mode 100644
index 0000000000..27153765f6
--- /dev/null
+++ b/remote_io/test-dup.c
@@ -0,0 +1,28 @@
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+
+int
+main ()
+{
+  char buf[100];
+  int fd = open ("out.dup2", O_CREAT|O_WRONLY|O_TRUNC, 0655);
+  int fd_dup = dup (fd);
+
+  //errno = EADV;
+  //perror ("adv");
+
+  sprintf (buf, "[%d] hahaha\n", getpid ());
+  write (fd_dup, buf, strlen (buf) + 1);
+
+  close (fd);
+  close (fd_dup);
+
+  fd = dup (STDERR_FILENO);
+  close (STDERR_FILENO);
+  close (fd);
+
+  return 0;
+}
diff --git a/remote_io/test-dup2.c b/remote_io/test-dup2.c
new file mode 100644
index 0000000000..41a02a3d5a
--- /dev/null
+++ b/remote_io/test-dup2.c
@@ -0,0 +1,25 @@
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+int
+main ()
+{
+  int fd = open ("out.dup2", O_CREAT|O_WRONLY|O_TRUNC, 0655);
+  dup2 (fd, STDERR_FILENO);
+
+  //errno = EADV;
+  //perror ("adv");
+
+  fprintf (stderr, "[%d] hahaha\n", getpid ());
+
+  close (fd);
+  close (STDERR_FILENO);
+
+  dup2 (STDIN_FILENO, STDERR_FILENO);
+  close (STDIN_FILENO);
+  close (STDERR_FILENO);
+
+  return 0;
+}
diff --git a/remote_io/test-epoll-2.c b/remote_io/test-epoll-2.c
new file mode 100644
index 0000000000..010d6699b8
--- /dev/null
+++ b/remote_io/test-epoll-2.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/epoll.h>
+#include <signal.h>
+
+int
+main ()
+{
+  int res;
+  int epfd;
+  struct epoll_event event;
+  sigset_t sigmask;
+
+  sigemptyset (&sigmask);
+  sigaddset(&sigmask, SIGINT);
+
+  event.events = EPOLLIN;
+  event.data.u32 = 0;
+  
+  epfd = epoll_create1 (1);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  printf ("enter a number: ");
+  fflush (stdout);
+
+  if (epoll_pwait (epfd, &event, 1, 1000, &sigmask) == 0)
+    printf ("missing number\n");
+  else
+    {
+      scanf ("%d", &res);
+      printf ("entered: %d (%d)\n", res, event.events);
+    }
+  
+  return 0;
+}
diff --git a/remote_io/test-epoll-3.c b/remote_io/test-epoll-3.c
new file mode 100644
index 0000000000..1d536c6163
--- /dev/null
+++ b/remote_io/test-epoll-3.c
@@ -0,0 +1,64 @@
+#include <stdio.h>
+#include <sys/epoll.h>
+#include <unistd.h>
+#include <signal.h>
+#include <remote_io.h>
+
+#define BUFSZ 100
+
+extern void check_migrate (void *, void *);
+
+void __attribute__((pcn_disable))
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  pcn_migrate_disable ();
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  pcn_migrate_enable ();
+  return;
+}
+
+int
+main ()
+{
+  struct epoll_event event;
+  struct sigaction sa;
+  int i, val, epfd;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  event.events = EPOLLIN;
+  event.data.u32 = 12345;
+  
+  epfd = epoll_create1 (EPOLL_CLOEXEC);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  for (i = 0; i < 2; i++)
+    {
+      printf ("Enter a number: ");
+      fflush(stdout);
+
+      if (epoll_pwait (epfd, &event, 1, -1, NULL) > 0)
+	{
+	  scanf ("%d", &val);
+	  printf ("entered '%d' / %d\n", val, event.data.u32);
+	}
+
+      printf ("Enter a number: ");
+      fflush(stdout);
+
+      if (epoll_wait (epfd, &event, 1, -1) > 0)
+	{
+	  scanf ("%d", &val);
+	  printf ("entered '%d' / %d\n", val, event.data.u32);
+	}
+    }
+
+  return 0;
+}
diff --git a/remote_io/test-execve.c b/remote_io/test-execve.c
new file mode 100644
index 0000000000..d80534271d
--- /dev/null
+++ b/remote_io/test-execve.c
@@ -0,0 +1,22 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+int
+main (int argc, char *argv[], char *envp[])
+{
+  if (argc < 2)
+    {
+      printf ("Insufficient arugments\n");
+      exit (EXIT_FAILURE);
+    }
+
+  printf ("Executing %s\n", argv[1]);
+
+  execve (argv[1], &argv[1], envp);
+
+  return 0;
+}
diff --git a/remote_io/test-fcntl.c b/remote_io/test-fcntl.c
new file mode 100644
index 0000000000..c6bfb98c78
--- /dev/null
+++ b/remote_io/test-fcntl.c
@@ -0,0 +1,17 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-fcntl.c -o tf.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-fcntl.c -o tf.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+
+int
+main ()
+{
+  printf ("stdin: %x\n", fcntl (0, F_GETFL, 0));
+  printf ("stdout: %x\n", fcntl (1, F_GETFL, 0));
+  printf ("stderr: %x\n", fcntl (2, F_GETFL, 0));
+
+  return 0;
+}
diff --git a/remote_io/test-fgets.c b/remote_io/test-fgets.c
new file mode 100644
index 0000000000..aea9df96c4
--- /dev/null
+++ b/remote_io/test-fgets.c
@@ -0,0 +1,15 @@
+#include <stdio.h>
+
+#define BUFSZ 100
+
+int
+main ()
+{
+  char buf[BUFSZ];
+
+  fgets (buf, BUFSZ, stdin);
+
+  printf ("read in: %s\n", buf);
+
+  return 0;
+}
diff --git a/remote_io/test-fork-1.c b/remote_io/test-fork-1.c
new file mode 100644
index 0000000000..7982708c15
--- /dev/null
+++ b/remote_io/test-fork-1.c
@@ -0,0 +1,22 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+int
+main ()
+{
+  int pid = fork ();
+  int status;
+
+  if (pid == 0)
+    sleep (2);
+  else
+    sleep (1);
+
+  printf ("hello, I'm process %d\n", getpid ());
+
+  if (pid)
+    wait (&status);
+  
+  return 0;
+}
diff --git a/remote_io/test-fork-2.c b/remote_io/test-fork-2.c
new file mode 100644
index 0000000000..d66c5610ce
--- /dev/null
+++ b/remote_io/test-fork-2.c
@@ -0,0 +1,108 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <sys/epoll.h>
+
+#define BUFSZ 1000
+char buf[BUFSZ];
+
+int
+do_child (int fd)
+{
+  struct epoll_event e;
+  int epfd, len;
+
+  /* Need to use epoll, because the read system call isn't
+     interruptible in RIO glibc.  */
+  e.events = EPOLLIN;
+  e.data.u32 = fd;
+
+  epfd = epoll_create1 (0);
+  if (epfd == -1)
+    perror ("epoll_create");
+
+  epoll_ctl (epfd, EPOLL_CTL_ADD, fd, &e);
+
+  while (1)
+    {
+      buf[0] = '\0';
+
+      epoll_wait (epfd, &e, 1, -1);
+
+      fgets (buf, BUFSZ, stdin);
+      len = strlen (buf) + 1;
+
+      if (buf[0] == 'Q')
+	exit (EXIT_SUCCESS);
+
+      write (fd, &len, sizeof (int));
+      write (fd, buf, len);
+    }
+}
+
+int
+do_parent (int fd)
+{
+  struct epoll_event e;
+  int epfd, status, len;
+
+  e.events = EPOLLIN | EPOLLHUP;
+  e.data.u32 = fd;
+
+  epfd = epoll_create1 (0);
+  if (epfd == -1)
+    perror ("epoll_create");
+
+  epoll_ctl (epfd, EPOLL_CTL_ADD, fd, &e);
+
+  while (1)
+    {
+      printf ("(%d) enter something or press Q to exit> ", getpid ());
+      fflush (stdout);
+
+      epoll_wait (epfd, &e, 1, -1);
+
+      if (e.events & EPOLLHUP)
+	{
+	  wait (&status);
+	  exit (EXIT_SUCCESS);
+	}
+
+      status = read (fd, &len, sizeof (int));
+      if (status != sizeof (int))
+	{
+	  perror ("read");
+	  exit (EXIT_FAILURE);
+	}
+
+      read (fd, buf, len);
+      printf ("%s", buf);
+    }
+}
+
+int
+main ()
+{
+  int pfds[2], pid, res;
+
+  res = pipe (pfds);
+  if (res < 0)
+    exit (EXIT_FAILURE);
+
+  pid = fork ();
+
+  if (pid == 0)
+    do_child (pfds[1]);
+ else
+   {
+     close (STDIN_FILENO);
+     close (pfds[1]);
+     do_parent (pfds[0]);
+   }
+
+  return 0;
+}
diff --git a/remote_io/test-fork-3.c b/remote_io/test-fork-3.c
new file mode 100644
index 0000000000..858d2a9f8e
--- /dev/null
+++ b/remote_io/test-fork-3.c
@@ -0,0 +1,193 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <sys/epoll.h>
+
+#define BUFSZ 1000
+char buf[BUFSZ];
+
+#define LEN 9
+
+#define LIO_TOUCH(var) (*(volatile typeof(var)*)&(var))
+
+int
+do_child (int fd)
+{
+  struct epoll_event e;
+  static int epfd, len;
+
+  /* Need to use epoll, because the read system call isn't
+     interruptible in RIO glibc.  */
+  e.events = EPOLLIN;
+  e.data.u32 = STDIN_FILENO;
+
+  epfd = epoll_create1 (0);
+  if (epfd == -1)
+    perror ("epoll_create");
+
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &e);
+
+  while (1)
+    {
+      buf[0] = '\0';
+
+      epoll_wait (epfd, &e, 1, -1);
+
+      fgets (buf, BUFSZ, stdin);
+      len = strlen (buf) + 1;
+
+      if (buf[0] == 'Q')
+	exit (EXIT_SUCCESS);
+
+      write (fd, &len, sizeof (int));
+      write (fd, buf, len);
+    }
+
+  LIO_TOUCH (epfd);
+  LIO_TOUCH (len);
+}
+
+int
+do_relay ()
+{
+  struct epoll_event e;
+  static int epfd, len, status;
+
+  /* Need to use epoll, because the read system call isn't
+     interruptible in RIO glibc.  */
+  e.events = EPOLLIN | EPOLLHUP;
+  e.data.u32 = STDIN_FILENO;
+
+  epfd = epoll_create1 (0);
+  if (epfd == -1)
+    perror ("epoll_create");
+
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &e);
+
+  while (1)
+    {
+      buf[0] = '\0';
+
+      epoll_wait (epfd, &e, 1, -1);
+
+      if (e.events & EPOLLHUP)
+	{
+	  wait (&status);
+	  exit (EXIT_SUCCESS);
+	}
+      
+      read (STDIN_FILENO, &len, sizeof (int));
+      read (STDIN_FILENO, buf, len);
+
+      write (STDOUT_FILENO, &len, sizeof (int));
+      write (STDOUT_FILENO, buf, len);
+    }
+
+  LIO_TOUCH (epfd);
+}
+
+int
+do_parent (int fd)
+{
+  struct epoll_event e;
+  static int epfd, status, len;
+
+  e.events = EPOLLIN | EPOLLHUP;
+  e.data.u32 = fd;
+
+  epfd = epoll_create1 (0);
+  if (epfd == -1)
+    perror ("epoll_create");
+
+  epoll_ctl (epfd, EPOLL_CTL_ADD, fd, &e);
+
+  while (1)
+    {
+      printf ("(%d) enter something or press Q to exit> ", getpid ());
+      fflush (stdout);
+
+      epoll_wait (epfd, &e, 1, -1);
+
+      if (e.events & EPOLLHUP)
+	{
+	  wait (&status);
+	  exit (EXIT_SUCCESS);
+	}
+
+      status = read (fd, &len, sizeof (int));
+      if (status != sizeof (int))
+	{
+	  perror ("read");
+	  exit (EXIT_FAILURE);
+	}
+
+      read (fd, buf, len);
+      printf ("%s", buf);
+    }
+
+  LIO_TOUCH (epfd);
+}
+
+int
+main ()
+{
+  int pfds[2], pid, res, i, fd;
+
+  res = pipe (pfds);
+  if (res < 0)
+    exit (EXIT_FAILURE);
+
+  pid = fork ();
+
+  /* Pipe:
+       ./tf3 <0-1> f1 <0-1> f2 <0-1> ... <0-1> child
+   */
+
+  if (pid == 0)
+    {
+      close (pfds[0]);
+      fd = pfds[1];
+
+      for (i = 0; i < LEN - 2; i++)
+	{
+	  res = pipe (pfds);
+	  if (res < 0)
+	    exit (EXIT_FAILURE);
+
+	  pid = fork ();
+
+	  if (pid > 0)
+	    {
+	      close (STDIN_FILENO);
+	      close (STDOUT_FILENO);
+	      dup (pfds[0]);
+	      dup (fd);
+	      close (pfds[0]);
+	      close (pfds[1]);
+	      close (fd);
+
+	      do_relay ();
+	    }
+	  else
+	    {
+	      close (fd);
+	      close (pfds[0]);
+	      fd = pfds[1];
+	    }
+	}
+
+      do_child (fd);
+    }
+  else
+    {
+      close (STDIN_FILENO);
+      close (pfds[1]);
+      do_parent (pfds[0]);
+    }
+
+  return 0;
+}
diff --git a/remote_io/test-getcwd.c b/remote_io/test-getcwd.c
new file mode 100644
index 0000000000..aca67d63ce
--- /dev/null
+++ b/remote_io/test-getcwd.c
@@ -0,0 +1,19 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-getcwd.c -o tg.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-getcwd.c -o tg.a64.exe -g
+
+#include <stdio.h>
+#include <unistd.h>
+#include <linux/limits.h>
+
+int
+main ()
+{
+  char pwd[PATH_MAX];
+
+  getcwd (pwd, PATH_MAX);
+  
+  printf ("pwd = %s\n", pwd);
+
+  return 0;
+}
diff --git a/remote_io/test-io.c b/remote_io/test-io.c
new file mode 100644
index 0000000000..426baec2d8
--- /dev/null
+++ b/remote_io/test-io.c
@@ -0,0 +1,41 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ epoll.c -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ epoll.c -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/epoll.h>
+
+int
+main ()
+{
+  int res;
+  int epfd;
+  struct epoll_event event;
+
+  event.events = EPOLLIN;
+  event.data.u32 = 0;
+  
+  epfd = epoll_create (1);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  printf ("enter a number: ");
+  fflush (stdout);
+
+  if (epoll_wait (epfd, &event, 1, 1000) == 0)
+    printf ("missing number\n");
+  else
+    {
+      scanf ("%d", &res);
+      printf ("entered: %d\n", res);
+    }
+  
+  return 0;
+}
diff --git a/remote_io/test-kill.c b/remote_io/test-kill.c
new file mode 100644
index 0000000000..0c2eee3d83
--- /dev/null
+++ b/remote_io/test-kill.c
@@ -0,0 +1,87 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+
+extern void check_migrate (void *, void *);
+extern long __migrate_gb_variable; /* -1 => inactive, 0 => ARM, 1 => x86  */
+
+void
+show_help (const char *exe)
+{
+  printf ("%s options:\n", exe);
+  printf ("\t-s <SIGNO> -> integer signal number\n");
+  printf ("\t-p <PID> -> integer PID to send signal to\n");
+  printf ("\t-K -> set signal to SIGKILL\n");
+  printf ("\t-S -> set signal to SIGSTOP\n");
+  printf ("\t-C -> set signal to SIGCONT\n");
+  printf ("\t-m -> toggle ISA migration\n");
+}
+
+int
+main (int argc, char *argv[])
+{
+  char c;
+  int signo = -1;
+  int pid = -1;
+  int migrate = 0;
+
+  while ((c = getopt (argc, argv, "s:p:KSCm")) != -1)
+    switch (c)
+      {
+      case 's':
+	signo = atoi (optarg);
+	break;
+
+      case 'p':
+	pid = atoi (optarg);
+	break;
+
+      case 'K':
+	signo = SIGKILL;
+	break;
+
+      case 'S':
+	signo = SIGSTOP;
+	break;
+
+      case 'C':
+	signo = SIGCONT;
+	break;
+
+      case 'm':
+	migrate = 1;
+	break;
+
+      default:
+	show_help (argv[0]);
+	exit (EXIT_FAILURE);
+      }
+
+  if (pid == -1)
+    {
+      printf ("Error: missing PID\n");
+      show_help (argv[0]);
+      exit (EXIT_FAILURE);
+    }
+
+  if (signo == -1)
+    {
+      printf ("Error: missing SIGNO\n");
+      show_help (argv[0]);
+      exit (EXIT_FAILURE);
+    }
+
+  if (migrate)
+    {
+      /* Spin until __migrate_gb_variable is set by CRIU.  */
+      while (__migrate_gb_variable < 0)
+	;
+
+      check_migrate (NULL, NULL);
+    }
+
+  kill (pid, signo);
+  
+  return 0;
+}
diff --git a/remote_io/test-launcher-popen.c b/remote_io/test-launcher-popen.c
new file mode 100644
index 0000000000..8522ca04ba
--- /dev/null
+++ b/remote_io/test-launcher-popen.c
@@ -0,0 +1,27 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+int
+main (int argc, char *argv[])
+{
+  char *msg = "THE MESSAGE IS... I FORGOT\n";
+  FILE *file;
+  
+  if (argc < 2)
+    {
+      printf ("Insufficient arugments\n");
+      exit (EXIT_FAILURE);
+    }
+
+  file = popen (argv[1], "w");
+  fputs (msg, file);
+  pclose (file);
+
+  printf ("Message sent!\n");
+
+  return 0;
+}
diff --git a/remote_io/test-launcher.c b/remote_io/test-launcher.c
new file mode 100644
index 0000000000..007ed3092f
--- /dev/null
+++ b/remote_io/test-launcher.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+int
+main (int argc, char *argv[], char *envp[])
+{
+  int pfds[2], res, len, pid;
+  char *msg = "THE MESSAGE IS... I FORGOT\n";
+
+  len = strlen (msg);
+
+  if (argc < 2)
+    {
+      printf ("Insufficient arugments\n");
+      exit (EXIT_FAILURE);
+    }
+
+  res = pipe (pfds);
+  if (res < 0)
+    exit (EXIT_FAILURE);
+
+  pid = fork ();
+  if (pid == 0)
+    {
+      close (STDIN_FILENO);
+      dup (pfds[0]);
+      close (pfds[0]);
+
+      execve (argv[1], &argv[1], envp);
+    }
+
+  write (pfds[1], msg, len);
+
+  wait (&res);
+  printf ("Message sent!\n");
+
+  return 0;
+}
diff --git a/remote_io/test-libepoll-test.c b/remote_io/test-libepoll-test.c
new file mode 100644
index 0000000000..511f4cd2e8
--- /dev/null
+++ b/remote_io/test-libepoll-test.c
@@ -0,0 +1,58 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ -Wl,-rpath,$(pwd) -L. -lepoll -o etest.x86.exe test-libepoll.c
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ -L. -lepoll -o etest.x86.exe test-epoll.c
+
+#include <stdio.h>
+#include <stdio_ext.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+
+char
+getval ()
+{
+  char c = -1;
+  int epfd;
+  struct epoll_event event;
+
+  __fpurge (stdin);
+
+  event.events = EPOLLIN;
+  event.data.u32 = 0;
+  
+  epfd = epoll_create (1);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  printf ("enter a number: ");
+  fflush (stdout);
+
+  if (epoll_wait (epfd, &event, 1, 1000))
+    {
+      scanf ("%c", &c);
+      printf ("user entered '%c'\n", c);
+    }
+  else
+    printf ("local epoll timed out\n");
+  
+  return c;
+}
+
+extern int getnum (void);
+
+int
+main ()
+{
+  int num = getnum ();
+
+  if (num < 0)
+    printf ("epoll timer expired\n");
+  else
+    printf ("user entered %d\n", num);
+
+  getval ();
+  
+  return 0;
+}
+
diff --git a/remote_io/test-libepoll.c b/remote_io/test-libepoll.c
new file mode 100644
index 0000000000..b03b3714de
--- /dev/null
+++ b/remote_io/test-libepoll.c
@@ -0,0 +1,34 @@
+// gcc -shared -fpic libepoll.c -o libepoll.so
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/epoll.h>
+
+int
+getnum ()
+{
+  int res = -1;
+  int epfd;
+  struct epoll_event event;
+
+  event.events = EPOLLIN;
+  event.data.u32 = 0;
+  
+  epfd = epoll_create (1);
+  if (epfd == -1)
+    perror ("epoll_create");
+  
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
+
+  printf ("enter a number: ");
+  fflush (stdout);
+
+  if (epoll_wait (epfd, &event, 1, 1000))
+    scanf ("%d", &res);
+  
+  return res;
+}
diff --git a/remote_io/test-link.c b/remote_io/test-link.c
new file mode 100644
index 0000000000..000ceb0f31
--- /dev/null
+++ b/remote_io/test-link.c
@@ -0,0 +1,33 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-link.c -o tlink.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-link.c -o tlink.a64.exe -g
+
+#include <stdio.h>
+#include <unistd.h>
+
+#define BUFSZ 100
+
+int
+main ()
+{
+  char buf[BUFSZ];
+  int ret;
+
+  link (__FILE__, "new."__FILE__);
+  link (__FILE__, "new."__FILE__);
+  perror ("link");
+  unlink ("new."__FILE__);
+  symlink (__FILE__, "new."__FILE__);
+  symlink (__FILE__, "new."__FILE__);  
+  perror ("symlink");
+
+  ret = readlink ("./new." __FILE__, buf, BUFSZ);
+  if (ret > 0 && ret < BUFSZ)
+    buf[ret] = '\0';
+  else
+    buf[BUFSZ-1] = '\0';
+
+  printf ("link = %s (size = %d)\n", buf, ret);
+
+  return unlink ("new."__FILE__);
+}
diff --git a/remote_io/test-lseek.c b/remote_io/test-lseek.c
new file mode 100644
index 0000000000..f0857b191d
--- /dev/null
+++ b/remote_io/test-lseek.c
@@ -0,0 +1,50 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-lseek.c -o tlseek.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-lseek.c -o tlseek.a64.exe -g
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define BUFSZ 100
+
+int
+main ()
+{
+  char fname[] = "test.lseek";
+  //            01234567890123456789012345
+  char msg[] = "abcdefghijklmnopqrstuvwxyz";
+  char out[] = "abcdefghiJKLMNopqrstuvwxyz";
+  char frag[] = "JKLMN";
+  char buf[BUFSZ];
+  int mlen = strlen (msg) + 1;
+  int fd, res;
+
+  unlink (fname);
+  
+  fd = open (fname, O_CREAT|O_RDWR|O_TRUNC, 0655);
+  write (fd, msg, mlen);
+
+  lseek (fd, 9, SEEK_SET);
+  write (fd, frag, strlen (frag));
+
+  sync_file_range (fd, 9, strlen (frag),
+		   SYNC_FILE_RANGE_WAIT_BEFORE
+		   | SYNC_FILE_RANGE_WRITE
+		   | SYNC_FILE_RANGE_WAIT_AFTER);
+
+  lseek (fd, 0, SEEK_SET);
+  read (fd, buf, mlen);
+
+  if (strcmp (buf, out) != 0)
+    {
+      printf ("error: buffers do not match\n");
+      printf ("  %s\n  %s\n", buf, out);
+    }
+  
+  close (fd);
+
+  return unlink (fname);
+}
diff --git a/remote_io/test-malloc.c b/remote_io/test-malloc.c
new file mode 100644
index 0000000000..c94d4182d0
--- /dev/null
+++ b/remote_io/test-malloc.c
@@ -0,0 +1,31 @@
+#include <stdio.h>
+#include <local_io.h>
+
+void
+test_array (int *ary, int n)
+{
+  int i;
+
+  for (i = 0; i < n; i++)
+    if (ary[i] != i+1)
+      printf ("unexpected value: ary[%d]: %d != %d\n", i, ary[i], i+1);
+}
+
+int
+main ()
+{
+  int *ary = NULL;
+  int i;
+
+  for (i = 1; i < 10; i++)
+    {
+      ary = lio_realloc (ary, i * sizeof (int));
+      ary[i-1] = i;
+
+      test_array (ary, i);
+    }
+
+  lio_free (ary);
+
+  return 0;
+}
diff --git a/remote_io/test-mmap-2.c b/remote_io/test-mmap-2.c
new file mode 100644
index 0000000000..64f7e266f2
--- /dev/null
+++ b/remote_io/test-mmap-2.c
@@ -0,0 +1,25 @@
+#define _GNU_SOURCE
+
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+
+int
+main ()
+{
+  const char msg[] = "abcdefghijklmnopqrstuvwxyz\n";
+  int fd = open ("test.123", O_CREAT|O_TRUNC|O_RDWR, 0644);
+  char *addr;
+
+  fallocate (fd, FALLOC_FL_ZERO_RANGE, 0, strlen (msg));
+  
+  addr = mmap (NULL, strlen (msg), PROT_WRITE, MAP_SHARED, fd, 0);
+
+  strcpy (addr, msg);
+
+  close (fd);
+  munmap (addr, strlen (msg));
+
+  return 0;
+}
diff --git a/remote_io/test-mmap.c b/remote_io/test-mmap.c
new file mode 100644
index 0000000000..33768de799
--- /dev/null
+++ b/remote_io/test-mmap.c
@@ -0,0 +1,30 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ mmap-test.c -g -o mmap.x86.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ mmap-test.c -g -o mmap.a64.exe
+
+#define _GNU_SOURCE
+
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+
+int
+main ()
+{
+  const char msg[] = "abcdefghijklmnopqrstuvwxyz\n";
+  int fd = open ("test.123", O_CREAT|O_TRUNC|O_RDWR, 0644);
+  char *addr;
+
+  fallocate (fd, FALLOC_FL_ZERO_RANGE, 0, strlen (msg));
+  
+  addr = mmap (NULL, strlen (msg), PROT_WRITE, MAP_SHARED, fd, 0);
+
+  strcpy (addr, msg);
+
+  //close (fd);
+  munmap (addr, strlen (msg));
+  close (fd);
+
+ return 0;
+}
diff --git a/remote_io/test-pipe.c b/remote_io/test-pipe.c
new file mode 100644
index 0000000000..44807407a9
--- /dev/null
+++ b/remote_io/test-pipe.c
@@ -0,0 +1,26 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-pipe.c -o tp.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-pipe.c -o tp.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+int
+main ()
+{
+  int pfds[2], res;
+  char out[7], *in = "hello\n"; // length 7
+
+  res = pipe (pfds);
+  if (res < 0)
+    exit (EXIT_FAILURE);
+
+  write (pfds[1], in, 7);
+  read (pfds[0], out, 7);
+
+  write (STDOUT_FILENO, out, 7);
+  
+  return 0;
+}
diff --git a/remote_io/test-poll.c b/remote_io/test-poll.c
new file mode 100644
index 0000000000..4a74b9e9b2
--- /dev/null
+++ b/remote_io/test-poll.c
@@ -0,0 +1,51 @@
+#include <stdio.h>
+#include <poll.h>
+#include <unistd.h>
+#include <signal.h>
+#include <remote_io.h>
+
+#define BUFSZ 100
+
+extern void check_migrate (void *, void *);
+
+void __attribute__((pcn_disable))
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  pcn_migrate_disable ();
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  pcn_migrate_enable ();
+  return;
+}
+
+int
+main ()
+{
+  struct pollfd pfd[1];
+  struct sigaction sa;
+  int i, val;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  for (i = 0; i < 3; i++)
+    {
+      printf ("Enter a number: ");
+      fflush(stdout);
+
+      pfd[0].fd = STDIN_FILENO;
+      pfd[0].events = POLLIN;
+
+      if (poll (pfd, 1, -1) > 0)
+	{
+	  scanf ("%d", &val);
+	  printf ("entered '%d'\n", val);
+	}
+
+      check_migrate (NULL, NULL);
+    }
+
+  return 0;
+}
diff --git a/remote_io/test-ppoll.c b/remote_io/test-ppoll.c
new file mode 100644
index 0000000000..c44795f735
--- /dev/null
+++ b/remote_io/test-ppoll.c
@@ -0,0 +1,31 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-poll.c -o tp.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-poll.c -o tp.a64.exe -g
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <unistd.h>
+#include <poll.h>
+#include <sys/time.h>
+
+int
+main ()
+{
+  struct pollfd fds;
+  struct timespec t;
+
+  fds.fd = STDIN_FILENO;
+  fds.events = POLLIN;
+
+  t.tv_sec = 2;
+  t.tv_nsec = 0;
+
+  printf ("sizeof (struct timespec) = %d\n", sizeof (t));
+  //ppoll (&fds, 1, &t, NULL);
+
+  printf ("poll with timeout zero:\n");
+  poll (&fds, 1, 0);
+
+  return 0;
+}
diff --git a/remote_io/test-pread.c b/remote_io/test-pread.c
new file mode 100644
index 0000000000..aae8542dfe
--- /dev/null
+++ b/remote_io/test-pread.c
@@ -0,0 +1,24 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-pread.c -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-pread.c -g
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define BUFSZ 25
+
+int
+main ()
+{
+  int fd = open (__FILE__, O_RDONLY);
+  char buf[BUFSZ], eol = '\n';
+  int res;
+
+  res = pread (fd, &buf, BUFSZ, 50);
+  write (STDOUT_FILENO, buf, BUFSZ);
+  write (STDOUT_FILENO, &eol, 1);
+  close (fd);
+
+  return 0;
+}
diff --git a/remote_io/test-pwrite.c b/remote_io/test-pwrite.c
new file mode 100644
index 0000000000..2a5416227f
--- /dev/null
+++ b/remote_io/test-pwrite.c
@@ -0,0 +1,41 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define BUFSZ 512
+
+int
+main ()
+{
+  char *base = "abcd> ";
+  char *num = "12345";
+  char buf[BUFSZ];
+  int l_base, l_num, l_file;
+  int fd;
+
+  l_base = strlen (base);
+  l_num = strlen (num) + 1; // Add NUL character
+  l_file = strlen (__FILE__) + 1;
+
+  fd = open ("out.pwrite", O_CREAT|O_RDWR|O_TRUNC, 0644);
+  if (fd < 0)
+    {
+      perror ("open failed");
+      exit (EXIT_FAILURE);
+    }
+
+  write (fd, base, l_base);
+  write (fd, num, l_num);
+
+  pread (fd, buf, l_base + l_num, 0);
+  printf ("before: %s\n", buf);
+
+  pwrite (fd, __FILE__, l_file, l_base);
+
+  pread (fd, buf, l_base + l_file, 0);
+  printf ("after: %s\n", buf);
+
+  return 0;
+}
diff --git a/remote_io/test-pwritev.c b/remote_io/test-pwritev.c
new file mode 100644
index 0000000000..b0d0f60e00
--- /dev/null
+++ b/remote_io/test-pwritev.c
@@ -0,0 +1,36 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/uio.h>
+
+#define BUFSZ 100
+
+int
+main ()
+{
+  const char *s1 = "Hello. ";
+  const char *s2 = "My name is Function ";
+  const char *s3 = __FUNCTION__;
+  const char *s4 = ".\n";
+  char buf[BUFSZ];
+
+  struct iovec iov[4];
+  int fd = open ("out.pwritev", O_CREAT | O_RDWR | O_TRUNC, 0644);
+  int len;
+
+  iov[0].iov_base = (void *) s1;
+  iov[0].iov_len = strlen (s1);
+  iov[1].iov_base = (void *) s2;
+  iov[1].iov_len = strlen (s2);
+  iov[2].iov_base = (void *) s3;
+  iov[2].iov_len = strlen (s3);
+  iov[3].iov_base = (void *) s4;
+  iov[3].iov_len = strlen (s4);
+
+  pwritev (fd, iov, 4, 0);
+  len = pread (fd, buf, BUFSZ, 0);
+
+  write (STDOUT_FILENO, buf, len);
+
+  return 0;
+}
diff --git a/remote_io/test-rename.c b/remote_io/test-rename.c
new file mode 100644
index 0000000000..ce80e1d046
--- /dev/null
+++ b/remote_io/test-rename.c
@@ -0,0 +1,20 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-rename.c -o trename.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-rename.c -o trename.a64.exe -g
+
+#include <stdio.h>
+#include <unistd.h>
+
+#define BUFSZ 100
+
+int
+main ()
+{
+  char buf[BUFSZ];
+  int ret;
+
+  symlink (__FILE__, "new."__FILE__);  
+  rename ("new."__FILE__, "NEW."__FILE__);
+
+  return unlink ("NEW."__FILE__);
+}
diff --git a/remote_io/test-select-2.c b/remote_io/test-select-2.c
new file mode 100644
index 0000000000..92e72934ae
--- /dev/null
+++ b/remote_io/test-select-2.c
@@ -0,0 +1,80 @@
+#include <stdio.h>
+#include <sys/select.h>
+#include <unistd.h>
+#include <signal.h>
+#include <remote_io.h>
+
+#define BUFSZ 100
+
+extern void check_migrate (void *, void *);
+
+void __attribute__((pcn_disable))
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  pcn_migrate_disable ();
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  pcn_migrate_enable ();
+  return;
+}
+
+extern volatile long __migrate_gb_variable;
+
+void
+test_select (struct timeval *tv)
+{
+  fd_set rfds;
+  int val;
+
+  printf ("Enter a number: ");
+  fflush(stdout);
+
+  FD_ZERO (&rfds);
+  FD_SET (STDIN_FILENO, &rfds);
+
+  //__migrate_gb_variable = 0;
+  if (select (STDIN_FILENO + 1, &rfds, NULL, NULL, tv) > 0)
+    {
+      scanf ("%d", &val);
+      printf ("entered '%d'\n", val);
+    }
+}
+
+int
+test_pselect (struct timespec *ts)
+{
+  fd_set rfds;
+  int val;
+
+  printf ("Enter a number: ");
+  fflush(stdout);
+
+  FD_ZERO (&rfds);
+  FD_SET (STDIN_FILENO, &rfds);
+
+  if (pselect (STDIN_FILENO + 1, &rfds, NULL, NULL, ts, NULL) > 0)
+    {
+      scanf ("%d", &val);
+      printf ("entered '%d'\n", val);
+    }
+}
+
+int
+main ()
+{
+  struct timeval tv = { 3, 500 * 1000 };
+  struct timespec ts = { 3, 500 * 1000 * 1000 };
+  struct sigaction sa;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  test_select (NULL);
+  test_select (&tv);
+  test_pselect (&ts);
+  test_pselect (NULL);
+  
+  return 0;
+}
diff --git a/remote_io/test-select-3.c b/remote_io/test-select-3.c
new file mode 100644
index 0000000000..24273b1288
--- /dev/null
+++ b/remote_io/test-select-3.c
@@ -0,0 +1,76 @@
+#include <stdio.h>
+#include <sys/select.h>
+#include <unistd.h>
+#include <signal.h>
+#include <remote_io.h>
+
+#define BUFSZ 100
+
+extern void check_migrate (void *, void *);
+
+void __attribute__((pcn_disable))
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  pcn_migrate_disable ();
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  pcn_migrate_enable ();
+  return;
+}
+
+extern volatile long __migrate_gb_variable;
+
+void
+test_select (struct timeval *tv)
+{
+  fd_set rfds;
+  int val;
+
+  printf ("Enter a number: ");
+  fflush(stdout);
+
+  FD_ZERO (&rfds);
+  FD_SET (STDIN_FILENO, &rfds);
+
+  //__migrate_gb_variable = 0;
+  if (select (STDIN_FILENO + 1, &rfds, NULL, NULL, tv) > 0)
+    {
+      scanf ("%d", &val);
+      printf ("entered '%d'\n", val);
+    }
+}
+
+int
+test_pselect (struct timespec *ts)
+{
+  fd_set rfds;
+  int val;
+
+  printf ("Enter a number: ");
+  fflush(stdout);
+
+  FD_ZERO (&rfds);
+  FD_SET (STDIN_FILENO, &rfds);
+
+  if (pselect (STDIN_FILENO + 1, &rfds, NULL, NULL, ts, NULL) > 0)
+    {
+      scanf ("%d", &val);
+      printf ("entered '%d'\n", val);
+    }
+}
+
+int
+main ()
+{
+  struct timespec ts = { 10, 500 * 1000 * 1000 };
+  struct sigaction sa;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  test_pselect (&ts);
+  
+  return 0;
+}
diff --git a/remote_io/test-select.c b/remote_io/test-select.c
new file mode 100644
index 0000000000..24fb774d69
--- /dev/null
+++ b/remote_io/test-select.c
@@ -0,0 +1,56 @@
+#include <stdio.h>
+#include <string.h>
+#include <sys/select.h>
+#include <signal.h>
+#include <unistd.h>
+#include <assert.h>
+
+#define BUFSZ 1000
+
+void
+verify (int res, fd_set *rfds, char *a, const char *b)
+{
+  if (res == 1)
+    {
+      assert (FD_ISSET (STDIN_FILENO, rfds) == 1);
+      scanf ("%s", a);
+      if (strcmp (a, b) == 0)
+	printf ("Excellent!\n");
+      else
+	printf ("... Wrong!\n");
+    }
+  else
+    printf ("... Didn't receive '%s'\n", b);
+}
+
+int
+main ()
+{
+  fd_set rfds;
+  struct timeval tv = { 1, 500 * 1000 };
+  struct timespec ts = { 1, 500 * 1000 * 1000 };
+  sigset_t sigmask;
+  char buf[BUFSZ];
+  int res;
+
+  sigemptyset (&sigmask);
+  sigaddset(&sigmask, SIGINT);
+
+  FD_ZERO (&rfds);
+  FD_SET (STDIN_FILENO, &rfds);
+
+  printf ("enter 'abc': ");
+  fflush (stdout);
+  res = select (STDIN_FILENO + 1, &rfds, NULL, NULL, &tv);
+  verify (res, &rfds, buf, "abc");
+
+  printf ("enter '123': ");
+  fflush (stdout);
+  res = pselect (STDIN_FILENO + 1, &rfds, NULL, NULL, &ts, NULL);
+  verify (res, &rfds, buf, "123");
+
+  printf ("press anything to exit, or wait 1.5s\n");
+  res = pselect (STDIN_FILENO + 1, &rfds, NULL, NULL, &ts, &sigmask);
+
+  return 0;
+}
diff --git a/remote_io/test-setitimer.c b/remote_io/test-setitimer.c
new file mode 100644
index 0000000000..b657a327a3
--- /dev/null
+++ b/remote_io/test-setitimer.c
@@ -0,0 +1,67 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+static void
+handle_sig (int signo)
+{
+  assert (signo == SIGALRM);
+  return;
+}
+
+static void
+install_sighandler (int signo)
+{
+  sigset_t sigmask;
+  struct sigaction act;
+
+  sigemptyset (&sigmask);
+  sigaddset (&sigmask, signo);
+  sigprocmask (SIG_UNBLOCK, &sigmask, NULL);
+
+  act.sa_flags = 0;
+  act.sa_handler = handle_sig;
+  sigaction (signo, &act, NULL);
+}
+
+int
+main ()
+{
+  struct itimerval timer = { 0 }, old;
+  int val = -1;
+  int i, res = -1;
+
+  timer.it_interval.tv_sec = 1;
+  timer.it_value.tv_sec = 1;
+
+  install_sighandler (SIGALRM);
+
+  getitimer (ITIMER_REAL, &old);
+
+  assert (old.it_interval.tv_sec == 0);
+  assert (old.it_interval.tv_usec == 0);
+  assert (old.it_value.tv_sec == 0);
+  assert (old.it_value.tv_sec == 0);
+
+  setitimer (ITIMER_REAL, &timer, NULL);
+
+  for (i = 0; i < 5 && res < 0; i++)
+    {
+      res = read (STDIN_FILENO, &val, sizeof (int));
+
+      if (res == -1)
+	printf ("interrupted by the timer\n");
+      else
+	printf ("entered %c\n", val);
+    }
+
+  getitimer (ITIMER_REAL, &old);
+
+  assert (old.it_interval.tv_sec == timer.it_interval.tv_sec);
+  assert (old.it_interval.tv_usec == timer.it_interval.tv_usec);
+
+  return 0;
+}
diff --git a/remote_io/test-shm-1.c b/remote_io/test-shm-1.c
new file mode 100644
index 0000000000..c0558fa40d
--- /dev/null
+++ b/remote_io/test-shm-1.c
@@ -0,0 +1,163 @@
+/* man shm_open  */
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <semaphore.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <string.h>
+
+#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE);	\
+  } while (0)
+
+#define BUF_SIZE 1024   /* Maximum size for exchanged string */
+
+/* Define a structure that will be imposed on the shared
+   memory object */
+
+struct shmbuf {
+  sem_t  sem1;            /* POSIX unnamed semaphore */
+  sem_t  sem2;            /* POSIX unnamed semaphore */
+  size_t cnt;             /* Number of bytes used in 'buf' */
+  char   buf[BUF_SIZE];   /* Data being transferred */
+};
+
+const char shmpath[] = "/shm-tester";
+const char message[] = "This is only a test, a shm_open test.";
+
+//****************************************************************************************
+
+/* pshm_ucase_bounce.c
+
+   Licensed under GNU General Public License v2 or later.
+*/
+
+int
+main1()
+{
+  /* Create shared memory object and set its size to the size
+     of our structure. */
+
+  int fd = shm_open(shmpath, O_CREAT | O_EXCL | O_RDWR,
+		    S_IRUSR | S_IWUSR);
+  if (fd == -1)
+    errExit("shm_open");
+
+  if (ftruncate(fd, sizeof(struct shmbuf)) == -1)
+    errExit("ftruncate");
+
+  /* Map the object into the caller's address space. */
+
+  struct shmbuf *shmp = mmap(NULL, sizeof(*shmp),
+			     PROT_READ | PROT_WRITE,
+			     MAP_SHARED, fd, 0);
+  if (shmp == MAP_FAILED)
+    errExit("mmap");
+
+  /* Initialize semaphores as process-shared, with value 0. */
+
+  if (sem_init(&shmp->sem1, 1, 0) == -1)
+    errExit("sem_init-sem1");
+  if (sem_init(&shmp->sem2, 1, 0) == -1)
+    errExit("sem_init-sem2");
+
+  /* Wait for 'sem1' to be posted by peer before touching
+     shared memory. */
+
+  if (sem_wait(&shmp->sem1) == -1)
+    errExit("sem_wait");
+
+  /* Convert data in shared memory into upper case. */
+
+  for (int j = 0; j < shmp->cnt; j++)
+    shmp->buf[j] = toupper((unsigned char) shmp->buf[j]);
+
+  /* Post 'sem2' to tell the peer that it can now
+     access the modified data in shared memory. */
+
+  if (sem_post(&shmp->sem2) == -1)
+    errExit("sem_post");
+
+  /* Unlink the shared memory object. Even if the peer process
+     is still using the object, this is okay. The object will
+     be removed only after all open references are closed. */
+
+  shm_unlink(shmpath);
+
+  exit(EXIT_SUCCESS);
+}
+
+//****************************************************************************************
+
+/* pshm_ucase_send.c
+
+   Licensed under GNU General Public License v2 or later.
+*/
+
+int
+main2()
+{
+  size_t len = strlen(message);
+  const char *string = message;
+
+  sleep (1);
+
+  if (len > BUF_SIZE) {
+    fprintf(stderr, "String is too long\n");
+    exit(EXIT_FAILURE);
+  }
+
+  /* Open the existing shared memory object and map it
+     into the caller's address space. */
+
+  int fd = shm_open(shmpath, O_RDWR, 0);
+  if (fd == -1)
+    errExit("shm_open");
+
+  struct shmbuf *shmp = mmap(NULL, sizeof(*shmp),
+			     PROT_READ | PROT_WRITE,
+			     MAP_SHARED, fd, 0);
+  if (shmp == MAP_FAILED)
+    errExit("mmap");
+
+  /* Copy data into the shared memory object. */
+
+  shmp->cnt = len;
+  memcpy(&shmp->buf, string, len);
+
+  /* Tell peer that it can now access shared memory. */
+
+  if (sem_post(&shmp->sem1) == -1)
+    errExit("sem_post");
+
+  /* Wait until peer says that it has finished accessing
+     the shared memory. */
+
+  if (sem_wait(&shmp->sem2) == -1)
+    errExit("sem_wait");
+
+  /* Write modified data in shared memory to standard output. */
+
+  write(STDOUT_FILENO, &shmp->buf, len);
+  write(STDOUT_FILENO, "\n", 1);
+
+  exit(EXIT_SUCCESS);
+}
+
+//****************************************************************************************
+
+int
+main ()
+{
+  int pid = fork ();
+
+  if (pid == 0)
+    main2 ();
+  else
+    main1 ();
+
+  return 0;
+}
diff --git a/remote_io/test-shm-2.c b/remote_io/test-shm-2.c
new file mode 100644
index 0000000000..d23e1d12f7
--- /dev/null
+++ b/remote_io/test-shm-2.c
@@ -0,0 +1,55 @@
+/* man shm_open  */
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <semaphore.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <string.h>
+
+#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE);	\
+  } while (0)
+
+const char shmpath[] = "/test-shm-2";
+#define BUFSZ 1024
+
+int
+main()
+{
+  /* Create shared memory object and set its size to the size
+     of our structure. */
+
+  int fd = shm_open(shmpath, O_CREAT | O_EXCL | O_RDWR,
+		    S_IRUSR | S_IWUSR);
+  int res;
+  void *buf;
+
+  if (fd == -1)
+    errExit("shm_open");
+
+  if (ftruncate(fd, BUFSZ) == -1)
+    errExit("ftruncate");
+
+  /* Map the object into the caller's address space. */
+
+  buf = mmap(NULL, BUFSZ,
+	     PROT_READ | PROT_WRITE,
+	     MAP_SHARED, fd, 0);
+  if (buf == MAP_FAILED)
+    errExit("mmap");
+
+  /* Unlink the shared memory object. Even if the peer process
+     is still using the object, this is okay. The object will
+     be removed only after all open references are closed. */
+
+  shm_unlink(shmpath);
+
+  res = munmap (buf, BUFSZ);
+  if (res < 0)
+    errExit ("munmap");
+  
+  exit(EXIT_SUCCESS);
+}
diff --git a/remote_io/test-sigint-2.c b/remote_io/test-sigint-2.c
new file mode 100644
index 0000000000..7b00b15aff
--- /dev/null
+++ b/remote_io/test-sigint-2.c
@@ -0,0 +1,42 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-sigint-2.c -o ts-2.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-sigint-2.c -o ts-2.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <remote_io.h>
+
+void
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  exit (EXIT_SUCCESS);
+}
+
+int
+main ()
+{
+  struct sigaction sa;
+  int d;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  pcn_unload_signals ();
+  printf ("unloaded signals\n");
+  
+  printf ("[%d] sigint test\n", getpid ());
+  scanf ("%d", &d);
+
+  pcn_restore_signals ();
+  printf ("restored signals\n");
+
+  scanf ("%d", &d);  
+  
+  return 0;
+}
diff --git a/remote_io/test-sigint.c b/remote_io/test-sigint.c
new file mode 100644
index 0000000000..005447e4e6
--- /dev/null
+++ b/remote_io/test-sigint.c
@@ -0,0 +1,33 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-sigint.c -o ts.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-sigint.c -o ts.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+
+void
+sigint_handler (int signo, siginfo_t *si, void *arg)
+{
+  printf ("received signal 'SIGINT' from process %d\n", si->si_pid);
+  exit (EXIT_SUCCESS);
+}
+
+int
+main ()
+{
+  struct sigaction sa;
+  int d;
+
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_sigaction = sigint_handler;
+  sa.sa_flags = SA_SIGINFO;
+  sigaction (SIGINT, &sa, NULL);
+
+  printf ("[%d] sigint test\n", getpid ());
+  scanf ("%d", &d);
+
+  return 0;
+}
diff --git a/remote_io/test-signalfd.c b/remote_io/test-signalfd.c
new file mode 100644
index 0000000000..3beeeb822b
--- /dev/null
+++ b/remote_io/test-signalfd.c
@@ -0,0 +1,107 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/signalfd.h>
+#include <sys/epoll.h>
+
+void
+handle_error (char *msg)
+{
+  perror (msg);
+  exit (EXIT_FAILURE);
+}
+
+int
+setup_signal (int sfd, int signo)
+{
+  sigset_t sigmask;
+
+  sigemptyset (&sigmask);
+  sigaddset (&sigmask, signo);
+
+  if (sigprocmask (SIG_BLOCK, &sigmask, NULL) == -1)
+    handle_error ("sigprocmask");
+
+  sfd = signalfd (sfd, &sigmask, 0);
+  if (sfd == -1)
+    handle_error ("signalfd");
+
+  return sfd;
+}
+
+int
+main ()
+{
+  struct itimerval timer = { 0 }, old;
+  struct epoll_event ie[2], events[2];
+  int val = -1;
+  int i, res = -1;
+  int sfd, epfd;
+
+  timer.it_interval.tv_sec = 1;
+  timer.it_value.tv_sec = 1;
+
+  sfd = setup_signal (-1, SIGALRM);
+  sfd = setup_signal (sfd, SIGALRM | SIGUSR1);
+
+  epfd = epoll_create (2);
+  if (epfd == -1)
+    handle_error ("epoll_create");
+
+  ie[0].events = EPOLLIN;
+  ie[0].data.u32 = STDIN_FILENO;
+  ie[1].events = EPOLLIN;
+  ie[1].data.u32 = sfd;
+
+  epoll_ctl (epfd, EPOLL_CTL_ADD, STDIN_FILENO, &ie[0]);
+  epoll_ctl (epfd, EPOLL_CTL_ADD, sfd, &ie[1]);
+
+  getitimer (ITIMER_REAL, &old);
+
+  assert (old.it_interval.tv_sec == 0);
+  assert (old.it_interval.tv_usec == 0);
+  assert (old.it_value.tv_sec == 0);
+  assert (old.it_value.tv_sec == 0);
+
+  setitimer (ITIMER_REAL, &timer, NULL);
+
+  for (i = 0; i < 5 && res < 0; i++)
+    {
+      res = epoll_wait (epfd, events, 2, -1);
+
+      if (res == 2)
+	break;
+
+      if (events[0].data.fd == sfd)
+	{
+	  struct signalfd_siginfo fdsi;
+
+	  res = read (sfd, &fdsi, sizeof (fdsi));
+	  if (res != sizeof (fdsi))
+	    handle_error ("read fdsi");
+
+	  assert (fdsi.ssi_signo == SIGALRM);
+
+	  res = -1;
+	}
+      else
+	res = read (STDIN_FILENO, &val, sizeof (int));
+
+      if (res == -1)
+	printf ("interrupted by the timer\n");
+      else
+	printf ("entered %c\n", val);
+    }
+
+  getitimer (ITIMER_REAL, &old);
+
+  assert (old.it_interval.tv_sec == timer.it_interval.tv_sec);
+  assert (old.it_interval.tv_usec == timer.it_interval.tv_usec);
+
+  close (sfd);
+
+  return 0;
+}
diff --git a/remote_io/test-signals.c b/remote_io/test-signals.c
new file mode 100644
index 0000000000..2c5625899b
--- /dev/null
+++ b/remote_io/test-signals.c
@@ -0,0 +1,94 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-signals.c -o tsig.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-signals.c -o tsig.a64.exe -g
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <dirent.h>
+#include <signal.h>
+#include <setjmp.h>
+#include <termio.h>
+#include <stdatomic.h>
+
+#define BUF_SZ 512
+
+char sigmsg[BUF_SZ] = "sighandler: count = ";
+int siginit = -1;
+jmp_buf jb;
+
+_Atomic int sigcnt;
+
+void
+sighandler (int signo)
+{
+  int i, j, cnt;
+
+  if (siginit == -1)
+    siginit = strlen (sigmsg);
+
+  cnt = ++sigcnt;
+
+  for (i = 1; cnt; cnt /= 10, i++)
+    sigmsg[BUF_SZ - i] = cnt % 10 + '0';
+
+  for (j = 0; j < i; j++)
+    sigmsg[siginit + j] = sigmsg[BUF_SZ - i + j + 1];
+  sigmsg[siginit + j] = '\n';
+  sigmsg[siginit + j + 1] = '\0';
+
+  i = strlen (sigmsg);
+  write (STDOUT_FILENO, sigmsg, i);
+  
+  longjmp (jb, 1);
+
+  return;
+}
+
+void
+job (int pid)
+{
+  static atomic_int i = 0;
+  int delay = 1000 * 1000 / 2;
+  int x;
+  
+  if (setjmp (jb) == 1)
+    {
+      sigset_t sigmask;
+
+      sigemptyset (&sigmask);
+      sigaddset (&sigmask, SIGINT);
+      sigprocmask (SIG_UNBLOCK, &sigmask, NULL);
+    }
+
+  while (1)
+    {
+      x = i++;
+      printf ("%d: %d\n", pid, x);
+      usleep (delay);
+    }
+}
+
+int
+main ()
+{
+  struct sigaction sigact;
+  sigset_t sigmask;
+
+  sigact.sa_flags = 0;
+  sigact.sa_handler = sighandler;
+  sigemptyset (&sigact.sa_mask);
+
+  sigemptyset (&sigmask);
+  sigaddset (&sigmask, SIGUSR1);
+  sigprocmask (SIG_BLOCK, &sigmask, NULL);
+  sigaction (SIGINT, &sigact, NULL); /* CTRL-c; exit with CTRL-\  */
+
+  job (getpid ());
+}
diff --git a/remote_io/test-socket-client.c b/remote_io/test-socket-client.c
new file mode 100644
index 0000000000..1846c43b2f
--- /dev/null
+++ b/remote_io/test-socket-client.c
@@ -0,0 +1,69 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-socket-client.c -g -o tsc.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-socket-client.c -g -o tsc.a64.exe
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <unistd.h>
+
+#include <string.h>
+
+#define PORT 3124
+
+int
+main (int argc, char *argv[])
+{
+  int sockfd, n;
+  struct sockaddr_in saddr;
+  struct hostent *server;
+
+  if (argc < 3)
+    {
+      fprintf(stderr,"Usage: %s hostname \"message\"\n", argv[0]);
+      exit(0);
+    }
+
+  sockfd = socket(AF_INET, SOCK_STREAM, 0);
+
+  if (sockfd < 0)
+    {
+      perror("ERROR opening socket");
+      exit(1);
+    }
+
+  server = gethostbyname (argv[1]);
+
+  if (server == NULL)
+    {
+      fprintf (stderr,"ERROR, no such host\n");
+      exit (EXIT_FAILURE);
+    }
+
+  bzero ((char *) &saddr, sizeof(saddr));
+  saddr.sin_family = AF_INET;
+  bcopy ((char *)server->h_addr,
+	 (char *)&saddr.sin_addr.s_addr,
+	 server->h_length);
+  saddr.sin_port = htons (PORT);
+
+  if (connect (sockfd, (struct sockaddr*)&saddr, sizeof (saddr)) < 0)
+    {
+      perror("ERROR connecting");
+      exit(1);
+    }
+
+  n = send (sockfd, argv[2], strlen (argv[2]), 0);
+
+  if (n < 0)
+    {
+      perror ("ERROR writing to socket");
+      exit (1);
+    }
+
+  printf ("sent> %s\n", argv[2]);
+
+  return 0;
+}
diff --git a/remote_io/test-socket-server.c b/remote_io/test-socket-server.c
new file mode 100644
index 0000000000..40c6a72849
--- /dev/null
+++ b/remote_io/test-socket-server.c
@@ -0,0 +1,84 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-socket-server.c -g -o tss.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-socket-server.c -g -o tss.a64.exe
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <string.h>
+
+#define PORT 3124
+
+int
+main (int argc, char *argv[])
+{
+  int sockfd, newsockfd, len;
+  char buffer[256], client[INET6_ADDRSTRLEN], host[INET6_ADDRSTRLEN];
+  struct sockaddr_in saddr, caddr, haddr, *s;
+  struct sockaddr_storage addr;
+  int n;
+
+  sockfd = socket (AF_INET, SOCK_STREAM, 0);
+
+  if (sockfd < 0)
+    {
+      perror("ERROR opening socket");
+      exit(1);
+    }
+
+  bzero ((char *) &saddr, sizeof (saddr));
+
+  saddr.sin_family = AF_INET;
+  saddr.sin_addr.s_addr = INADDR_ANY;
+  saddr.sin_port = htons(PORT);
+
+  if (bind(sockfd, (struct sockaddr *) &saddr, sizeof (saddr)) < 0)
+    {
+      perror("ERROR on binding");
+      exit(1);
+    }
+
+  listen (sockfd, 5);
+  len = sizeof (caddr);
+
+  newsockfd = accept (sockfd, (struct sockaddr *)&caddr, &len);
+
+  if (newsockfd < 0)
+    {
+      perror("ERROR on accept");
+      exit(1);
+    }
+
+  len = sizeof (addr);
+  getpeername (newsockfd, (struct sockaddr *)&addr, &len);
+  s = (struct sockaddr_in *)&addr;
+  inet_ntop (AF_INET, &s->sin_addr, client, INET6_ADDRSTRLEN);
+
+  getsockname (newsockfd, (struct sockaddr *)&addr, &len);
+  inet_ntop (AF_INET, &s->sin_addr, host, INET6_ADDRSTRLEN);
+
+  bzero (buffer,256);
+  n = read (newsockfd, buffer, 255);
+
+  if (n < 0)
+    {
+      perror("ERROR reading from socket");
+      exit(1);
+    }
+
+  printf ("%s->%s:%d> %s\n", client, host, ntohs(s->sin_port), buffer);
+
+  if (n < 0)
+    {
+      perror("ERROR writing to socket");
+      exit(1);
+    }
+
+  return 0;
+}
diff --git a/remote_io/test-stat.c b/remote_io/test-stat.c
new file mode 100644
index 0000000000..413d976b5f
--- /dev/null
+++ b/remote_io/test-stat.c
@@ -0,0 +1,37 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+
+void
+dump_stat (char *file, struct stat *st)
+{
+  printf ("file = %s\n", file);
+  printf ("dev = %lx, ino = %lx, mode = %u, nlink = %x uid = %x, gid = %x\n",
+	  st->st_dev, st->st_ino, st->st_mode, st->st_nlink,
+	  st->st_uid, st->st_gid);
+  printf ("rdev = %lx, size = %lu, blksize = %x, blocks = %lu\n",
+	  st->st_rdev, st->st_size, st->st_blksize, st->st_blocks);
+}
+
+int
+main ()
+{
+  struct stat st;
+
+  fstat (1, &st);
+  dump_stat ("stdout", &st);
+  bzero (&st, sizeof (st));
+
+  stat (__FILE__, &st);
+  dump_stat (__FILE__, &st);
+  bzero (&st, sizeof (st));
+
+  lstat (__FILE__, &st);
+  dump_stat (__FILE__, &st);
+
+  return 0;
+}
diff --git a/remote_io/test-statfs.c b/remote_io/test-statfs.c
new file mode 100644
index 0000000000..032586d4af
--- /dev/null
+++ b/remote_io/test-statfs.c
@@ -0,0 +1,65 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/vfs.h>
+#include <unistd.h>
+
+void
+dump_statfs (struct statfs *st, const char *fname)
+{
+  printf ("file = %s\n", fname);
+  printf ("f_type = %lx\n", st->f_type);
+  printf ("f_bsize = %ld\n", st->f_bsize);
+  printf ("f_blocks = %ld\n", st->f_blocks);
+  printf ("f_bfree = %ld\n", st->f_bfree);
+  printf ("f_bavail = %ld\n", st->f_bavail);
+  printf ("f_files = %ld\n", st->f_files);
+  printf ("f_ffree = %ld\n", st->f_ffree);
+  printf ("f_fsid = %lx\n", st->f_fsid);
+  printf ("f_namelen = %ld\n", st->f_namelen);
+  printf ("f_frsize = %ld\n", st->f_frsize);
+  printf ("f_flags = %ld\n\n", st->f_flags);
+}
+
+int
+main ()
+{
+  struct statfs st;
+  const char *tmp = "/tmp/t.statfs";
+  int fd, res;
+
+  res = statfs (__FILE__, &st);
+  if (res < 0)
+    {
+      perror ("statfs failed");
+      exit (EXIT_FAILURE);
+    }
+
+  printf ("sizeof (struct statfs) = %ld\n", sizeof (struct statfs));
+  printf ("sizeof (__fsword_t) = %ld\n", sizeof (__fsword_t));
+  printf ("sizeof (fsblkcnt_t) = %ld\n", sizeof (fsblkcnt_t));
+  printf ("sizeof (fsid_t) = %ld\n\n", sizeof (fsid_t));
+
+  dump_statfs (&st, __FILE__);
+
+  fd = open (tmp, O_WRONLY|O_CREAT|O_NOCTTY|O_NONBLOCK, 0666);
+  if (fd < 0)
+    {
+      perror ("open failed");
+      exit (EXIT_FAILURE);
+    }
+
+  res = fstatfs (fd, &st);
+  if (res < 0)
+    {
+      perror ("statfs failed");
+      exit (EXIT_FAILURE);
+    }
+
+  dump_statfs (&st, tmp);
+  close (fd);
+  unlink (tmp);
+
+  return 0;
+}
diff --git a/remote_io/test-stream-recvmsg.c b/remote_io/test-stream-recvmsg.c
new file mode 100644
index 0000000000..90429752d2
--- /dev/null
+++ b/remote_io/test-stream-recvmsg.c
@@ -0,0 +1,103 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-stream-recvmsg.c -g -o recvmsg.exe
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-stream-recvmsg.c -g -o recvmsg.a64.exe
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <string.h>
+
+#define PORT 3124
+
+int
+main (int argc, char *argv[])
+{
+  int sockfd, newsockfd, len;
+  char hdr[4], payload[256], ip[INET6_ADDRSTRLEN];
+  struct sockaddr_in saddr, caddr, *s;
+  struct sockaddr_storage addr;
+  struct iovec iov[2];
+  struct msghdr mhdr;
+  struct cmsghdr chdr;
+  int n;
+
+  bzero (&mhdr, sizeof mhdr);
+  bzero (&chdr, sizeof chdr);
+
+  sockfd = socket (AF_INET, SOCK_STREAM, 0);
+
+  if (sockfd < 0)
+    {
+      perror("ERROR opening socket");
+      exit(1);
+    }
+
+  bzero ((char *) &saddr, sizeof (saddr));
+
+  saddr.sin_family = AF_INET;
+  saddr.sin_addr.s_addr = INADDR_ANY;
+  saddr.sin_port = htons(PORT);
+
+  if (bind(sockfd, (struct sockaddr *) &saddr, sizeof (saddr)) < 0)
+    {
+      perror("ERROR on binding");
+      exit(1);
+    }
+
+  listen (sockfd, 5);
+  len = sizeof (caddr);
+
+  newsockfd = accept (sockfd, (struct sockaddr *)&caddr, &len);
+
+  if (newsockfd < 0)
+    {
+      perror("ERROR on accept");
+      exit(1);
+    }
+
+  len = sizeof (addr);
+  getpeername (newsockfd, (struct sockaddr *)&addr, &len);
+  s = (struct sockaddr_in *)&addr;
+  inet_ntop (AF_INET, &s->sin_addr, ip, INET6_ADDRSTRLEN);
+
+  bzero (hdr, 4);
+  bzero (payload, 256);
+
+  iov[0].iov_base = hdr;
+  iov[0].iov_len = 4;
+  iov[1].iov_base = payload;
+  iov[1].iov_len = 256;
+
+  mhdr.msg_iov = iov;
+  mhdr.msg_iovlen = 2;
+  mhdr.msg_name = &addr;
+  mhdr.msg_namelen = sizeof addr;
+  mhdr.msg_control = &chdr;
+  mhdr.msg_controllen = sizeof chdr;
+  mhdr.msg_flags = 0;
+
+  n = recvmsg (newsockfd, &mhdr, 0);
+
+  if (n < 0)
+    {
+      perror("ERROR reading from socket");
+      exit(1);
+    }
+
+  printf ("%s:%d> [%s] %s\n", ip, ntohs(s->sin_port), hdr, payload);
+
+  if (n < 0)
+    {
+      perror("ERROR writing to socket");
+      exit(1);
+    }
+
+  return 0;
+}
diff --git a/remote_io/test-sync.c b/remote_io/test-sync.c
new file mode 100644
index 0000000000..d2701be2d3
--- /dev/null
+++ b/remote_io/test-sync.c
@@ -0,0 +1,30 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-sync.c -o tsync.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-sync.c -o tsync.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+int
+main ()
+{
+  int fd = open ("out.test-sync", O_CREAT|O_WRONLY|O_TRUNC, 0644);
+  const char *msg = "abcdefg\n";
+  
+  if (fd < 0)
+    {
+      perror ("open failed");
+      exit (EXIT_FAILURE);
+    }
+
+  write (fd, msg, strlen (msg) + 1);
+
+  fsync (fd);
+  fdatasync (fd);
+  close (fd);
+
+  return 0;
+}
diff --git a/remote_io/test-sysv-shm-1.c b/remote_io/test-sysv-shm-1.c
new file mode 100644
index 0000000000..e60ddd6c95
--- /dev/null
+++ b/remote_io/test-sysv-shm-1.c
@@ -0,0 +1,60 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/shm.h>
+#include <sys/wait.h>
+
+#define BUFSZ 4096
+
+void
+error (char *msg)
+{
+  perror (msg);
+  exit (EXIT_FAILURE);
+}
+
+int
+main ()
+{
+  int shmid, pid, len, status;
+  char *mem;
+  char *msg = "I didn't receive anything!";
+
+  shmid = shmget(IPC_PRIVATE, BUFSZ, IPC_CREAT | 0600);
+  if (shmid == -1)
+    error ("shmid");
+
+  pid = fork ();
+
+  if (pid == 0)
+    {
+      mem = (char *)shmat(shmid, NULL, 0);
+      if (mem == (char *)-1)
+	error ("shmat");
+
+      printf ("> ");
+      fflush (stdout);
+      len = read (STDIN_FILENO, mem, BUFSZ - 1);
+
+      if (len == -1)
+	memcpy (mem, msg, strlen (msg));
+      else
+	mem[len] = '\0';
+
+      exit (EXIT_SUCCESS);
+    }
+
+  waitpid (pid, &status, 0);
+
+  mem = (char *)shmat(shmid, NULL, SHM_RDONLY);
+  if (mem == (char *)-1)
+    error ("shmat");
+
+  printf ("MSG = %s", mem);
+
+  if (shmctl(shmid, IPC_RMID, NULL) == -1)
+    error ("shmid");
+
+  return 0;
+}
diff --git a/remote_io/test-truncate.c b/remote_io/test-truncate.c
new file mode 100644
index 0000000000..425ccf61d4
--- /dev/null
+++ b/remote_io/test-truncate.c
@@ -0,0 +1,43 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-truncate.c -o ttruncate.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-truncate.c -o ttruncate.a64.exe -g
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <sys/stat.h>
+
+int
+main ()
+{
+  const char *fname = "out.test-truncate";
+  int fd = open (fname, O_CREAT|O_WRONLY|O_TRUNC, 0644);
+  const char *msg = "abcdefg\n";
+  struct stat st;
+
+  if (fd < 0)
+    {
+      perror ("open failed");
+      exit (EXIT_FAILURE);
+    }
+
+  write (fd, msg, strlen (msg) + 1);
+
+  ftruncate (fd, 0);
+  ftruncate (fd, 100);
+
+  fstat (fd, &st);
+  assert (st.st_size == 100);
+
+  close (fd);
+
+  truncate (fname, 50);
+
+  stat (fname, &st);
+  assert (st.st_size == 50);
+
+  return 0;
+}
diff --git a/remote_io/test-umask.c b/remote_io/test-umask.c
new file mode 100644
index 0000000000..60eeb49e17
--- /dev/null
+++ b/remote_io/test-umask.c
@@ -0,0 +1,36 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-umask.c -o tumask.exe -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-umask.c -o tumask.a64.exe -g
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#define BUFSZ 100
+
+int
+main ()
+{
+  char fname[] = "test.umask";
+  char msg[] = "abcdefghjklmnopqrstuvwxyz";
+  char buf[BUFSZ];
+  int mlen = strlen (msg);
+  int fd, ret;
+  struct stat stat;
+
+  umask (027);
+
+  unlink (fname);
+
+  fd = open (fname, O_CREAT|O_WRONLY|O_TRUNC, 0777);
+  write (fd, msg, mlen);
+  fstat (fd, &stat);
+
+  printf ("st_mode = 0%o\n", stat.st_mode);
+
+  close (fd);
+
+  return unlink (fname);
+}
diff --git a/remote_io/test-uname.c b/remote_io/test-uname.c
new file mode 100644
index 0000000000..be68745647
--- /dev/null
+++ b/remote_io/test-uname.c
@@ -0,0 +1,23 @@
+// x86_64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/x86_64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/x86_64/lib/ test-uname.c -g
+
+// aarch64-popcorn-linux-gnu-gcc -Wl,-dynamic-linker,/scratch/pjr/inst/aarch64/lib/ld-2.31.so -Wl,-rpath,/scratch/pjr/inst/aarch64/lib/ test-uname.c -g
+
+#include <stdio.h>
+#include <sys/utsname.h>
+
+int
+main ()
+{
+  struct utsname buf;
+
+  uname (&buf);
+  
+  printf ("sizeof (struct utsname) = %d\n", sizeof buf);
+  printf ("sysname = %s\n", buf.sysname);
+  printf ("nodename = %s\n", buf.nodename);
+  printf ("release = %s\n", buf.release);
+  printf ("version = %s\n", buf.version);
+  printf ("machine = %s\n", buf.machine);
+
+  return 0;
+}
diff --git a/stdio-common/Makefile b/stdio-common/Makefile
index 5e92d6b9ae..95af0c12d7 100644
--- a/stdio-common/Makefile
+++ b/stdio-common/Makefile
@@ -66,10 +66,6 @@ tests := tstscanf test_rdwr test-popen tstgetln test-fseek \
 	 tst-scanf-round \
 	 tst-renameat2 tst-bz11319 tst-bz11319-fortify2 \
 	 scanf14a scanf16a \
-	 tst-printf-bz25691 \
-	 tst-vfprintf-width-prec-alloc \
-	 tst-grouping2 \
-  # tests
 
 
 test-srcs = tst-unbputc tst-printf tst-printfsz-islongdouble
@@ -79,12 +75,10 @@ tests-special += $(objpfx)tst-unbputc.out $(objpfx)tst-printf.out \
 		 $(objpfx)tst-printf-bz18872-mem.out \
 		 $(objpfx)tst-setvbuf1-cmp.out \
 		 $(objpfx)tst-vfprintf-width-prec-mem.out \
-		 $(objpfx)tst-printfsz-islongdouble.out \
-		 $(objpfx)tst-printf-bz25691-mem.out
+		 $(objpfx)tst-printfsz-islongdouble.out
 generated += tst-printf-bz18872.c tst-printf-bz18872.mtrace \
 	     tst-printf-bz18872-mem.out \
-	     tst-vfprintf-width-prec.mtrace tst-vfprintf-width-prec-mem.out \
-	     tst-printf-bz25691.mtrace tst-printf-bz25691-mem.out
+	     tst-vfprintf-width-prec.mtrace tst-vfprintf-width-prec-mem.out
 endif
 
 include ../Rules
@@ -97,7 +91,6 @@ $(objpfx)bug14.out: $(gen-locales)
 $(objpfx)scanf13.out: $(gen-locales)
 $(objpfx)test-vfprintf.out: $(gen-locales)
 $(objpfx)tst-grouping.out: $(gen-locales)
-$(objpfx)tst-grouping2.out: $(gen-locales)
 $(objpfx)tst-sprintf.out: $(gen-locales)
 $(objpfx)tst-sscanf.out: $(gen-locales)
 $(objpfx)tst-swprintf.out: $(gen-locales)
@@ -107,8 +100,6 @@ endif
 tst-printf-bz18872-ENV = MALLOC_TRACE=$(objpfx)tst-printf-bz18872.mtrace
 tst-vfprintf-width-prec-ENV = \
   MALLOC_TRACE=$(objpfx)tst-vfprintf-width-prec.mtrace
-tst-printf-bz25691-ENV = \
-  MALLOC_TRACE=$(objpfx)tst-printf-bz25691.mtrace
 
 $(objpfx)tst-unbputc.out: tst-unbputc.sh $(objpfx)tst-unbputc
 	$(SHELL) $< $(common-objpfx) '$(test-program-prefix)' > $@; \
diff --git a/stdio-common/bug22.c b/stdio-common/bug22.c
index 029b549941..b3d48eb8e1 100644
--- a/stdio-common/bug22.c
+++ b/stdio-common/bug22.c
@@ -57,7 +57,7 @@ do_test (void)
 
   ret = fprintf (fp, "%." SN3 "d", 1);
   printf ("ret = %d\n", ret);
-  if (ret != N3)
+  if (ret != -1 || errno != EOVERFLOW)
 	  return 1;
 
   /* GCC 9 warns about output of more than INT_MAX characters; this is
diff --git a/stdio-common/tst-printf-bz25691.c b/stdio-common/tst-printf-bz25691.c
deleted file mode 100644
index 37b30a3a8a..0000000000
--- a/stdio-common/tst-printf-bz25691.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Test for memory leak with large width (BZ#25691).
-   Copyright (C) 2020 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <wchar.h>
-#include <stdint.h>
-#include <locale.h>
-
-#include <mcheck.h>
-#include <support/check.h>
-#include <support/support.h>
-
-static int
-do_test (void)
-{
-  mtrace ();
-
-  /* For 's' conversion specifier with 'l' modifier the array must be
-     converted to multibyte characters up to the precision specific
-     value.  */
-  {
-    /* The input size value is to force a heap allocation on temporary
-       buffer (in the old implementation).  */
-    const size_t winputsize = 64 * 1024 + 1;
-    wchar_t *winput = xmalloc (winputsize * sizeof (wchar_t));
-    wmemset (winput, L'a', winputsize - 1);
-    winput[winputsize - 1] = L'\0';
-
-    char result[9];
-    const char expected[] = "aaaaaaaa";
-    int ret;
-
-    ret = snprintf (result, sizeof (result), "%.65537ls", winput);
-    TEST_COMPARE (ret, winputsize - 1);
-    TEST_COMPARE_BLOB (result, sizeof (result), expected, sizeof (expected));
-
-    ret = snprintf (result, sizeof (result), "%ls", winput);
-    TEST_COMPARE (ret, winputsize - 1);
-    TEST_COMPARE_BLOB (result, sizeof (result), expected, sizeof (expected));
-
-    free (winput);
-  }
-
-  /* For 's' converstion specifier the array is interpreted as a multibyte
-     character sequence and converted to wide characters up to the precision
-     specific value.  */
-  {
-    /* The input size value is to force a heap allocation on temporary
-       buffer (in the old implementation).  */
-    const size_t mbssize = 32 * 1024;
-    char *mbs = xmalloc (mbssize);
-    memset (mbs, 'a', mbssize - 1);
-    mbs[mbssize - 1] = '\0';
-
-    const size_t expectedsize = 32 * 1024;
-    wchar_t *expected = xmalloc (expectedsize * sizeof (wchar_t));
-    wmemset (expected, L'a', expectedsize - 1);
-    expected[expectedsize-1] = L'\0';
-
-    const size_t resultsize = mbssize * sizeof (wchar_t);
-    wchar_t *result = xmalloc (resultsize);
-    int ret;
-
-    ret = swprintf (result, resultsize, L"%.65537s", mbs);
-    TEST_COMPARE (ret, mbssize - 1);
-    TEST_COMPARE_BLOB (result, (ret + 1) * sizeof (wchar_t),
-		       expected, expectedsize * sizeof (wchar_t));
-
-    ret = swprintf (result, resultsize, L"%1$.65537s", mbs);
-    TEST_COMPARE (ret, mbssize - 1);
-    TEST_COMPARE_BLOB (result, (ret + 1) * sizeof (wchar_t),
-		       expected, expectedsize * sizeof (wchar_t));
-
-    /* Same test, but with an invalid multibyte sequence.  */
-    mbs[mbssize - 2] = 0xff;
-
-    ret = swprintf (result, resultsize, L"%.65537s", mbs);
-    TEST_COMPARE (ret, -1);
-
-    ret = swprintf (result, resultsize, L"%1$.65537s", mbs);
-    TEST_COMPARE (ret, -1);
-
-    free (mbs);
-    free (result);
-    free (expected);
-  }
-
-  return 0;
-}
-
-#include <support/test-driver.c>
diff --git a/stdio-common/tst-vfprintf-width-prec-alloc.c b/stdio-common/tst-vfprintf-width-prec-alloc.c
deleted file mode 100644
index 0a74b53a33..0000000000
--- a/stdio-common/tst-vfprintf-width-prec-alloc.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/* Test large width or precision does not involve large allocation.
-   Copyright (C) 2020 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <stdio.h>
-#include <sys/resource.h>
-#include <support/check.h>
-
-char test_string[] = "test";
-
-static int
-do_test (void)
-{
-  struct rlimit limit;
-  TEST_VERIFY_EXIT (getrlimit (RLIMIT_AS, &limit) == 0);
-  limit.rlim_cur = 200 * 1024 * 1024;
-  TEST_VERIFY_EXIT (setrlimit (RLIMIT_AS, &limit) == 0);
-  FILE *fp = fopen ("/dev/null", "w");
-  TEST_VERIFY_EXIT (fp != NULL);
-  TEST_COMPARE (fprintf (fp, "%1000000000d", 1), 1000000000);
-  TEST_COMPARE (fprintf (fp, "%.1000000000s", test_string), 4);
-  TEST_COMPARE (fprintf (fp, "%1000000000d %1000000000d", 1, 2), 2000000001);
-  TEST_COMPARE (fprintf (fp, "%2$.*1$s", 0x7fffffff, test_string), 4);
-  return 0;
-}
-
-#include <support/test-driver.c>
diff --git a/stdio-common/vfprintf-internal.c b/stdio-common/vfprintf-internal.c
index b1c8f5c43e..3be92d4b6e 100644
--- a/stdio-common/vfprintf-internal.c
+++ b/stdio-common/vfprintf-internal.c
@@ -31,7 +31,6 @@
 #include <locale/localeinfo.h>
 #include <stdio.h>
 #include <scratch_buffer.h>
-#include <intprops.h>
 
 /* This code is shared between the standard stdio implementation found
    in GNU C library and the libio implementation originally found in
@@ -46,6 +45,10 @@
 #include <wctype.h>
 #endif
 
+/* In some cases we need extra space for all the output which is not
+   counted in the width of the string. We assume 32 characters is
+   enough.  */
+#define EXTSIZ		32
 #define ARGCHECK(S, Format) \
   do									      \
     {									      \
@@ -116,38 +119,22 @@
   while (0)
 #endif
 
-/* Add LENGTH to DONE.  Return the new value of DONE, or -1 on
-   overflow (and set errno accordingly).  */
-static inline int
-done_add_func (size_t length, int done)
-{
-  if (done < 0)
-    return done;
-  int ret;
-  if (INT_ADD_WRAPV (done, length, &ret))
-    {
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-  return ret;
-}
-
-#define done_add(val)							\
-  do									\
-    {									\
-      /* Ensure that VAL has a type similar to int.  */			\
-      _Static_assert (sizeof (val) == sizeof (int), "value int size");	\
-      _Static_assert ((__typeof__ (val)) -1 < 0, "value signed");	\
-      done = done_add_func ((val), done);				\
-      if (done < 0)							\
-	goto all_done;							\
-    }									\
-  while (0)
+#define done_add(val) \
+  do {									      \
+    unsigned int _val = val;						      \
+    assert ((unsigned int) done < (unsigned int) INT_MAX);		      \
+    if (__glibc_unlikely (INT_MAX - done < _val))			      \
+      {									      \
+	done = -1;							      \
+	 __set_errno (EOVERFLOW);					      \
+	goto all_done;							      \
+      }									      \
+    done += _val;							      \
+  } while (0)
 
 #ifndef COMPILE_WPRINTF
 # define vfprintf	__vfprintf_internal
 # define CHAR_T		char
-# define OTHER_CHAR_T   wchar_t
 # define UCHAR_T	unsigned char
 # define INT_T		int
 typedef const char *THOUSANDS_SEP_T;
@@ -156,14 +143,25 @@ typedef const char *THOUSANDS_SEP_T;
 # define STR_LEN(Str)	strlen (Str)
 
 # define PUT(F, S, N)	_IO_sputn ((F), (S), (N))
+# define PAD(Padchar) \
+  do {									      \
+    if (width > 0)							      \
+      {									      \
+	ssize_t written = _IO_padn (s, (Padchar), width);		      \
+	if (__glibc_unlikely (written != width))			      \
+	  {								      \
+	    done = -1;							      \
+	    goto all_done;						      \
+	  }								      \
+	done_add (written);						      \
+      }									      \
+  } while (0)
 # define PUTC(C, F)	_IO_putc_unlocked (C, F)
 # define ORIENT		if (_IO_vtable_offset (s) == 0 && _IO_fwide (s, -1) != -1)\
 			  return -1
-# define CONVERT_FROM_OTHER_STRING __wcsrtombs
 #else
 # define vfprintf	__vfwprintf_internal
 # define CHAR_T		wchar_t
-# define OTHER_CHAR_T   char
 /* This is a hack!!!  There should be a type uwchar_t.  */
 # define UCHAR_T	unsigned int /* uwchar_t */
 # define INT_T		wint_t
@@ -175,9 +173,21 @@ typedef wchar_t THOUSANDS_SEP_T;
 # include <_itowa.h>
 
 # define PUT(F, S, N)	_IO_sputn ((F), (S), (N))
+# define PAD(Padchar) \
+  do {									      \
+    if (width > 0)							      \
+      {									      \
+	ssize_t written = _IO_wpadn (s, (Padchar), width);		      \
+	if (__glibc_unlikely (written != width))			      \
+	  {								      \
+	    done = -1;							      \
+	    goto all_done;						      \
+	  }								      \
+	done_add (written);						      \
+      }									      \
+  } while (0)
 # define PUTC(C, F)	_IO_putwc_unlocked (C, F)
 # define ORIENT		if (_IO_fwide (s, 1) != 1) return -1
-# define CONVERT_FROM_OTHER_STRING __mbsrtowcs
 
 # undef _itoa
 # define _itoa(Val, Buf, Base, Case) _itowa (Val, Buf, Base, Case)
@@ -186,33 +196,6 @@ typedef wchar_t THOUSANDS_SEP_T;
 # define EOF WEOF
 #endif
 
-static inline int
-pad_func (FILE *s, CHAR_T padchar, int width, int done)
-{
-  if (width > 0)
-    {
-      ssize_t written;
-#ifndef COMPILE_WPRINTF
-      written = _IO_padn (s, padchar, width);
-#else
-      written = _IO_wpadn (s, padchar, width);
-#endif
-      if (__glibc_unlikely (written != width))
-	return -1;
-      return done_add_func (width, done);
-    }
-  return done;
-}
-
-#define PAD(Padchar)							\
-  do									\
-    {									\
-      done = pad_func (s, (Padchar), width, done);			\
-      if (done < 0)							\
-	goto all_done;							\
-    }									\
-  while (0)
-
 #include "_i18n_number.h"
 
 /* Include the shared code for parsing the format string.  */
@@ -232,115 +215,24 @@ pad_func (FILE *s, CHAR_T padchar, int width, int done)
     }									      \
   while (0)
 
-static inline int
-outstring_func (FILE *s, const UCHAR_T *string, size_t length, int done)
-{
-  assert ((size_t) done <= (size_t) INT_MAX);
-  if ((size_t) PUT (s, string, length) != (size_t) (length))
-    return -1;
-  return done_add_func (length, done);
-}
-
-#define outstring(String, Len)						\
-  do									\
-    {									\
-      const void *string_ = (String);					\
-      done = outstring_func (s, string_, (Len), done);			\
-      if (done < 0)							\
-	goto all_done;							\
-    }									\
-   while (0)
-
-/* Write the string SRC to S.  If PREC is non-negative, write at most
-   PREC bytes.  If LEFT is true, perform left justification.  */
-static int
-outstring_converted_wide_string (FILE *s, const OTHER_CHAR_T *src, int prec,
-				 int width, bool left, int done)
-{
-  /* Use a small buffer to combine processing of multiple characters.
-     CONVERT_FROM_OTHER_STRING expects the buffer size in (wide)
-     characters, and buf_length counts that.  */
-  enum { buf_length = 256 / sizeof (CHAR_T) };
-  CHAR_T buf[buf_length];
-  _Static_assert (sizeof (buf) > MB_LEN_MAX,
-		  "buffer is large enough for a single multi-byte character");
-
-  /* Add the initial padding if needed.  */
-  if (width > 0 && !left)
-    {
-      /* Make a first pass to find the output width, so that we can
-	 add the required padding.  */
-      mbstate_t mbstate = { 0 };
-      const OTHER_CHAR_T *src_copy = src;
-      size_t total_written;
-      if (prec < 0)
-	total_written = CONVERT_FROM_OTHER_STRING
-	  (NULL, &src_copy, 0, &mbstate);
-      else
-	{
-	  /* The source might not be null-terminated.  Enforce the
-	     limit manually, based on the output length.  */
-	  total_written = 0;
-	  size_t limit = prec;
-	  while (limit > 0 && src_copy != NULL)
-	    {
-	      size_t write_limit = buf_length;
-	      if (write_limit > limit)
-		write_limit = limit;
-	      size_t written = CONVERT_FROM_OTHER_STRING
-		(buf, &src_copy, write_limit, &mbstate);
-	      if (written == (size_t) -1)
-		return -1;
-	      if (written == 0)
-		break;
-	      total_written += written;
-	      limit -= written;
-	    }
-	}
-
-      /* Output initial padding.  */
-      if (total_written < width)
-	{
-	  done = pad_func (s, L_(' '), width - total_written, done);
-	  if (done < 0)
-	    return done;
-	}
-    }
-
-  /* Convert the input string, piece by piece.  */
-  size_t total_written = 0;
-  {
-    mbstate_t mbstate = { 0 };
-    /* If prec is negative, remaining is not decremented, otherwise,
-      it serves as the write limit.  */
-    size_t remaining = -1;
-    if (prec >= 0)
-      remaining = prec;
-    while (remaining > 0 && src != NULL)
-      {
-	size_t write_limit = buf_length;
-	if (remaining < write_limit)
-	  write_limit = remaining;
-	size_t written = CONVERT_FROM_OTHER_STRING
-	  (buf, &src, write_limit, &mbstate);
-	if (written == (size_t) -1)
-	  return -1;
-	if (written == 0)
-	  break;
-	done = outstring_func (s, (const UCHAR_T *) buf, written, done);
-	if (done < 0)
-	  return done;
-	total_written += written;
-	if (prec >= 0)
-	  remaining -= written;
-      }
-  }
-
-  /* Add final padding.  */
-  if (width > 0 && left && total_written < width)
-    return pad_func (s, L_(' '), width - total_written, done);
-  return done;
-}
+#define outstring(String, Len)						      \
+  do									      \
+    {									      \
+      assert ((size_t) done <= (size_t) INT_MAX);			      \
+      if ((size_t) PUT (s, (String), (Len)) != (size_t) (Len))		      \
+	{								      \
+	  done = -1;							      \
+	  goto all_done;						      \
+	}								      \
+      if (__glibc_unlikely (INT_MAX - done < (Len)))			      \
+      {									      \
+	done = -1;							      \
+	 __set_errno (EOVERFLOW);					      \
+	goto all_done;							      \
+      }									      \
+      done += (Len);							      \
+    }									      \
+  while (0)
 
 /* For handling long_double and longlong we use the same flag.  If
    `long' and `long long' are effectively the same type define it to
@@ -1130,6 +1022,7 @@ static const uint8_t jump_table[] =
     LABEL (form_string):						      \
       {									      \
 	size_t len;							      \
+	int string_malloced;						      \
 									      \
 	/* The string argument could in fact be `char *' or `wchar_t *'.      \
 	   But this should not make a difference here.  */		      \
@@ -1141,6 +1034,7 @@ static const uint8_t jump_table[] =
 	/* Entry point for printing other strings.  */			      \
       LABEL (print_string):						      \
 									      \
+	string_malloced = 0;						      \
 	if (string == NULL)						      \
 	  {								      \
 	    /* Write "(null)" if there's space.  */			      \
@@ -1157,12 +1051,41 @@ static const uint8_t jump_table[] =
 	  }								      \
 	else if (!is_long && spec != L_('S'))				      \
 	  {								      \
-	    done = outstring_converted_wide_string			      \
-	      (s, (const char *) string, prec, width, left, done);	      \
-	    if (done < 0)						      \
-	      goto all_done;						      \
-	    /* The padding has already been written.  */		      \
-	    break;							      \
+	    /* This is complicated.  We have to transform the multibyte	      \
+	       string into a wide character string.  */			      \
+	    const char *mbs = (const char *) string;			      \
+	    mbstate_t mbstate;						      \
+									      \
+	    len = prec != -1 ? __strnlen (mbs, (size_t) prec) : strlen (mbs); \
+									      \
+	    /* Allocate dynamically an array which definitely is long	      \
+	       enough for the wide character version.  Each byte in the	      \
+	       multi-byte string can produce at most one wide character.  */  \
+	    if (__glibc_unlikely (len > SIZE_MAX / sizeof (wchar_t)))	      \
+	      {								      \
+		__set_errno (EOVERFLOW);				      \
+		done = -1;						      \
+		goto all_done;						      \
+	      }								      \
+	    else if (__libc_use_alloca (len * sizeof (wchar_t)))	      \
+	      string = (CHAR_T *) alloca (len * sizeof (wchar_t));	      \
+	    else if ((string = (CHAR_T *) malloc (len * sizeof (wchar_t)))    \
+		     == NULL)						      \
+	      {								      \
+		done = -1;						      \
+		goto all_done;						      \
+	      }								      \
+	    else							      \
+	      string_malloced = 1;					      \
+									      \
+	    memset (&mbstate, '\0', sizeof (mbstate_t));		      \
+	    len = __mbsrtowcs (string, &mbs, len, &mbstate);		      \
+	    if (len == (size_t) -1)					      \
+	      {								      \
+		/* Illegal multibyte character.  */			      \
+		done = -1;						      \
+		goto all_done;						      \
+	      }								      \
 	  }								      \
 	else								      \
 	  {								      \
@@ -1185,6 +1108,8 @@ static const uint8_t jump_table[] =
 	outstring (string, len);					      \
 	if (left)							      \
 	  PAD (L' ');							      \
+	if (__glibc_unlikely (string_malloced))				      \
+	  free (string);						      \
       }									      \
       break;
 #else
@@ -1233,6 +1158,7 @@ static const uint8_t jump_table[] =
     LABEL (form_string):						      \
       {									      \
 	size_t len;							      \
+	int string_malloced;						      \
 									      \
 	/* The string argument could in fact be `char *' or `wchar_t *'.      \
 	   But this should not make a difference here.  */		      \
@@ -1244,6 +1170,7 @@ static const uint8_t jump_table[] =
 	/* Entry point for printing other strings.  */			      \
       LABEL (print_string):						      \
 									      \
+	string_malloced = 0;						      \
 	if (string == NULL)						      \
 	  {								      \
 	    /* Write "(null)" if there's space.  */			      \
@@ -1269,12 +1196,51 @@ static const uint8_t jump_table[] =
 	  }								      \
 	else								      \
 	  {								      \
-	    done = outstring_converted_wide_string			      \
-	      (s, (const wchar_t *) string, prec, width, left, done);	      \
-	    if (done < 0)						      \
-	      goto all_done;						      \
-	    /* The padding has already been written.  */		      \
-	    break;							      \
+	    const wchar_t *s2 = (const wchar_t *) string;		      \
+	    mbstate_t mbstate;						      \
+									      \
+	    memset (&mbstate, '\0', sizeof (mbstate_t));		      \
+									      \
+	    if (prec >= 0)						      \
+	      {								      \
+		/* The string `s2' might not be NUL terminated.  */	      \
+		if (__libc_use_alloca (prec))				      \
+		  string = (char *) alloca (prec);			      \
+		else if ((string = (char *) malloc (prec)) == NULL)	      \
+		  {							      \
+		    done = -1;						      \
+		    goto all_done;					      \
+		  }							      \
+		else							      \
+		  string_malloced = 1;					      \
+		len = __wcsrtombs (string, &s2, prec, &mbstate);	      \
+	      }								      \
+	    else							      \
+	      {								      \
+		len = __wcsrtombs (NULL, &s2, 0, &mbstate);		      \
+		if (len != (size_t) -1)					      \
+		  {							      \
+		    assert (__mbsinit (&mbstate));			      \
+		    s2 = (const wchar_t *) string;			      \
+		    if (__libc_use_alloca (len + 1))			      \
+		      string = (char *) alloca (len + 1);		      \
+		    else if ((string = (char *) malloc (len + 1)) == NULL)    \
+		      {							      \
+			done = -1;					      \
+			goto all_done;					      \
+		      }							      \
+		    else						      \
+		      string_malloced = 1;				      \
+		    (void) __wcsrtombs (string, &s2, len + 1, &mbstate);      \
+		  }							      \
+	      }								      \
+									      \
+	    if (len == (size_t) -1)					      \
+	      {								      \
+		/* Illegal wide-character string.  */			      \
+		done = -1;						      \
+		goto all_done;						      \
+	      }								      \
 	  }								      \
 									      \
 	if ((width -= len) < 0)						      \
@@ -1288,6 +1254,8 @@ static const uint8_t jump_table[] =
 	outstring (string, len);					      \
 	if (left)							      \
 	  PAD (' ');							      \
+	if (__glibc_unlikely (string_malloced))			              \
+	  free (string);						      \
       }									      \
       break;
 #endif
@@ -1339,6 +1307,7 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)
 
   /* Buffer intermediate results.  */
   CHAR_T work_buffer[WORK_BUFFER_SIZE];
+  CHAR_T *workstart = NULL;
   CHAR_T *workend;
 
   /* We have to save the original argument pointer.  */
@@ -1447,6 +1416,7 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)
       UCHAR_T pad = L_(' ');/* Padding character.  */
       CHAR_T spec;
 
+      workstart = NULL;
       workend = work_buffer + WORK_BUFFER_SIZE;
 
       /* Get current character in format string.  */
@@ -1538,6 +1508,31 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)
 	    pad = L_(' ');
 	    left = 1;
 	  }
+
+	if (__glibc_unlikely (width >= INT_MAX / sizeof (CHAR_T) - EXTSIZ))
+	  {
+	    __set_errno (EOVERFLOW);
+	    done = -1;
+	    goto all_done;
+	  }
+
+	if (width >= WORK_BUFFER_SIZE - EXTSIZ)
+	  {
+	    /* We have to use a special buffer.  */
+	    size_t needed = ((size_t) width + EXTSIZ) * sizeof (CHAR_T);
+	    if (__libc_use_alloca (needed))
+	      workend = (CHAR_T *) alloca (needed) + width + EXTSIZ;
+	    else
+	      {
+		workstart = (CHAR_T *) malloc (needed);
+		if (workstart == NULL)
+		  {
+		    done = -1;
+		    goto all_done;
+		  }
+		workend = workstart + width + EXTSIZ;
+	      }
+	  }
       }
       JUMP (*f, step1_jumps);
 
@@ -1545,13 +1540,31 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)
     LABEL (width):
       width = read_int (&f);
 
-      if (__glibc_unlikely (width == -1))
+      if (__glibc_unlikely (width == -1
+			    || width >= INT_MAX / sizeof (CHAR_T) - EXTSIZ))
 	{
 	  __set_errno (EOVERFLOW);
 	  done = -1;
 	  goto all_done;
 	}
 
+      if (width >= WORK_BUFFER_SIZE - EXTSIZ)
+	{
+	  /* We have to use a special buffer.  */
+	  size_t needed = ((size_t) width + EXTSIZ) * sizeof (CHAR_T);
+	  if (__libc_use_alloca (needed))
+	    workend = (CHAR_T *) alloca (needed) + width + EXTSIZ;
+	  else
+	    {
+	      workstart = (CHAR_T *) malloc (needed);
+	      if (workstart == NULL)
+		{
+		  done = -1;
+		  goto all_done;
+		}
+	      workend = workstart + width + EXTSIZ;
+	    }
+	}
       if (*f == L_('$'))
 	/* Oh, oh.  The argument comes from a positional parameter.  */
 	goto do_positional;
@@ -1600,6 +1613,34 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)
 	}
       else
 	prec = 0;
+      if (prec > width && prec > WORK_BUFFER_SIZE - EXTSIZ)
+	{
+	  /* Deallocate any previously allocated buffer because it is
+	     too small.  */
+	  if (__glibc_unlikely (workstart != NULL))
+	    free (workstart);
+	  workstart = NULL;
+	  if (__glibc_unlikely (prec >= INT_MAX / sizeof (CHAR_T) - EXTSIZ))
+	    {
+	      __set_errno (EOVERFLOW);
+	      done = -1;
+	      goto all_done;
+	    }
+	  size_t needed = ((size_t) prec + EXTSIZ) * sizeof (CHAR_T);
+
+	  if (__libc_use_alloca (needed))
+	    workend = (CHAR_T *) alloca (needed) + prec + EXTSIZ;
+	  else
+	    {
+	      workstart = (CHAR_T *) malloc (needed);
+	      if (workstart == NULL)
+		{
+		  done = -1;
+		  goto all_done;
+		}
+	      workend = workstart + prec + EXTSIZ;
+	    }
+	}
       JUMP (*f, step2_jumps);
 
       /* Process 'h' modifier.  There might another 'h' following.  */
@@ -1663,6 +1704,10 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)
       /* The format is correctly handled.  */
       ++nspecs_done;
 
+      if (__glibc_unlikely (workstart != NULL))
+	free (workstart);
+      workstart = NULL;
+
       /* Look for next format specifier.  */
 #ifdef COMPILE_WPRINTF
       f = __find_specwc ((end_of_spec = ++f));
@@ -1680,11 +1725,18 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)
 
   /* Hand off processing for positional parameters.  */
 do_positional:
+  if (__glibc_unlikely (workstart != NULL))
+    {
+      free (workstart);
+      workstart = NULL;
+    }
   done = printf_positional (s, format, readonly_format, ap, &ap_save,
 			    done, nspecs_done, lead_str_end, work_buffer,
 			    save_errno, grouping, thousands_sep, mode_flags);
 
  all_done:
+  if (__glibc_unlikely (workstart != NULL))
+    free (workstart);
   /* Unlock the stream.  */
   _IO_funlockfile (s);
   _IO_cleanup_region_end (0);
@@ -1728,6 +1780,8 @@ printf_positional (FILE *s, const CHAR_T *format, int readonly_format,
   /* Just a counter.  */
   size_t cnt;
 
+  CHAR_T *workstart = NULL;
+
   if (grouping == (const char *) -1)
     {
 #ifdef COMPILE_WPRINTF
@@ -1920,6 +1974,7 @@ printf_positional (FILE *s, const CHAR_T *format, int readonly_format,
       char pad = specs[nspecs_done].info.pad;
       CHAR_T spec = specs[nspecs_done].info.spec;
 
+      workstart = NULL;
       CHAR_T *workend = work_buffer + WORK_BUFFER_SIZE;
 
       /* Fill in last information.  */
@@ -1953,6 +2008,27 @@ printf_positional (FILE *s, const CHAR_T *format, int readonly_format,
 	  prec = specs[nspecs_done].info.prec;
 	}
 
+      /* Maybe the buffer is too small.  */
+      if (MAX (prec, width) + EXTSIZ > WORK_BUFFER_SIZE)
+	{
+	  if (__libc_use_alloca ((MAX (prec, width) + EXTSIZ)
+				 * sizeof (CHAR_T)))
+	    workend = ((CHAR_T *) alloca ((MAX (prec, width) + EXTSIZ)
+					  * sizeof (CHAR_T))
+		       + (MAX (prec, width) + EXTSIZ));
+	  else
+	    {
+	      workstart = (CHAR_T *) malloc ((MAX (prec, width) + EXTSIZ)
+					     * sizeof (CHAR_T));
+	      if (workstart == NULL)
+		{
+		  done = -1;
+		  goto all_done;
+		}
+	      workend = workstart + (MAX (prec, width) + EXTSIZ);
+	    }
+	}
+
       /* Process format specifiers.  */
       while (1)
 	{
@@ -2026,12 +2102,18 @@ printf_positional (FILE *s, const CHAR_T *format, int readonly_format,
 	  break;
 	}
 
+      if (__glibc_unlikely (workstart != NULL))
+	free (workstart);
+      workstart = NULL;
+
       /* Write the following constant string.  */
       outstring (specs[nspecs_done].end_of_fmt,
 		 specs[nspecs_done].next_fmt
 		 - specs[nspecs_done].end_of_fmt);
     }
  all_done:
+  if (__glibc_unlikely (workstart != NULL))
+    free (workstart);
   scratch_buffer_free (&argsbuf);
   scratch_buffer_free (&specsbuf);
   return done;
@@ -2154,8 +2236,7 @@ group_number (CHAR_T *front_ptr, CHAR_T *w, CHAR_T *rear_ptr,
 	    copy_rest:
 	      /* No further grouping to be done.  Copy the rest of the
 		 number.  */
-	      w -= s - front_ptr;
-	      memmove (w, front_ptr, (s - front_ptr) * sizeof (CHAR_T));
+	      memmove (w, s, (front_ptr -s) * sizeof (CHAR_T));
 	      break;
 	    }
 	  else if (*grouping != '\0')
diff --git a/string/test-strnlen.c b/string/test-strnlen.c
index ca34352b0d..a1a6746cc9 100644
--- a/string/test-strnlen.c
+++ b/string/test-strnlen.c
@@ -75,7 +75,7 @@ do_test (size_t align, size_t len, size_t maxlen, int max_char)
 {
   size_t i;
 
-  align &= (getpagesize () / sizeof (CHAR) - 1);
+  align &= 63;
   if ((align + len) * sizeof (CHAR) >= page_size)
     return;
 
@@ -92,50 +92,32 @@ do_test (size_t align, size_t len, size_t maxlen, int max_char)
 static void
 do_overflow_tests (void)
 {
-  size_t i, j, al_idx, repeats, len;
+  size_t i, j, len;
   const size_t one = 1;
   uintptr_t buf_addr = (uintptr_t) buf1;
-  const size_t alignments[] = { 0, 1, 7, 9, 31, 33, 63, 65, 95, 97, 127, 129 };
 
-  for (al_idx = 0; al_idx < sizeof (alignments) / sizeof (alignments[0]);
-       al_idx++)
+  for (i = 0; i < 750; ++i)
     {
-      for (repeats = 0; repeats < 2; ++repeats)
-	{
-	  size_t align = repeats ? (getpagesize () - alignments[al_idx])
-				 : alignments[al_idx];
-	  align /= sizeof (CHAR);
-	  for (i = 0; i < 750; ++i)
-	    {
-	      do_test (align, i, SIZE_MAX, BIG_CHAR);
-
-	      do_test (align, i, SIZE_MAX - i, BIG_CHAR);
-	      do_test (align, i, i - buf_addr, BIG_CHAR);
-	      do_test (align, i, -buf_addr - i, BIG_CHAR);
-	      do_test (align, i, SIZE_MAX - buf_addr - i, BIG_CHAR);
-	      do_test (align, i, SIZE_MAX - buf_addr + i, BIG_CHAR);
-
-	      len = 0;
-	      for (j = 8 * sizeof (size_t) - 1; j; --j)
-		{
-		  len |= one << j;
-		  do_test (align, i, len, BIG_CHAR);
-		  do_test (align, i, len - i, BIG_CHAR);
-		  do_test (align, i, len + i, BIG_CHAR);
-		  do_test (align, i, len - buf_addr - i, BIG_CHAR);
-		  do_test (align, i, len - buf_addr + i, BIG_CHAR);
-
-		  do_test (align, i, ~len - i, BIG_CHAR);
-		  do_test (align, i, ~len + i, BIG_CHAR);
-		  do_test (align, i, ~len - buf_addr - i, BIG_CHAR);
-		  do_test (align, i, ~len - buf_addr + i, BIG_CHAR);
-
-		  do_test (align, i, -buf_addr, BIG_CHAR);
-		  do_test (align, i, j - buf_addr, BIG_CHAR);
-		  do_test (align, i, -buf_addr - j, BIG_CHAR);
-		}
-	    }
-	}
+      do_test (0, i, SIZE_MAX - i, BIG_CHAR);
+      do_test (0, i, i - buf_addr, BIG_CHAR);
+      do_test (0, i, -buf_addr - i, BIG_CHAR);
+      do_test (0, i, SIZE_MAX - buf_addr - i, BIG_CHAR);
+      do_test (0, i, SIZE_MAX - buf_addr + i, BIG_CHAR);
+
+      len = 0;
+      for (j = 8 * sizeof(size_t) - 1; j ; --j)
+        {
+          len |= one << j;
+          do_test (0, i, len - i, BIG_CHAR);
+          do_test (0, i, len + i, BIG_CHAR);
+          do_test (0, i, len - buf_addr - i, BIG_CHAR);
+          do_test (0, i, len - buf_addr + i, BIG_CHAR);
+
+          do_test (0, i, ~len - i, BIG_CHAR);
+          do_test (0, i, ~len + i, BIG_CHAR);
+          do_test (0, i, ~len - buf_addr - i, BIG_CHAR);
+          do_test (0, i, ~len - buf_addr + i, BIG_CHAR);
+        }
     }
 }
 
diff --git a/support/Makefile b/support/Makefile
index 05e8c292b7..3325feb790 100644
--- a/support/Makefile
+++ b/support/Makefile
@@ -83,10 +83,8 @@ libsupport-routines = \
   xasprintf \
   xbind \
   xcalloc \
-  xchdir \
   xchroot \
   xclock_gettime \
-  xclone \
   xclose \
   xconnect \
   xcopy_file_range \
diff --git a/support/support.h b/support/support.h
index 0536474c41..77d68c2aba 100644
--- a/support/support.h
+++ b/support/support.h
@@ -23,7 +23,6 @@
 #ifndef SUPPORT_H
 #define SUPPORT_H
 
-#include <stdbool.h>
 #include <stddef.h>
 #include <sys/cdefs.h>
 /* For mode_t.  */
diff --git a/support/temp_file.c b/support/temp_file.c
index e41128c2d4..277c5e0cf1 100644
--- a/support/temp_file.c
+++ b/support/temp_file.c
@@ -1,6 +1,5 @@
 /* Temporary file handling for tests.
-   Copyright (C) 1998-2022 Free Software Foundation, Inc.
-   Copyright The GNU Tools Authors.
+   Copyright (C) 1998-2020 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,17 +20,15 @@
    some 32-bit platforms. */
 #define _FILE_OFFSET_BITS 64
 
-#include <support/check.h>
 #include <support/temp_file.h>
 #include <support/temp_file-internal.h>
 #include <support/support.h>
 
-#include <errno.h>
 #include <paths.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <xunistd.h>
+#include <unistd.h>
 
 /* List of temporary files.  */
 static struct temp_name_list
@@ -39,20 +36,14 @@ static struct temp_name_list
   struct temp_name_list *next;
   char *name;
   pid_t owner;
-  bool toolong;
 } *temp_name_list;
 
 /* Location of the temporary files.  Set by the test skeleton via
    support_set_test_dir.  The string is not be freed.  */
 static const char *test_dir = _PATH_TMP;
 
-/* Name of subdirectories in a too long temporary directory tree.  */
-static char toolong_subdir[NAME_MAX + 1];
-static bool toolong_initialized;
-static size_t toolong_path_max;
-
-static void
-add_temp_file_internal (const char *name, bool toolong)
+void
+add_temp_file (const char *name)
 {
   struct temp_name_list *newp
     = (struct temp_name_list *) xcalloc (sizeof (*newp), 1);
@@ -62,26 +53,21 @@ add_temp_file_internal (const char *name, bool toolong)
       newp->name = newname;
       newp->next = temp_name_list;
       newp->owner = getpid ();
-      newp->toolong = toolong;
       temp_name_list = newp;
     }
   else
     free (newp);
 }
 
-void
-add_temp_file (const char *name)
-{
-  add_temp_file_internal (name, false);
-}
-
 int
-create_temp_file_in_dir (const char *base, const char *dir, char **filename)
+create_temp_file (const char *base, char **filename)
 {
   char *fname;
   int fd;
 
-  fname = xasprintf ("%s/%sXXXXXX", dir, base);
+  fname = (char *) xmalloc (strlen (test_dir) + 1 + strlen (base)
+			    + sizeof ("XXXXXX"));
+  strcpy (stpcpy (stpcpy (stpcpy (fname, test_dir), "/"), base), "XXXXXX");
 
   fd = mkstemp (fname);
   if (fd == -1)
@@ -100,14 +86,8 @@ create_temp_file_in_dir (const char *base, const char *dir, char **filename)
   return fd;
 }
 
-int
-create_temp_file (const char *base, char **filename)
-{
-  return create_temp_file_in_dir (base, test_dir, filename);
-}
-
-static char *
-create_temp_directory_internal (const char *base, bool toolong)
+char *
+support_create_temp_directory (const char *base)
 {
   char *path = xasprintf ("%s/%sXXXXXX", test_dir, base);
   if (mkdtemp (path) == NULL)
@@ -115,132 +95,16 @@ create_temp_directory_internal (const char *base, bool toolong)
       printf ("error: mkdtemp (\"%s\"): %m", path);
       exit (1);
     }
-  add_temp_file_internal (path, toolong);
+  add_temp_file (path);
   return path;
 }
 
-char *
-support_create_temp_directory (const char *base)
-{
-  return create_temp_directory_internal (base, false);
-}
-
-static void
-ensure_toolong_initialized (void)
-{
-  if (!toolong_initialized)
-    FAIL_EXIT1 ("uninitialized toolong directory tree\n");
-}
-
-static void
-initialize_toolong (const char *base)
-{
-  long name_max = pathconf (base, _PC_NAME_MAX);
-  name_max = (name_max < 0 ? 64
-	      : (name_max < sizeof (toolong_subdir) ? name_max
-		 : sizeof (toolong_subdir) - 1));
-
-  long path_max = pathconf (base, _PC_PATH_MAX);
-  path_max = (path_max < 0 ? 1024
-	      : path_max <= PTRDIFF_MAX ? path_max : PTRDIFF_MAX);
-
-  /* Sanity check to ensure that the test does not create temporary directories
-     in different filesystems because this API doesn't support it.  */
-  if (toolong_initialized)
-    {
-      if (name_max != strlen (toolong_subdir))
-	FAIL_UNSUPPORTED ("name_max: Temporary directories in different"
-			  " filesystems not supported yet\n");
-      if (path_max != toolong_path_max)
-	FAIL_UNSUPPORTED ("path_max: Temporary directories in different"
-			  " filesystems not supported yet\n");
-      return;
-    }
-
-  toolong_path_max = path_max;
-
-  size_t len = name_max;
-  memset (toolong_subdir, 'X', len);
-  toolong_initialized = true;
-}
-
-char *
-support_create_and_chdir_toolong_temp_directory (const char *basename)
-{
-  char *base = create_temp_directory_internal (basename, true);
-  xchdir (base);
-
-  initialize_toolong (base);
-
-  size_t sz = strlen (toolong_subdir);
-
-  /* Create directories and descend into them so that the final path is larger
-     than PATH_MAX.  */
-  for (size_t i = 0; i <= toolong_path_max / sz; i++)
-    {
-      int ret = mkdir (toolong_subdir, S_IRWXU);
-      if (ret != 0 && errno == ENAMETOOLONG)
-	FAIL_UNSUPPORTED ("Filesystem does not support creating too long "
-			  "directory trees\n");
-      else if (ret != 0)
-	FAIL_EXIT1 ("Failed to create directory tree: %m\n");
-      xchdir (toolong_subdir);
-    }
-  return base;
-}
-
-void
-support_chdir_toolong_temp_directory (const char *base)
-{
-  ensure_toolong_initialized ();
-
-  xchdir (base);
-
-  size_t sz = strlen (toolong_subdir);
-  for (size_t i = 0; i <= toolong_path_max / sz; i++)
-    xchdir (toolong_subdir);
-}
-
 /* Helper functions called by the test skeleton follow.  */
 
-static void
-remove_toolong_subdirs (const char *base)
+void
+support_set_test_dir (const char *path)
 {
-  ensure_toolong_initialized ();
-
-  if (chdir (base) != 0)
-    {
-      printf ("warning: toolong cleanup base failed: chdir (\"%s\"): %m\n",
-	      base);
-      return;
-    }
-
-  /* Descend.  */
-  int levels = 0;
-  size_t sz = strlen (toolong_subdir);
-  for (levels = 0; levels <= toolong_path_max / sz; levels++)
-    if (chdir (toolong_subdir) != 0)
-      {
-	printf ("warning: toolong cleanup failed: chdir (\"%s\"): %m\n",
-		toolong_subdir);
-	break;
-      }
-
-  /* Ascend and remove.  */
-  while (--levels >= 0)
-    {
-      if (chdir ("..") != 0)
-	{
-	  printf ("warning: toolong cleanup failed: chdir (\"..\"): %m\n");
-	  return;
-	}
-      if (remove (toolong_subdir) != 0)
-	{
-	  printf ("warning: could not remove subdirectory: %s: %m\n",
-		  toolong_subdir);
-	  return;
-	}
-    }
+  test_dir = path;
 }
 
 void
@@ -255,9 +119,6 @@ support_delete_temp_files (void)
 	 around, to prevent PID reuse.)  */
       if (temp_name_list->owner == pid)
 	{
-	  if (temp_name_list->toolong)
-	    remove_toolong_subdirs (temp_name_list->name);
-
 	  if (remove (temp_name_list->name) != 0)
 	    printf ("warning: could not remove temporary file: %s: %m\n",
 		    temp_name_list->name);
@@ -282,9 +143,3 @@ support_print_temp_files (FILE *f)
       fprintf (f, ")\n");
     }
 }
-
-void
-support_set_test_dir (const char *path)
-{
-  test_dir = path;
-}
diff --git a/support/temp_file.h b/support/temp_file.h
index 2598f82136..8b6303a6e4 100644
--- a/support/temp_file.h
+++ b/support/temp_file.h
@@ -32,27 +32,11 @@ void add_temp_file (const char *name);
    *FILENAME.  */
 int create_temp_file (const char *base, char **filename);
 
-/* Create a temporary file in directory DIR.  Return the opened file
-   descriptor on success, or -1 on failure.  Write the file name to
-   *FILENAME if FILENAME is not NULL.  In this case, the caller is
-   expected to free *FILENAME.  */
-int create_temp_file_in_dir (const char *base, const char *dir,
-			     char **filename);
-
 /* Create a temporary directory and schedule it for deletion.  BASE is
    used as a prefix for the unique directory name, which the function
    returns.  The caller should free this string.  */
 char *support_create_temp_directory (const char *base);
 
-/* Create a temporary directory tree that is longer than PATH_MAX and schedule
-   it for deletion.  BASENAME is used as a prefix for the unique directory
-   name, which the function returns.  The caller should free this string.  */
-char *support_create_and_chdir_toolong_temp_directory (const char *basename);
-
-/* Change into the innermost directory of the directory tree BASE, which was
-   created using support_create_and_chdir_toolong_temp_directory.  */
-void support_chdir_toolong_temp_directory (const char *base);
-
 __END_DECLS
 
 #endif /* SUPPORT_TEMP_FILE_H */
diff --git a/support/xclone.c b/support/xclone.c
deleted file mode 100644
index 243eee8b23..0000000000
--- a/support/xclone.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/* Auxiliary functions to issue the clone syscall.
-   Copyright (C) 2021 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#ifdef __linux__
-# include <support/check.h>
-# include <stackinfo.h>  /* For _STACK_GROWS_{UP,DOWN}.  */
-# include <xsched.h>
-
-pid_t
-xclone (int (*fn) (void *arg), void *arg, void *stack, size_t stack_size,
-	int flags)
-{
-  pid_t r = -1;
-
-# ifdef __ia64__
-  extern int __clone2 (int (*fn) (void *arg), void *stack, size_t stack_size,
-		       int flags, void *arg, ...);
-  r = __clone2 (fn, stack, stack_size, flags, arg, /* ptid */ NULL,
-		/* tls */ NULL, /* ctid  */ NULL);
-# else
-#  if _STACK_GROWS_DOWN
-  r = clone (fn, stack + stack_size, flags, arg, /* ptid */ NULL,
-	     /* tls */ NULL, /* ctid */  NULL);
-#  elif _STACK_GROWS_UP
-  r = clone (fn, stack, flags, arg, /* ptid */ NULL, /* tls */ NULL, NULL);
-#  endif
-# endif
-
-  if (r < 0)
-    FAIL_EXIT1 ("clone: %m");
-
-  return r;
-}
-#endif
diff --git a/support/xunistd.h b/support/xunistd.h
index 43799d92c5..96f498f2e5 100644
--- a/support/xunistd.h
+++ b/support/xunistd.h
@@ -44,7 +44,6 @@ long xsysconf (int name);
 long long xlseek (int fd, long long offset, int whence);
 void xftruncate (int fd, long long length);
 void xsymlink (const char *target, const char *linkpath);
-void xchdir (const char *path);
 
 /* Equivalent of "mkdir -p".  */
 void xmkdirp (const char *, mode_t);
diff --git a/sysdeps/aarch64/dl-machine.h b/sysdeps/aarch64/dl-machine.h
index 8ffa0d1c51..bde4f28107 100644
--- a/sysdeps/aarch64/dl-machine.h
+++ b/sysdeps/aarch64/dl-machine.h
@@ -126,6 +126,8 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 .type _dl_start_user, %function						\n\
 _start:									\n\
 	mov	" PTR "0, " PTR_SP "					\n\
+	// Preserve the frame pointer for reloading			\n\
+	mov	x28, x29						\n\
 	bl	_dl_start						\n\
 	// returns user entry point in x0				\n\
 	mov	x21, x0							\n\
@@ -177,6 +179,8 @@ _dl_start_user:								\n\
 	// load the finalizer function					\n\
 	adrp	x0, _dl_fini						\n\
 	add	" PTR "0, " PTR "0, #:lo12:_dl_fini			\n\
+	// Restore the frame pointer					\n\
+	mov	x29, x28						\n\
 	// jump to the user_s entry point				\n\
 	br      x21							\n\
 ");
diff --git a/sysdeps/aarch64/nptl/pthreaddef.h b/sysdeps/aarch64/nptl/pthreaddef.h
index 892b869fc2..8fb905dd0a 100644
--- a/sysdeps/aarch64/nptl/pthreaddef.h
+++ b/sysdeps/aarch64/nptl/pthreaddef.h
@@ -25,8 +25,8 @@
 /* Minimal stack size after allocating thread descriptor and guard size.  */
 #define MINIMAL_REST_STACK 2048
 
-/* Alignment requirement for TCB.  */
-#define TCB_ALIGNMENT 16
+/* Alignment requirement for TCB.  Bumped up to 64 for x86-64 compatibility.  */
+#define TCB_ALIGNMENT 64
 
 /* Location of current stack frame.  */
 #define CURRENT_STACK_FRAME	__builtin_frame_address (0)
diff --git a/sysdeps/aarch64/nptl/tls.h b/sysdeps/aarch64/nptl/tls.h
index e5627f777e..7b4a2c4813 100644
--- a/sysdeps/aarch64/nptl/tls.h
+++ b/sysdeps/aarch64/nptl/tls.h
@@ -64,6 +64,9 @@ typedef struct
 /* Alignment requirements for the TCB.  */
 # define TLS_TCB_ALIGN		__alignof__ (struct pthread)
 
+/* Popcorn Linux Padding.  */
+# define TLS_TCB_PCN_PAD	0x40
+
 /* Install the dtv pointer.  The pointer passed is to the element with
    index -1 which contain the length.  */
 # define INSTALL_DTV(tcbp, dtvp) \
@@ -80,6 +83,7 @@ typedef struct
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
    operation can cause a failure 'errno' must not be touched.  */
+/* Might need to set tcbp->private = tcbp for x86-64.  */
 # define TLS_INIT_TP(tcbp) \
   ({ __asm __volatile ("msr tpidr_el0, %0" : : "r" (tcbp)); NULL; })
 
@@ -94,6 +98,9 @@ typedef struct
 # define THREAD_SELF \
  ((struct pthread *)__builtin_thread_pointer () - 1)
 
+# define GET_TP \
+  ({ void *tp; __asm __volatile ("mrs %0, tpidr_el0" : "=r" (tp)); tp;})
+
 /* Magic for libthread_db to know how to do THREAD_SELF.  */
 # define DB_THREAD_SELF \
   CONST_THREAD_AREA (64, sizeof (struct pthread))
diff --git a/sysdeps/nptl/allocrtsig.c b/sysdeps/nptl/allocrtsig.c
index 116036e147..86c2f0e85b 100644
--- a/sysdeps/nptl/allocrtsig.c
+++ b/sysdeps/nptl/allocrtsig.c
@@ -26,6 +26,6 @@
 /* This tells the generic code (included below) how many signal
    numbers need to be reserved for libpthread's private uses
    (SIGCANCEL and SIGSETXID).  */
-#define RESERVED_SIGRT 2
+#define RESERVED_SIGRT 3
 
 #include <signal/allocrtsig.c>
diff --git a/sysdeps/nptl/fork.c b/sysdeps/nptl/fork.c
index f5cf88d68c..f5d65ef803 100644
--- a/sysdeps/nptl/fork.c
+++ b/sysdeps/nptl/fork.c
@@ -32,6 +32,8 @@
 #include <arch-fork.h>
 #include <futex-internal.h>
 #include <malloc/malloc-internal.h>
+#include <remote_io/remote_io.h>
+#include <elf/popcorn.h>
 
 static void
 fresetlockfiles (void)
@@ -48,6 +50,7 @@ pid_t
 __libc_fork (void)
 {
   pid_t pid;
+  int rio_server_port = -1;
 
   /* Determine if we are running multiple threads.  We skip some fork
      handlers in the single-thread case, to make fork safer to use in
@@ -73,6 +76,9 @@ __libc_fork (void)
       call_function_static_weak (__malloc_fork_lock_parent);
     }
 
+  if (pcn_data->pcn_remote_io_active)
+    rio_server_port = pcn_server_fork ();
+
   pid = arch_fork (&THREAD_SELF->tid);
 
   if (pid == 0)
@@ -83,6 +89,9 @@ __libc_fork (void)
       if (__fork_generation_pointer != NULL)
 	*__fork_generation_pointer += __PTHREAD_ONCE_FORK_GEN_INCR;
 
+      if (pcn_data->pcn_remote_io_active)
+        pcn_server_attach (rio_server_port);
+
 #ifdef __NR_set_robust_list
       /* Initialize the robust mutex list setting in the kernel which has
 	 been reset during the fork.  We do not check for errors because if
diff --git a/sysdeps/posix/getcwd.c b/sysdeps/posix/getcwd.c
index 839d78d7b7..f00b337a13 100644
--- a/sysdeps/posix/getcwd.c
+++ b/sysdeps/posix/getcwd.c
@@ -241,14 +241,6 @@ __getcwd (char *buf, size_t size)
   char *path;
 #ifndef NO_ALLOCATION
   size_t allocated = size;
-
-  /* A size of 1 byte is never useful.  */
-  if (allocated == 1)
-    {
-      __set_errno (ERANGE);
-      return NULL;
-    }
-
   if (size == 0)
     {
       if (buf != NULL)
diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
index 0a0da00151..1def194516 100644
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -59,10 +59,11 @@ include $(firstword $(wildcard $(sysdirs:=/sysctl.mk)))
 sysdep_routines += adjtimex clone umount umount2 readahead \
 		   setfsuid setfsgid epoll_pwait signalfd \
 		   eventfd eventfd_read eventfd_write prlimit \
-		   personality epoll_wait tee vmsplice splice \
+		   personality tee vmsplice splice \
 		   open_by_handle_at mlock2 pkey_mprotect pkey_set pkey_get \
 		   prctl \
-		   process_vm_readv process_vm_writev
+		   process_vm_readv process_vm_writev \
+		   epoll_create epoll_create1 epoll_ctl epoll_wait
 
 CFLAGS-gethostid.c = -fexceptions
 CFLAGS-tee.c = -fexceptions -fasynchronous-unwind-tables
@@ -275,7 +276,7 @@ sysdep_routines += xstatconv internal_statvfs internal_statvfs64 \
 
 sysdep_headers += bits/fcntl-linux.h
 
-tests += tst-fallocate tst-fallocate64 tst-getcwd-smallbuff
+tests += tst-fallocate tst-fallocate64
 endif
 
 ifeq ($(subdir),elf)
diff --git a/sysdeps/unix/sysv/linux/Versions b/sysdeps/unix/sysv/linux/Versions
index d385085c61..2fc6f45b0f 100644
--- a/sysdeps/unix/sysv/linux/Versions
+++ b/sysdeps/unix/sysv/linux/Versions
@@ -107,7 +107,7 @@ libc {
   }
   GLIBC_2.3.2 {
     # New kernel interfaces.
-    epoll_create; epoll_ctl; epoll_wait;
+    epoll_create; epoll_create1; epoll_ctl; epoll_wait;
   }
   GLIBC_2.3.3 {
     gnu_dev_major; gnu_dev_minor; gnu_dev_makedev;
@@ -177,6 +177,9 @@ libc {
   GLIBC_2.30 {
     getdents64; gettid; tgkill;
   }
+  GLIBC_2.31 {
+    epoll_create; epoll_ctl; epoll_wait;
+  }
   GLIBC_PRIVATE {
     # functions used in other libraries
     __syscall_rt_sigqueueinfo;
@@ -187,5 +190,8 @@ libc {
     __sigtimedwait;
     # functions used by nscd
     __netlink_assert_response;
+    __do_fxstatat;
+    __do_epoll_wait;
+    __do_epoll_pwait;
   }
 }
diff --git a/sysdeps/unix/sysv/linux/__libc_start_main_popcorn.c b/sysdeps/unix/sysv/linux/__libc_start_main_popcorn.c
new file mode 100644
index 0000000000..2b12fa7010
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/__libc_start_main_popcorn.c
@@ -0,0 +1,20 @@
+/* Build instructions:
+
+clang -O0 -fno-common -popcorn-libc -mllvm -optimize-regalloc \
+     -target aarch64-linux-gnu -S __libc_start_main_popcorn.c -fno-addrsig
+
+clang -O0 -fno-common -popcorn-libc -mllvm -optimize-regalloc \
+     -target x86_64-linux-gnu -S __libc_start_main_popcorn.c -fno-addrsig
+*/
+
+/* Wrapper function of __libc_start_main.  */
+
+#include <stdlib.h>
+
+int __libc_start_main_popcorn (int (*main) (int, char **, char **),
+			       int argc, char **argv, char **environ)
+{
+  exit (main (argc, argv, environ));
+
+  return 0;
+}
diff --git a/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h b/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h
index 9f4606a01f..c27e2cf381 100644
--- a/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h
+++ b/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h
@@ -21,9 +21,9 @@
 # error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
 #endif
 
-#define __O_DIRECTORY	 040000
-#define __O_NOFOLLOW	0100000
-#define __O_DIRECT	0200000
+#define A64__O_DIRECTORY	 040000
+#define A64__O_NOFOLLOW	0100000
+#define A64__O_DIRECT	0200000
 
 #ifdef __ILP32__
 # define __O_LARGEFILE	0400000
diff --git a/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c b/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c
index 0e3c7f76df..37c649aa27 100644
--- a/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c
+++ b/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c
@@ -16,5 +16,5 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define USE_IFUNC_GETTIMEOFDAY
+/* #define USE_IFUNC_GETTIMEOFDAY */
 #include <sysdeps/unix/sysv/linux/gettimeofday.c>
diff --git a/sysdeps/unix/sysv/linux/aarch64/kernel-features.h b/sysdeps/unix/sysv/linux/aarch64/kernel-features.h
index 5f301bed6c..61c8930d06 100644
--- a/sysdeps/unix/sysv/linux/aarch64/kernel-features.h
+++ b/sysdeps/unix/sysv/linux/aarch64/kernel-features.h
@@ -21,3 +21,13 @@
 
 #undef __ASSUME_CLONE_DEFAULT
 #define __ASSUME_CLONE_BACKWARDS 1
+
+# define __ASSUME_SOCKET_SYSCALL             1
+# define __ASSUME_SOCKETPAIR_SYSCALL         1
+# define __ASSUME_BIND_SYSCALL               1
+# define __ASSUME_LISTEN_SYSCALL             1
+# define __ASSUME_GETSOCKOPT_SYSCALL         1
+# define __ASSUME_SETSOCKOPT_SYSCALL         1
+# define __ASSUME_GETSOCKNAME_SYSCALL        1
+# define __ASSUME_GETPEERNAME_SYSCALL        1
+# define __ASSUME_SHUTDOWN_SYSCALL           1
diff --git a/sysdeps/unix/sysv/linux/accept.c b/sysdeps/unix/sysv/linux/accept.c
index f6021a75e7..aef98eadcf 100644
--- a/sysdeps/unix/sysv/linux/accept.c
+++ b/sysdeps/unix/sysv/linux/accept.c
@@ -18,10 +18,14 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <remote_io/remote_io.h>
 
 int
 __libc_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_accept (fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_ACCEPT_SYSCALL
   return SYSCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
 #elif defined __ASSUME_ACCEPT4_SYSCALL
@@ -29,6 +33,7 @@ __libc_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 #else
   return SOCKETCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
 #endif
+#endif
 }
 weak_alias (__libc_accept, accept)
 libc_hidden_def (accept)
diff --git a/sysdeps/unix/sysv/linux/access.c b/sysdeps/unix/sysv/linux/access.c
index d5e8949013..ca7673ff0f 100644
--- a/sysdeps/unix/sysv/linux/access.c
+++ b/sysdeps/unix/sysv/linux/access.c
@@ -19,15 +19,20 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 int
 __access (const char *file, int type)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_access (file, type);
+#else
 #ifdef __NR_access
   return INLINE_SYSCALL_CALL (access, file, type);
 #else
   return INLINE_SYSCALL_CALL (faccessat, AT_FDCWD, file, type);
 #endif
+#endif
 }
 libc_hidden_def (__access)
 weak_alias (__access, access)
diff --git a/sysdeps/unix/sysv/linux/bind.c b/sysdeps/unix/sysv/linux/bind.c
index da2ed19a33..f5e37d900a 100644
--- a/sysdeps/unix/sysv/linux/bind.c
+++ b/sysdeps/unix/sysv/linux/bind.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_bind (fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_BIND_SYSCALL
   return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, len);
 #else
   return SOCKETCALL (bind, fd, addr.__sockaddr__, len, 0, 0, 0);
 #endif
+#endif
 }
 weak_alias (__bind, bind)
diff --git a/sysdeps/unix/sysv/linux/chdir.c b/sysdeps/unix/sysv/linux/chdir.c
new file mode 100644
index 0000000000..6763504384
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/chdir.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include <remote_io/remote_io.h>
+
+int
+__chdir (const char *path)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_chdir (path);
+#else
+  return INLINE_SYSCALL (chdir, 1, path);
+#endif
+}
+libc_hidden_def (__chdir)
+weak_alias (__chdir, chdir)
diff --git a/sysdeps/unix/sysv/linux/chmod.c b/sysdeps/unix/sysv/linux/chmod.c
new file mode 100644
index 0000000000..6a92fb0c7b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/chmod.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <remote_io/remote_io.h>
+
+/* Change the protections of FILE to MODE.  */
+int
+__chmod (const char *file, mode_t mode)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_chmod (file, mode);
+#else
+  return INLINE_SYSCALL (fchmodat, 3, AT_FDCWD, file, mode);
+#endif
+}
+
+libc_hidden_def (__chmod)
+weak_alias (__chmod, chmod)
diff --git a/sysdeps/unix/sysv/linux/close.c b/sysdeps/unix/sysv/linux/close.c
index 602ab558e6..ca7448a050 100644
--- a/sysdeps/unix/sysv/linux/close.c
+++ b/sysdeps/unix/sysv/linux/close.c
@@ -19,12 +19,17 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 /* Close the file descriptor FD.  */
 int
 __close (int fd)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_close (fd);
+#else
   return SYSCALL_CANCEL (close, fd);
+#endif
 }
 libc_hidden_def (__close)
 strong_alias (__close, __libc_close)
diff --git a/sysdeps/unix/sysv/linux/close_nocancel.c b/sysdeps/unix/sysv/linux/close_nocancel.c
index 23ebcd0df5..249fc243b7 100644
--- a/sysdeps/unix/sysv/linux/close_nocancel.c
+++ b/sysdeps/unix/sysv/linux/close_nocancel.c
@@ -19,10 +19,15 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 int
 __close_nocancel (int fd)
 {
+#if IS_IN(libc) && defined SHARED
+  return pcn_close (fd);
+#else
   return INLINE_SYSCALL_CALL (close, fd);
+#endif
 }
 libc_hidden_def (__close_nocancel)
diff --git a/sysdeps/unix/sysv/linux/connect.c b/sysdeps/unix/sysv/linux/connect.c
index 0e970b41ed..ffc4eaaa3f 100644
--- a/sysdeps/unix/sysv/linux/connect.c
+++ b/sysdeps/unix/sysv/linux/connect.c
@@ -18,15 +18,20 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <remote_io/remote_io.h>
 
 int
 __libc_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_connect (fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_CONNECT_SYSCALL
   return SYSCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
 #else
   return SOCKETCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
 #endif
+#endif
 }
 weak_alias (__libc_connect, connect)
 weak_alias (__libc_connect, __connect)
diff --git a/sysdeps/unix/sysv/linux/dl-sysdep.h b/sysdeps/unix/sysv/linux/dl-sysdep.h
index 8ed45503e7..de8182719e 100644
--- a/sysdeps/unix/sysv/linux/dl-sysdep.h
+++ b/sysdeps/unix/sysv/linux/dl-sysdep.h
@@ -23,7 +23,7 @@
    machines, we should look at it for unwind information even if
    we aren't making direct use of it.  So enable this across the board.  */
 
-#define NEED_DL_SYSINFO_DSO	1
+#define NEED_DL_SYSINFO_DSO	0
 
 
 #ifndef __ASSEMBLER__
diff --git a/sysdeps/unix/sysv/linux/dup.c b/sysdeps/unix/sysv/linux/dup.c
new file mode 100644
index 0000000000..daabbe14a7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/dup.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include <remote_io/remote_io.h>
+
+int
+__dup (int fd)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_dup (fd);
+#else
+  return INLINE_SYSCALL (dup, 1, fd);
+#endif
+}
+libc_hidden_def (__dup)
+weak_alias (__dup, dup)
diff --git a/sysdeps/unix/sysv/linux/dup2.c b/sysdeps/unix/sysv/linux/dup2.c
new file mode 100644
index 0000000000..a169da9d66
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/dup2.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include <remote_io/remote_io.h>
+
+int
+__dup2 (int oldfd, int newfd)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_dup2 (oldfd, newfd);
+#else
+  return INLINE_SYSCALL (dup3, 2, oldfd, newfd);
+#endif
+}
+libc_hidden_def (__dup2)
+weak_alias (__dup2, dup2)
diff --git a/sysdeps/unix/sysv/linux/dup3.c b/sysdeps/unix/sysv/linux/dup3.c
new file mode 100644
index 0000000000..e83942fccc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/dup3.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include <remote_io/remote_io.h>
+
+int
+__dup3 (int oldfd, int newfd, int flags)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_dup3 (oldfd, newfd, flags);
+#else
+  return INLINE_SYSCALL (dup3, 3, oldfd, newfd, flags);
+#endif
+}
+libc_hidden_def (__dup3)
+weak_alias (__dup3, dup3)
diff --git a/sysdeps/unix/sysv/linux/generic/epoll_create.c b/sysdeps/unix/sysv/linux/epoll_create.c
similarity index 88%
rename from sysdeps/unix/sysv/linux/generic/epoll_create.c
rename to sysdeps/unix/sysv/linux/epoll_create.c
index e3eac4a7ac..10e027b76e 100644
--- a/sysdeps/unix/sysv/linux/generic/epoll_create.c
+++ b/sysdeps/unix/sysv/linux/epoll_create.c
@@ -21,8 +21,8 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/epoll.h>
-
-libc_hidden_proto (epoll_create)
+#include <remote_io/remote_io.h>
+#include <remote_io/local_io.h>
 
 int
 epoll_create (int size)
@@ -33,6 +33,10 @@ epoll_create (int size)
       return -1;
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_create (size);
+#else
   return INLINE_SYSCALL (epoll_create1, 1, 0);
+#endif
 }
 libc_hidden_def (epoll_create)
diff --git a/sysdeps/unix/sysv/linux/epoll_create1.c b/sysdeps/unix/sysv/linux/epoll_create1.c
new file mode 100644
index 0000000000..0751c894a5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/epoll_create1.c
@@ -0,0 +1,42 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/epoll.h>
+#include <remote_io/remote_io.h>
+#include <remote_io/local_io.h>
+
+int
+epoll_create1 (int flags)
+{
+  if (flags < 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_create (flags);
+#else
+  return INLINE_SYSCALL (epoll_create1, 1, flags);
+#endif
+}
+libc_hidden_def (epoll_create1)
diff --git a/sysdeps/unix/sysv/linux/epoll_ctl.c b/sysdeps/unix/sysv/linux/epoll_ctl.c
new file mode 100644
index 0000000000..6fd39d6bc9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/epoll_ctl.c
@@ -0,0 +1,44 @@
+/* Linux epoll_ctl implementation.
+   Copyright (C) 2017-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/epoll.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <remote_io/remote_io.h>
+
+/* Match PCN_EPOLL_NEW on x86-64.  */
+#define PCN_EPOLL_DEFAULT 1
+
+int
+__do_epoll_ctl (int ver, int epfd, int op, int fd, struct epoll_event *event)
+{
+  return INLINE_SYSCALL (epoll_ctl, 4, epfd, op, fd, event);
+}
+
+int
+epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_ctl (PCN_EPOLL_DEFAULT, epfd, op, fd, event);
+#else
+  return __do_epoll_ctl (PCN_EPOLL_DEFAULT, epfd, op, fd, event);
+#endif
+}
+libc_hidden_def (epoll_ctl)
\ No newline at end of file
diff --git a/sysdeps/unix/sysv/linux/epoll_pwait.c b/sysdeps/unix/sysv/linux/epoll_pwait.c
index fcd2a47d85..bd4ee799e0 100644
--- a/sysdeps/unix/sysv/linux/epoll_pwait.c
+++ b/sysdeps/unix/sysv/linux/epoll_pwait.c
@@ -23,6 +23,19 @@
 #include <sysdep-cancel.h>
 #include <sys/syscall.h>
 
+#include <remote_io.h>
+
+/* Match PCN_EPOLL_NEW on x86-64.  */
+#define PCN_EPOLL_DEFAULT 1
+
+int
+__do_epoll_pwait (int ver, int epfd, struct epoll_event *events,
+		  int maxevents, int timeout, const sigset_t *set)
+{
+  return SYSCALL_CANCEL (epoll_pwait, epfd, events, maxevents,
+			 timeout, set, _NSIG / 8);
+}
+
 #ifdef __NR_epoll_pwait
 
 /* Wait for events on an epoll instance "epfd". Returns the number of
@@ -39,8 +52,13 @@ int epoll_pwait (int epfd, struct epoll_event *events,
 		 int maxevents, int timeout,
 		 const sigset_t *set)
 {
-  return SYSCALL_CANCEL (epoll_pwait, epfd, events, maxevents,
-			 timeout, set, _NSIG / 8);
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_pwait (PCN_EPOLL_DEFAULT, epfd, events, maxevents, timeout,
+			  set);
+#else
+  return __do_epoll_pwait (PCN_EPOLL_DEFAULT, epfd, events, maxevents, timeout,
+			   set);
+#endif
 }
 
 #else
diff --git a/sysdeps/unix/sysv/linux/epoll_wait.c b/sysdeps/unix/sysv/linux/epoll_wait.c
index 4e343b9344..bf97b5891e 100644
--- a/sysdeps/unix/sysv/linux/epoll_wait.c
+++ b/sysdeps/unix/sysv/linux/epoll_wait.c
@@ -22,13 +22,30 @@
 #include <sys/epoll.h>
 
 #include <sysdep-cancel.h>
+#include <remote_io.h>
+
+/* Match PCN_EPOLL_NEW on x86-64.  */
+#define PCN_EPOLL_DEFAULT 1
 
 int
-epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout)
+__do_epoll_wait (int ver, int epfd, struct epoll_event *events,
+		 int maxevents, int timeout)
 {
 #ifdef __NR_epoll_wait
   return SYSCALL_CANCEL (epoll_wait, epfd, events, maxevents, timeout);
 #else
-  return epoll_pwait (epfd, events, maxevents, timeout, NULL);
+  return SYSCALL_CANCEL (epoll_pwait, epfd, events, maxevents, timeout, NULL);
+#endif
+}
+
+int
+epoll_wait (int epfd, struct epoll_event *events, int maxevents,
+	      int timeout)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_wait (PCN_EPOLL_DEFAULT, epfd, events, maxevents, timeout);
+#else
+  return __do_epoll_wait (PCN_EPOLL_DEFAULT, epfd, events, maxevents, timeout);
 #endif
 }
+libc_hidden_def (epoll_wait)
diff --git a/sysdeps/unix/sysv/linux/execve.c b/sysdeps/unix/sysv/linux/execve.c
new file mode 100644
index 0000000000..8293f75866
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/execve.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+
+#include <remote_io/remote_io.h>
+
+/* Replace the current process, executing PATH with arguments ARGV and
+   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
+int
+__execve (const char *path, char *const argv[], char *const envp[])
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_execve (path, argv, envp);
+#else
+  return INLINE_SYSCALL (execve, 3, path, argv, envp);
+#endif
+}
+libc_hidden_def (__execve)
+weak_alias (__execve, execve)
diff --git a/sysdeps/unix/sysv/linux/fallocate.c b/sysdeps/unix/sysv/linux/fallocate.c
index e40d0c4a23..e33de2c7ea 100644
--- a/sysdeps/unix/sysv/linux/fallocate.c
+++ b/sysdeps/unix/sysv/linux/fallocate.c
@@ -18,13 +18,18 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 #ifndef __OFF_T_MATCHES_OFF64_T
 /* Reserve storage for the data of the file associated with FD.  */
 int
 fallocate (int fd, int mode, __off_t offset, __off_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_fallocate (fd, mode, offset, len);
+#else
   return SYSCALL_CANCEL (fallocate, fd, mode,
 			 SYSCALL_LL (offset), SYSCALL_LL (len));
+#endif
 }
 #endif
diff --git a/sysdeps/unix/sysv/linux/fallocate64.c b/sysdeps/unix/sysv/linux/fallocate64.c
index b2d2fab797..601a4310e3 100644
--- a/sysdeps/unix/sysv/linux/fallocate64.c
+++ b/sysdeps/unix/sysv/linux/fallocate64.c
@@ -18,14 +18,19 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 
 /* Reserve storage for the data of the file associated with FD.  */
 int
 fallocate64 (int fd, int mode, __off64_t offset, __off64_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_fallocate (fd, mode, offset, len);
+#else
   return SYSCALL_CANCEL (fallocate, fd, mode,
 			 SYSCALL_LL64 (offset), SYSCALL_LL64 (len));
+#endif
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/fcntl_nocancel.c b/sysdeps/unix/sysv/linux/fcntl_nocancel.c
index bafc1cff5f..c3652a678b 100644
--- a/sysdeps/unix/sysv/linux/fcntl_nocancel.c
+++ b/sysdeps/unix/sysv/linux/fcntl_nocancel.c
@@ -21,6 +21,7 @@
 #include <errno.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 #ifndef __NR_fcntl64
 # define __NR_fcntl64 __NR_fcntl
@@ -61,5 +62,10 @@ __fcntl64_nocancel_adjusted (int fd, int cmd, void *arg)
         (INTERNAL_SYSCALL_ERRNO (res, err));
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  if (cmd == F_GETFL || cmd == F_SETFL || F_GETFD)
+    return pcn_fcntl (fd, cmd, (void *) arg);
+#endif
+
   return INLINE_SYSCALL_CALL (fcntl64, fd, cmd, (void *) arg);
 }
diff --git a/sysdeps/unix/sysv/linux/fdatasync.c b/sysdeps/unix/sysv/linux/fdatasync.c
index 87175b47d1..0db0de6260 100644
--- a/sysdeps/unix/sysv/linux/fdatasync.c
+++ b/sysdeps/unix/sysv/linux/fdatasync.c
@@ -20,10 +20,17 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+#include <remote_io/message.h>
+
 /* Synchronize at least the data part of a file with the underlying
    media.  */
 int
 fdatasync (int fd)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_sync (PCN_SYS_FDATASYNC, fd);
+#else
   return SYSCALL_CANCEL (fdatasync, fd);
+#endif
 }
diff --git a/sysdeps/unix/sysv/linux/fsync.c b/sysdeps/unix/sysv/linux/fsync.c
index afcca6e862..5200fe08be 100644
--- a/sysdeps/unix/sysv/linux/fsync.c
+++ b/sysdeps/unix/sysv/linux/fsync.c
@@ -20,9 +20,16 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+#include <remote_io/message.h>
+
 /* Make all changes done to FD actually appear on disk.  */
 int
 fsync (int fd)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_sync (PCN_SYS_FSYNC, fd);
+#else
   return SYSCALL_CANCEL (fsync, fd);
+#endif
 }
diff --git a/sysdeps/unix/sysv/linux/ftruncate64.c b/sysdeps/unix/sysv/linux/ftruncate64.c
index 606a0e86e0..2586108f00 100644
--- a/sysdeps/unix/sysv/linux/ftruncate64.c
+++ b/sysdeps/unix/sysv/linux/ftruncate64.c
@@ -19,6 +19,8 @@
 #include <sysdep.h>
 #include <errno.h>
 
+#include <remote_io/remote_io.h>
+
 #ifndef __NR_ftruncate64
 # define __NR_ftruncate64 __NR_ftruncate
 #endif
@@ -27,8 +29,12 @@
 int
 __ftruncate64 (int fd, off64_t length)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_ftruncate64 (fd, length);
+#else
   return INLINE_SYSCALL_CALL (ftruncate64, fd,
 			      __ALIGNMENT_ARG SYSCALL_LL64 (length));
+#endif
 }
 weak_alias (__ftruncate64, ftruncate64)
 
diff --git a/sysdeps/unix/sysv/linux/fxstatat.c b/sysdeps/unix/sysv/linux/fxstatat.c
index 524d5a6df6..94311b2390 100644
--- a/sysdeps/unix/sysv/linux/fxstatat.c
+++ b/sysdeps/unix/sysv/linux/fxstatat.c
@@ -29,12 +29,12 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 #include <xstatconv.h>
 
-/* Get information about the file NAME in BUF.  */
 int
-__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+__do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
 {
   int result;
   INTERNAL_SYSCALL_DECL (err);
@@ -57,6 +57,22 @@ __fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
     return INLINE_SYSCALL_ERROR_RETURN_VALUE (INTERNAL_SYSCALL_ERRNO (result,
 								      err));
 }
+libc_hidden_def (__do_fxstatat)
+
+/* Get information about the file NAME in BUF.  */
+int
+__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  int result;
+  INTERNAL_SYSCALL_DECL (err);
+
+#if IS_IN(libc) && defined SHARED
+  result = pcn_fxstatat (vers, fd, file, &kst, flag);
+#else
+  result = __do_fxstatat (vers, fd, file, st, flag);
+#endif
+  return result;
+}
 libc_hidden_def (__fxstatat)
 #if XSTAT_IS_XSTAT64
 # undef __fxstatat64
diff --git a/sysdeps/unix/sysv/linux/generic/Makefile b/sysdeps/unix/sysv/linux/generic/Makefile
index 124f83a0ab..cd01726b15 100644
--- a/sysdeps/unix/sysv/linux/generic/Makefile
+++ b/sysdeps/unix/sysv/linux/generic/Makefile
@@ -1,3 +1,3 @@
 ifeq ($(subdir),misc)
-sysdep_routines += epoll_create inotify_init stat-check
+sysdep_routines += inotify_init stat-check
 endif
diff --git a/sysdeps/unix/sysv/linux/generic/chmod.c b/sysdeps/unix/sysv/linux/generic/chmod.c
index b9631a9103..6a92fb0c7b 100644
--- a/sysdeps/unix/sysv/linux/generic/chmod.c
+++ b/sysdeps/unix/sysv/linux/generic/chmod.c
@@ -22,11 +22,17 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
+#include <remote_io/remote_io.h>
+
 /* Change the protections of FILE to MODE.  */
 int
 __chmod (const char *file, mode_t mode)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_chmod (file, mode);
+#else
   return INLINE_SYSCALL (fchmodat, 3, AT_FDCWD, file, mode);
+#endif
 }
 
 libc_hidden_def (__chmod)
diff --git a/sysdeps/unix/sysv/linux/generic/dup2.c b/sysdeps/unix/sysv/linux/generic/dup2.c
index 32592f9450..f6900071d2 100644
--- a/sysdeps/unix/sysv/linux/generic/dup2.c
+++ b/sysdeps/unix/sysv/linux/generic/dup2.c
@@ -21,6 +21,8 @@
 #include <limits.h>
 #include <unistd.h>
 
+#include <remote_io/remote_io.h>
+
 /* Duplicate FD to FD2, closing the old FD2 and making FD2 be
    open the same file as FD is.  Return FD2 or -1.  */
 int
@@ -31,7 +33,11 @@ __dup2 (int fd, int fd2)
   if (fd == fd2)
     return __libc_fcntl (fd, F_GETFL, 0) < 0 ? -1 : fd;
 
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_dup3 (fd, fd2, 0);
+#else
   return INLINE_SYSCALL (dup3, 3, fd, fd2, 0);
+#endif
 }
 libc_hidden_def (__dup2)
 weak_alias (__dup2, dup2)
diff --git a/sysdeps/unix/sysv/linux/generic/fstatfs.c b/sysdeps/unix/sysv/linux/generic/fstatfs.c
new file mode 100644
index 0000000000..56564c0180
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/generic/fstatfs.c
@@ -0,0 +1,37 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 1996-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <stddef.h>
+
+#include <remote_io/remote_io.h>
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs (int fd, struct statfs *buf)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_fstatfs (fd, buf);
+#else
+  return SYSCALL_CANCEL (fstatfs, fd, buf);
+#endif
+}
+libc_hidden_weak (__fstatfs)
+weak_alias (__fstatfs, fstatfs)
diff --git a/support/xsched.h b/sysdeps/unix/sysv/linux/generic/fstatfs64.c
similarity index 60%
rename from support/xsched.h
rename to sysdeps/unix/sysv/linux/generic/fstatfs64.c
index eefd731940..1e6fe561ee 100644
--- a/support/xsched.h
+++ b/sysdeps/unix/sysv/linux/generic/fstatfs64.c
@@ -1,5 +1,4 @@
-/* Wrapper for sched.h functions.
-   Copyright (C) 2021 Free Software Foundation, Inc.
+/* Copyright (C) 1998-2020 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,19 +15,21 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#ifndef SUPPORT_XSCHED_H
-#define SUPPORT_XSCHED_H
-
-__BEGIN_DECLS
-
-#include <sched.h>
-#include <sys/types.h>
-
-#ifdef __linux__
-pid_t xclone (int (*fn) (void *arg), void *arg, void *stack,
-	      size_t stack_size, int flags);
+#include <errno.h>
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <stddef.h>
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs64 (int fd, struct statfs64 *buf)
+{
+#ifdef __NR_fstatfs64
+  int rc = INLINE_SYSCALL (fstatfs64, 3, fd, sizeof (*buf), buf);
+  return rc ?: statfs_overflow (buf);
+#else
+  return INLINE_SYSCALL (fstatfs, 2, fd, buf);
 #endif
+}
+weak_alias (__fstatfs64, fstatfs64)
 
-__END_DECLS
-
-#endif
diff --git a/sysdeps/unix/sysv/linux/generic/link.c b/sysdeps/unix/sysv/linux/generic/link.c
index a038ba1408..2ba744a4e7 100644
--- a/sysdeps/unix/sysv/linux/generic/link.c
+++ b/sysdeps/unix/sysv/linux/generic/link.c
@@ -21,11 +21,18 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <remote_io/remote_io.h>
+
 /* Make a link to FROM called TO.  */
 int
 __link (const char *from, const char *to)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_link (from, to);
+#else
   return INLINE_SYSCALL (linkat, 5, AT_FDCWD, from, AT_FDCWD, to, 0);
+#endif
 }
 
+libc_hidden_def (__link)
 weak_alias (__link, link)
diff --git a/sysdeps/unix/sysv/linux/generic/lxstat.c b/sysdeps/unix/sysv/linux/generic/lxstat.c
index 1cf082961a..17aa81a5ab 100644
--- a/sysdeps/unix/sysv/linux/generic/lxstat.c
+++ b/sysdeps/unix/sysv/linux/generic/lxstat.c
@@ -27,14 +27,19 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 /* Get information about the file NAME in BUF.  */
 int
 __lxstat (int vers, const char *name, struct stat *buf)
 {
   if (vers == _STAT_VER_KERNEL)
+#if !IS_IN(rtld) && defined SHARED
+    return pcn_fxstatat (vers, AT_FDCWD, name, buf, AT_SYMLINK_NOFOLLOW);
+#else
     return INLINE_SYSCALL (newfstatat, 4, AT_FDCWD, name, buf,
                            AT_SYMLINK_NOFOLLOW);
+#endif
   errno = EINVAL;
   return -1;
 }
diff --git a/sysdeps/unix/sysv/linux/generic/mkdir.c b/sysdeps/unix/sysv/linux/generic/mkdir.c
index ff2e41fe96..4e6831102d 100644
--- a/sysdeps/unix/sysv/linux/generic/mkdir.c
+++ b/sysdeps/unix/sysv/linux/generic/mkdir.c
@@ -23,12 +23,17 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
+#include <remote_io/remote_io.h>
 
 /* Create a directory named PATH with protections MODE.  */
 int
 __mkdir (const char *path, mode_t mode)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mkdir (path, mode);
+#else
   return INLINE_SYSCALL (mkdirat, 3, AT_FDCWD, path, mode);
+#endif
 }
 
 libc_hidden_def (__mkdir)
diff --git a/sysdeps/unix/sysv/linux/generic/pipe.c b/sysdeps/unix/sysv/linux/generic/pipe.c
index 5d4a95f3e7..35ed20eb83 100644
--- a/sysdeps/unix/sysv/linux/generic/pipe.c
+++ b/sysdeps/unix/sysv/linux/generic/pipe.c
@@ -19,6 +19,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <stddef.h>
+#include <remote_io/remote_io.h>
 
 /* Create a one-way communication channel (__pipe).
    If successful, two file descriptors are stored in PIPEDES;
@@ -27,7 +28,11 @@
 int
 __pipe (int __pipedes[2])
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pipe (__pipedes, 0);
+#else
   return INLINE_SYSCALL (pipe2, 2, __pipedes, 0);
+#endif
 }
 libc_hidden_def (__pipe)
 weak_alias (__pipe, pipe)
diff --git a/sysdeps/unix/sysv/linux/generic/pipe2.c b/sysdeps/unix/sysv/linux/generic/pipe2.c
new file mode 100644
index 0000000000..b6ea98a6d3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/generic/pipe2.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <remote_io/remote_io.h>
+
+/* Create a one-way communication channel (__pipe).
+   If successful, two file descriptors are stored in PIPEDES;
+   bytes written on PIPEDES[1] can be read from PIPEDES[0].
+   Returns 0 if successful, -1 if not.  */
+int
+__pipe2 (int __pipedes[2], int flags)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pipe (__pipedes, flags);
+#else
+  return INLINE_SYSCALL (pipe2, 2, __pipedes, flags);
+#endif
+}
+libc_hidden_def (__pipe2)
+weak_alias (__pipe2, pipe2)
diff --git a/sysdeps/unix/sysv/linux/generic/readlink.c b/sysdeps/unix/sysv/linux/generic/readlink.c
index 721f84e3dd..b52ffe8761 100644
--- a/sysdeps/unix/sysv/linux/generic/readlink.c
+++ b/sysdeps/unix/sysv/linux/generic/readlink.c
@@ -20,12 +20,19 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <remote_io/remote_io.h>
+
 /* Read the contents of the symbolic link PATH into no more than
    LEN bytes of BUF.  The contents are not null-terminated.
    Returns the number of characters read, or -1 for errors.  */
 ssize_t
 __readlink (const char *path, char *buf, size_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_readlink (path, buf, len);
+#else
   return INLINE_SYSCALL (readlinkat, 4, AT_FDCWD, path, buf, len);
+#endif
 }
+libc_hidden_def (__readlink)
 weak_alias (__readlink, readlink)
diff --git a/sysdeps/unix/sysv/linux/generic/rmdir.c b/sysdeps/unix/sysv/linux/generic/rmdir.c
index e357a10e8d..c286e53ae6 100644
--- a/sysdeps/unix/sysv/linux/generic/rmdir.c
+++ b/sysdeps/unix/sysv/linux/generic/rmdir.c
@@ -21,11 +21,17 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <remote_io/remote_io.h>
 
 /* Remove the directory PATH.  */
 int
 __rmdir (const char *path)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_rmdir (path);
+#else
   return INLINE_SYSCALL (unlinkat, 3, AT_FDCWD, path, AT_REMOVEDIR);
+#endif
 }
+libc_hidden_def (__rmdir)
 weak_alias (__rmdir, rmdir)
diff --git a/sysdeps/unix/sysv/linux/generic/statfs.c b/sysdeps/unix/sysv/linux/generic/statfs.c
new file mode 100644
index 0000000000..c34e96dbae
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/generic/statfs.c
@@ -0,0 +1,37 @@
+/* statfs -- Return information about the filesystem on which FILE resides.
+   Copyright (C) 1996-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <stddef.h>
+
+#include <remote_io/remote_io.h>
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statfs (const char *file, struct statfs *buf)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_statfs (file, buf);
+#else
+  return SYSCALL_CANCEL (statfs, file, buf);
+#endif
+}
+libc_hidden_weak (__statfs)
+weak_alias (__statfs, statfs)
diff --git a/sysdeps/unix/sysv/linux/generic/symlink.c b/sysdeps/unix/sysv/linux/generic/symlink.c
index cddc11acf0..d6d2232058 100644
--- a/sysdeps/unix/sysv/linux/generic/symlink.c
+++ b/sysdeps/unix/sysv/linux/generic/symlink.c
@@ -21,10 +21,17 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <remote_io/remote_io.h>
+
 /* Make a link to FROM called TO.  */
 int
 __symlink (const char *from, const char *to)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_symlink (from, to);
+#else
   return INLINE_SYSCALL (symlinkat, 3, from, AT_FDCWD, to);
+#endif
 }
+libc_hidden_def (__symlink)
 weak_alias (__symlink, symlink)
diff --git a/sysdeps/unix/sysv/linux/generic/syscalls.list b/sysdeps/unix/sysv/linux/generic/syscalls.list
index ed8b216d47..02699f8a16 100644
--- a/sysdeps/unix/sysv/linux/generic/syscalls.list
+++ b/sysdeps/unix/sysv/linux/generic/syscalls.list
@@ -1,12 +1,5 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
 # Socket APIs
-socket		-	socket		i:iii	__socket	socket
 socketpair	-	socketpair	i:iiif	__socketpair	socketpair
-bind		-	bind		i:ipi	__bind		bind
-listen		-	listen		i:ii	__listen	listen
-getsockname	-	getsockname	i:ipp	__getsockname	getsockname
-getpeername	-	getpeername	i:ipp	__getpeername	getpeername
-setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
-getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
 shutdown	-	shutdown	i:ii	__shutdown	shutdown
diff --git a/sysdeps/unix/sysv/linux/generic/unlink.c b/sysdeps/unix/sysv/linux/generic/unlink.c
index 7908d0a576..1b8b140a84 100644
--- a/sysdeps/unix/sysv/linux/generic/unlink.c
+++ b/sysdeps/unix/sysv/linux/generic/unlink.c
@@ -21,11 +21,17 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <remote_io/remote_io.h>
 
 /* Remove the link named NAME.  */
 int
 __unlink (const char *name)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_unlink (name);
+#else
   return INLINE_SYSCALL (unlinkat, 3, AT_FDCWD, name, 0);
+#endif
 }
+libc_hidden_def (__unlink)
 weak_alias (__unlink, unlink)
diff --git a/sysdeps/unix/sysv/linux/generic/xstat.c b/sysdeps/unix/sysv/linux/generic/xstat.c
index 2eb27a6f91..8750f68209 100644
--- a/sysdeps/unix/sysv/linux/generic/xstat.c
+++ b/sysdeps/unix/sysv/linux/generic/xstat.c
@@ -28,12 +28,18 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
+#include <remote_io/remote_io.h>
+
 /* Get information about the file NAME in BUF.  */
 int
 __xstat (int vers, const char *name, struct stat *buf)
 {
   if (vers == _STAT_VER_KERNEL)
+#if IS_IN(libc) && defined SHARED
+    return pcn_fxstatat (vers, AT_FDCWD, name, buf, 0);
+#else
     return INLINE_SYSCALL (newfstatat, 4, AT_FDCWD, name, buf, 0);
+#endif
 
   errno = EINVAL;
   return -1;
diff --git a/sysdeps/unix/sysv/linux/getcwd.c b/sysdeps/unix/sysv/linux/getcwd.c
index fabc4bb8cc..64532dfce0 100644
--- a/sysdeps/unix/sysv/linux/getcwd.c
+++ b/sysdeps/unix/sysv/linux/getcwd.c
@@ -26,6 +26,7 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 
 /* If we compile the file for use in ld.so we don't need the feature
@@ -75,7 +76,12 @@ __getcwd (char *buf, size_t size)
 
   int retval;
 
+#if !IS_IN(rtld) && defined SHARED
+  retval = pcn_getcwd (path, alloc_size);
+#else
   retval = INLINE_SYSCALL (getcwd, 2, path, alloc_size);
+#endif
+
   if (retval > 0 && path[0] == '/')
     {
 #ifndef NO_ALLOCATION
diff --git a/sysdeps/unix/sysv/linux/getdents64.c b/sysdeps/unix/sysv/linux/getdents64.c
index 75892c2823..e60c21674a 100644
--- a/sysdeps/unix/sysv/linux/getdents64.c
+++ b/sysdeps/unix/sysv/linux/getdents64.c
@@ -21,6 +21,8 @@
 #include <errno.h>
 #include <limits.h>
 
+#include <remote_io/remote_io.h>
+
 /* The kernel struct linux_dirent64 matches the 'struct dirent64' type.  */
 ssize_t
 __getdents64 (int fd, void *buf, size_t nbytes)
@@ -29,7 +31,11 @@ __getdents64 (int fd, void *buf, size_t nbytes)
      checks in the kernel use an int type.  */
   if (nbytes > INT_MAX)
     nbytes = INT_MAX;
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_getdents64 (fd, buf, nbytes);
+#else
   return INLINE_SYSCALL_CALL (getdents64, fd, buf, nbytes);
+#endif
 }
 libc_hidden_def (__getdents64)
 weak_alias (__getdents64, getdents64)
diff --git a/sysdeps/unix/sysv/linux/getitimer.c b/sysdeps/unix/sysv/linux/getitimer.c
new file mode 100644
index 0000000000..286e7cca3c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/getitimer.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sysdep-cancel.h>
+
+#include <remote_io/remote_io.h>
+
+/* Set *VALUE to the current setting of timer WHICH.
+   Return 0 on success, -1 on errors.  */
+int
+__getitimer (enum __itimer_which which, struct itimerval *value)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_getitimer (which, value);
+#else
+  return SYSCALL_CANCEL (getitimer, which, value);
+#endif
+}
+
+weak_alias (__getitimer, getitimer)
diff --git a/sysdeps/unix/sysv/linux/getpeername.c b/sysdeps/unix/sysv/linux/getpeername.c
index addd32dc85..8dffd04b70 100644
--- a/sysdeps/unix/sysv/linux/getpeername.c
+++ b/sysdeps/unix/sysv/linux/getpeername.c
@@ -23,13 +23,20 @@
 #include <kernel-features.h>
 #include <sys/syscall.h>
 
+#include <remote_io/message.h>
+#include <remote_io/remote_io.h>
+
 int
 __getpeername (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_sock_getname (PCN_SYS_GETPEERNAME, fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_GETPEERNAME_SYSCALL
   return INLINE_SYSCALL (getpeername, 3, fd, addr.__sockaddr__, len);
 #else
   return SOCKETCALL (getpeername, fd, addr.__sockaddr__, len);
 #endif
+#endif
 }
 weak_alias (__getpeername, getpeername)
diff --git a/sysdeps/unix/sysv/linux/getpt.c b/sysdeps/unix/sysv/linux/getpt.c
index 3cc745e11a..1803b232c9 100644
--- a/sysdeps/unix/sysv/linux/getpt.c
+++ b/sysdeps/unix/sysv/linux/getpt.c
@@ -16,18 +16,69 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <errno.h>
 #include <fcntl.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include <paths.h>
+#include <sys/statfs.h>
+
+#include "linux_fsinfo.h"
 
 /* Path to the master pseudo terminal cloning device.  */
 #define _PATH_DEVPTMX _PATH_DEV "ptmx"
+/* Directory containing the UNIX98 pseudo terminals.  */
+#define _PATH_DEVPTS _PATH_DEV "pts"
+
+/* Prototype for function that opens BSD-style master pseudo-terminals.  */
+extern int __bsd_getpt (void) attribute_hidden;
 
 /* Open a master pseudo terminal and return its file descriptor.  */
 int
 __posix_openpt (int oflag)
 {
-  return __open (_PATH_DEVPTMX, oflag);
+  static int have_no_dev_ptmx;
+  int fd;
+
+  if (!have_no_dev_ptmx)
+    {
+      fd = __open (_PATH_DEVPTMX, oflag);
+      if (fd != -1)
+	{
+	  struct statfs fsbuf;
+	  static int devpts_mounted;
+
+	  /* Check that the /dev/pts filesystem is mounted
+	     or if /dev is a devfs filesystem (this implies /dev/pts).  */
+	  if (devpts_mounted
+	      || (__statfs (_PATH_DEVPTS, &fsbuf) == 0
+		  && fsbuf.f_type == DEVPTS_SUPER_MAGIC)
+	      || (__statfs (_PATH_DEV, &fsbuf) == 0
+		  && fsbuf.f_type == DEVFS_SUPER_MAGIC))
+	    {
+	      /* Everything is ok.  */
+	      devpts_mounted = 1;
+	      return fd;
+	    }
+
+	  /* If /dev/pts is not mounted then the UNIX98 pseudo terminals
+	     are not usable.  */
+	  __close (fd);
+	  have_no_dev_ptmx = 1;
+	  __set_errno (ENOENT);
+	}
+      else
+	{
+	  if (errno == ENOENT || errno == ENODEV)
+	    have_no_dev_ptmx = 1;
+	  else
+	    return -1;
+	}
+    }
+  else
+    __set_errno (ENOENT);
+
+  return -1;
 }
 weak_alias (__posix_openpt, posix_openpt)
 
@@ -35,6 +86,16 @@ weak_alias (__posix_openpt, posix_openpt)
 int
 __getpt (void)
 {
-  return __posix_openpt (O_RDWR);
+  int fd = __posix_openpt (O_RDWR);
+  if (fd == -1)
+    fd = __bsd_getpt ();
+  return fd;
 }
-weak_alias (__getpt, getpt)
+
+
+#define PTYNAME1 "pqrstuvwxyzabcde";
+#define PTYNAME2 "0123456789abcdef";
+
+#define __getpt __bsd_getpt
+#define HAVE_POSIX_OPENPT
+#include <sysdeps/unix/bsd/getpt.c>
diff --git a/sysdeps/unix/sysv/linux/getrlimit64.c b/sysdeps/unix/sysv/linux/getrlimit64.c
index 0f9a2f4936..6ff9af0c5c 100644
--- a/sysdeps/unix/sysv/linux/getrlimit64.c
+++ b/sysdeps/unix/sysv/linux/getrlimit64.c
@@ -27,6 +27,7 @@
 #define getrlimit getrlimit_redirect
 #define __getrlimit __getrlimit_redirect
 #include <sys/resource.h>
+#include <stddef.h>
 #undef getrlimit
 #undef __getrlimit
 
diff --git a/sysdeps/unix/sysv/linux/getsockname.c b/sysdeps/unix/sysv/linux/getsockname.c
index e24a5515ab..8792dd9838 100644
--- a/sysdeps/unix/sysv/linux/getsockname.c
+++ b/sysdeps/unix/sysv/linux/getsockname.c
@@ -23,13 +23,20 @@
 #include <kernel-features.h>
 #include <sys/syscall.h>
 
+#include <remote_io/message.h>
+#include <remote_io/remote_io.h>
+
 int
 __getsockname (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_sock_getname (PCN_SYS_GETSOCKNAME, fd, addr.__sockaddr__, len);
+#else
 #ifdef __ASSUME_GETSOCKNAME_SYSCALL
   return INLINE_SYSCALL (getsockname, 3, fd, addr.__sockaddr__, len);
 #else
   return SOCKETCALL (getsockname, fd, addr.__sockaddr__, len);
 #endif
+#endif
 }
 weak_alias (__getsockname, getsockname)
diff --git a/sysdeps/unix/sysv/linux/getsockopt.c b/sysdeps/unix/sysv/linux/getsockopt.c
index 11939660c1..844824839a 100644
--- a/sysdeps/unix/sysv/linux/getsockopt.c
+++ b/sysdeps/unix/sysv/linux/getsockopt.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __getsockopt (int fd, int level, int optname, void *optval, socklen_t *len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_getsockopt (fd, level, optname, optval, len);
+#else
 #ifdef __ASSUME_GETSOCKOPT_SYSCALL
   return INLINE_SYSCALL (getsockopt, 5, fd, level, optname, optval, len);
 #else
   return SOCKETCALL (getsockopt, fd, level, optname, optval, len);
 #endif
+#endif
 }
 weak_alias (__getsockopt, getsockopt)
diff --git a/sysdeps/unix/sysv/linux/grantpt.c b/sysdeps/unix/sysv/linux/grantpt.c
index 43122f9a76..2030e07fa6 100644
--- a/sysdeps/unix/sysv/linux/grantpt.c
+++ b/sysdeps/unix/sysv/linux/grantpt.c
@@ -1,41 +1,44 @@
-/* grantpt implementation for Linux.
-   Copyright (C) 1998-2020 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Zack Weinberg <zack@rabi.phys.columbia.edu>, 1998.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
+#include <assert.h>
+#include <ctype.h>
+#include <dirent.h>
 #include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
 #include <stdlib.h>
-#include <sys/ioctl.h>
-#include <termios.h>
+#include <unistd.h>
 
-int
-grantpt (int fd)
+#include <not-cancel.h>
+
+#include "pty-private.h"
+
+#if HAVE_PT_CHOWN
+/* Close all file descriptors except the one specified.  */
+static void
+close_all_fds (void)
 {
-  /* Without pt_chown on Linux, we have delegated the creation of the
-     pty node with the right group and permission mode to the kernel, and
-     non-root users are unlikely to be able to change it. Therefore let's
-     consider that POSIX enforcement is the responsibility of the whole
-     system and not only the GNU libc.   */
+  DIR *dir = __opendir ("/proc/self/fd");
+  if (dir != NULL)
+    {
+      struct dirent64 *d;
+      while ((d = __readdir64 (dir)) != NULL)
+	if (isdigit (d->d_name[0]))
+	  {
+	    char *endp;
+	    long int fd = strtol (d->d_name, &endp, 10);
+	    if (*endp == '\0' && fd != PTY_FILENO && fd != dirfd (dir))
+	      __close_nocancel_nostatus (fd);
+	  }
 
-  /* Verify that fd refers to a ptmx descriptor.  */
-  unsigned int ptyno;
-  int ret = __ioctl (fd, TIOCGPTN, &ptyno);
-  if (ret != 0 && errno == ENOTTY)
-    /* POSIX requires EINVAL instead of ENOTTY provided by the kernel.  */
-    __set_errno (EINVAL);
-  return ret;
+      __closedir (dir);
+
+      int nullfd = __open_nocancel (_PATH_DEVNULL, O_RDONLY);
+      assert (nullfd == STDIN_FILENO);
+      nullfd = __open_nocancel (_PATH_DEVNULL, O_WRONLY);
+      assert (nullfd == STDOUT_FILENO);
+      __dup2 (STDOUT_FILENO, STDERR_FILENO);
+    }
 }
+# define CLOSE_ALL_FDS() close_all_fds()
+#endif
+
+#include <sysdeps/unix/grantpt.c>
diff --git a/sysdeps/unix/sysv/linux/kill.c b/sysdeps/unix/sysv/linux/kill.c
new file mode 100644
index 0000000000..e5cbcce18f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/kill.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+
+#include <remote_io/remote_io.h>
+
+/* Send signal SIG to process number PID.  If PID is zero,
+   send SIG to all processes in the current process's process group.
+   If PID is < -1, send SIG to all processes in process group - PID.  */
+int
+__kill (int pid, int sig)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_kill (pid, sig);
+#else
+  return INLINE_SYSCALL_CALL (kill, pid, sig);
+#endif
+}
+libc_hidden_def (__kill)
+weak_alias (__kill, kill)
diff --git a/sysdeps/unix/sysv/linux/link.c b/sysdeps/unix/sysv/linux/link.c
new file mode 100644
index 0000000000..189f8cf6f6
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/link.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <remote_io/remote_io.h>
+
+/* Make a link to FROM called TO.  */
+int
+__link (const char *from, const char *to)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_link (from, to);
+#else
+  return INLINE_SYSCALL (link, 2, from, to);
+#endif
+}
+
+libc_hidden_def (__link)
+weak_alias (__link, link)
diff --git a/sysdeps/unix/sysv/linux/listen.c b/sysdeps/unix/sysv/linux/listen.c
index 124c2fed74..4775e502d1 100644
--- a/sysdeps/unix/sysv/linux/listen.c
+++ b/sysdeps/unix/sysv/linux/listen.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 listen (int fd, int backlog)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_listen (fd, backlog);
+#else
 #ifdef __ASSUME_LISTEN_SYSCALL
   return INLINE_SYSCALL (listen, 2, fd, backlog);
 #else
   return SOCKETCALL (listen, fd, backlog);
 #endif
+#endif
 }
 weak_alias (listen, __listen);
diff --git a/sysdeps/unix/sysv/linux/lseek64.c b/sysdeps/unix/sysv/linux/lseek64.c
index d1aee524e2..d433f79915 100644
--- a/sysdeps/unix/sysv/linux/lseek64.c
+++ b/sysdeps/unix/sysv/linux/lseek64.c
@@ -23,9 +23,14 @@
 #include <errno.h>
 #include <shlib-compat.h>
 
+#include <remote_io/remote_io.h>
+
 off64_t
 __lseek64 (int fd, off64_t offset, int whence)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_lseek64 (fd, offset, whence);
+#else
 #ifdef __NR__llseek
   loff_t res;
   int rc = INLINE_SYSCALL_CALL (_llseek, fd,
@@ -35,6 +40,7 @@ __lseek64 (int fd, off64_t offset, int whence)
 #else
   return INLINE_SYSCALL_CALL (lseek, fd, offset, whence);
 #endif
+#endif
 }
 
 #ifdef  __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/mkdir.c b/sysdeps/unix/sysv/linux/mkdir.c
new file mode 100644
index 0000000000..d7adb8e35c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/mkdir.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sysdep.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <remote_io/remote_io.h>
+
+/* Create a directory named PATH with protections MODE.  */
+int
+__mkdir (const char *path, mode_t mode)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mkdir (path, mode);
+#else
+  return INLINE_SYSCALL (mkdir, 2, path, mode);
+#endif
+}
+
+libc_hidden_def (__mkdir)
+weak_alias (__mkdir, mkdir)
diff --git a/sysdeps/unix/sysv/linux/mmap.c b/sysdeps/unix/sysv/linux/mmap.c
index 22f276bb14..a101a36239 100644
--- a/sysdeps/unix/sysv/linux/mmap.c
+++ b/sysdeps/unix/sysv/linux/mmap.c
@@ -21,6 +21,7 @@
 #include <sys/mman.h>
 #include <sysdep.h>
 #include <stdint.h>
+#include <remote_io/remote_io.h>
 
 #ifndef __OFF_T_MATCHES_OFF64_T
 # include <mmap_internal.h>
@@ -39,12 +40,22 @@ __mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset)
     return (void *) INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
 
 #ifdef __NR_mmap2
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd,
+  		   offset / (uint32_t) MMAP2_PAGE_UNIT);
+#else
   return (void *) MMAP_CALL (mmap2, addr, len, prot, flags, fd,
 			     offset / (uint32_t) MMAP2_PAGE_UNIT);
+#endif
+#else
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd,
+		   MMAP_ADJUST_OFFSET (offset));
 #else
   return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd,
 			     MMAP_ADJUST_OFFSET (offset));
 #endif
+#endif
 }
 weak_alias (__mmap, mmap)
 libc_hidden_def (__mmap)
diff --git a/sysdeps/unix/sysv/linux/mmap64.c b/sysdeps/unix/sysv/linux/mmap64.c
index 8074deb466..5363f950e6 100644
--- a/sysdeps/unix/sysv/linux/mmap64.c
+++ b/sysdeps/unix/sysv/linux/mmap64.c
@@ -22,6 +22,7 @@
 #include <sys/mman.h>
 #include <sysdep.h>
 #include <mmap_internal.h>
+#include <remote_io/remote_io.h>
 
 #ifdef __NR_mmap2
 /* To avoid silent truncation of offset when using mmap2, do not accept
@@ -53,11 +54,20 @@ __mmap64 (void *addr, size_t len, int prot, int flags, int fd, off64_t offset)
 
   MMAP_PREPARE (addr, len, prot, flags, fd, offset);
 #ifdef __NR_mmap2
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd,
+		   (off_t) (offset / MMAP2_PAGE_UNIT));
+#else
   return (void *) MMAP_CALL (mmap2, addr, len, prot, flags, fd,
 			     (off_t) (offset / MMAP2_PAGE_UNIT));
+#endif
+#else
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_mmap (addr, len, prot, flags, fd, offset);
 #else
   return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd, offset);
 #endif
+#endif
 }
 weak_alias (__mmap64, mmap64)
 libc_hidden_def (__mmap64)
diff --git a/stdio-common/tst-grouping2.c b/sysdeps/unix/sysv/linux/munmap.c
similarity index 61%
rename from stdio-common/tst-grouping2.c
rename to sysdeps/unix/sysv/linux/munmap.c
index 3024c942a6..f74bc6c6ca 100644
--- a/stdio-common/tst-grouping2.c
+++ b/sysdeps/unix/sysv/linux/munmap.c
@@ -1,4 +1,4 @@
-/* Test printf with grouping and large width (bug 29530)
+/* mmap - map files or devices into memory.  Linux version.
    Copyright (C) 2022 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -16,24 +16,22 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <locale.h>
-#include <stdio.h>
-#include <support/check.h>
-#include <support/support.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sysdep.h>
+#include <stdint.h>
+#include <remote_io/remote_io.h>
 
-static int
-do_test (void)
+int
+__munmap (void *addr, size_t len)
 {
-  const int field_width = 1000;
-  char buf[field_width + 1];
-
-  xsetlocale (LC_NUMERIC, "de_DE.UTF-8");
-
-  /* This used to crash in group_number.  */
-  TEST_COMPARE (sprintf (buf, "%'*d", field_width, 1000), field_width);
-  TEST_COMPARE_STRING (buf + field_width - 6, " 1.000");
-
-  return 0;
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_munmap (addr, len);
+#else
+  return (int) INLINE_SYSCALL_CALL (munmap, addr, len);
+#endif
 }
 
-#include <support/test-driver.c>
+weak_alias (__munmap, munmap)
+libc_hidden_def (__munmap)
diff --git a/sysdeps/unix/sysv/linux/open64.c b/sysdeps/unix/sysv/linux/open64.c
index f2d0c55810..8c7694e04d 100644
--- a/sysdeps/unix/sysv/linux/open64.c
+++ b/sysdeps/unix/sysv/linux/open64.c
@@ -20,6 +20,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdarg.h>
+#include <remote_io/remote_io.h>
 
 #include <sysdep-cancel.h>
 
@@ -45,8 +46,14 @@ __libc_open64 (const char *file, int oflag, ...)
       va_end (arg);
     }
 
+#if !IS_IN(rtld) && defined SHARED
+//  rio_dbg_printf ("%s: dirfd = %x, pathname = %s, flags = %x, mode = %x\n",
+//		  __FUNCTION__, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+  return pcn_openat (AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+#else
   return SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,
 			 mode);
+#endif
 }
 
 strong_alias (__libc_open64, __open64)
diff --git a/sysdeps/unix/sysv/linux/open64_nocancel.c b/sysdeps/unix/sysv/linux/open64_nocancel.c
index 6f4580a455..6248609c0a 100644
--- a/sysdeps/unix/sysv/linux/open64_nocancel.c
+++ b/sysdeps/unix/sysv/linux/open64_nocancel.c
@@ -20,6 +20,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdarg.h>
+#include <remote_io/remote_io.h>
 
 #include <not-cancel.h>
 
@@ -42,8 +43,13 @@ __open64_nocancel (const char *file, int oflag, ...)
       va_end (arg);
     }
 
+#if !IS_IN(rtld) && defined SHARED
+//  rio_dbg_printf ("%s: %x, %s, %x, %x\n", __FUNCTION__, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+  return pcn_openat (AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);
+#else
   return INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,
 			      mode);
+#endif
 }
 
 hidden_def (__open64_nocancel)
diff --git a/sysdeps/unix/sysv/linux/openat64_nocancel.c b/sysdeps/unix/sysv/linux/openat64_nocancel.c
index 80fe66210d..a63648d61c 100644
--- a/sysdeps/unix/sysv/linux/openat64_nocancel.c
+++ b/sysdeps/unix/sysv/linux/openat64_nocancel.c
@@ -1,3 +1,5 @@
+// This file needs to by updated to use pcn_open.  */
+
 /* Linux openat syscall implementation, LFS, non-cancellable.
    Copyright (C) 2018-2020 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/sysdeps/unix/sysv/linux/poll.c b/sysdeps/unix/sysv/linux/poll.c
index 1c41ade1b7..db1e018e32 100644
--- a/sysdeps/unix/sysv/linux/poll.c
+++ b/sysdeps/unix/sysv/linux/poll.c
@@ -21,12 +21,17 @@
 
 #include <sysdep-cancel.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __poll (struct pollfd *fds, nfds_t nfds, int timeout)
 {
 #ifdef __NR_poll
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_poll  (fds, nfds, timeout);
+#else
   return SYSCALL_CANCEL (poll, fds, nfds, timeout);
+#endif
 #else
   struct timespec timeout_ts;
   struct timespec *timeout_ts_p = NULL;
@@ -38,8 +43,12 @@ __poll (struct pollfd *fds, nfds_t nfds, int timeout)
       timeout_ts_p = &timeout_ts;
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_ppoll (fds, nfds, timeout_ts_p, NULL);
+#else
   return SYSCALL_CANCEL (ppoll, fds, nfds, timeout_ts_p, NULL, 0);
 #endif
+#endif
 }
 libc_hidden_def (__poll)
 weak_alias (__poll, poll)
diff --git a/sysdeps/unix/sysv/linux/ppoll.c b/sysdeps/unix/sysv/linux/ppoll.c
index 3fcd19efb4..970f0bb33b 100644
--- a/sysdeps/unix/sysv/linux/ppoll.c
+++ b/sysdeps/unix/sysv/linux/ppoll.c
@@ -22,7 +22,7 @@
 #include <sys/poll.h>
 #include <sysdep-cancel.h>
 #include <kernel-features.h>
-
+#include <remote_io/remote_io.h>
 
 int
 __ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
@@ -41,7 +41,11 @@ __ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
 # ifndef __NR_ppoll_time64
 #  define __NR_ppoll_time64 __NR_ppoll
 # endif
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_ppoll (fds, nfds, timeout, sigmask);
+#else
   return SYSCALL_CANCEL (ppoll_time64, fds, nfds, timeout, sigmask, _NSIG / 8);
+#endif
 #else
 # ifdef __NR_ppoll_time64
   int ret = SYSCALL_CANCEL (ppoll_time64, fds, nfds, timeout, sigmask,
@@ -61,9 +65,13 @@ __ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
       ts32 = valid_timespec64_to_timespec (*timeout);
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_ppoll (fds, nfds, timeout ? &ts32 : NULL, sigmask);
+#else
   return SYSCALL_CANCEL (ppoll, fds, nfds, timeout ? &ts32 : NULL, sigmask,
                          _NSIG / 8);
 #endif
+#endif
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/pread64.c b/sysdeps/unix/sysv/linux/pread64.c
index a7f907186b..0091460224 100644
--- a/sysdeps/unix/sysv/linux/pread64.c
+++ b/sysdeps/unix/sysv/linux/pread64.c
@@ -18,6 +18,7 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 #ifndef __NR_pread64
 # define __NR_pread64 __NR_pread
@@ -26,7 +27,11 @@
 ssize_t
 __libc_pread64 (int fd, void *buf, size_t count, off64_t offset)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pread64 (fd, buf, count, offset);
+#else
   return SYSCALL_CANCEL (pread64, fd, buf, count, SYSCALL_LL64_PRW (offset));
+#endif
 }
 
 weak_alias (__libc_pread64, __pread64)
diff --git a/sysdeps/unix/sysv/linux/pselect.c b/sysdeps/unix/sysv/linux/pselect.c
index d7c6ff8fdb..49dd69211b 100644
--- a/sysdeps/unix/sysv/linux/pselect.c
+++ b/sysdeps/unix/sysv/linux/pselect.c
@@ -19,10 +19,15 @@
 #include <sys/select.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+
 int
 __pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
 	   const struct timespec *timeout, const sigset_t *sigmask)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pselect (nfds, readfds, writefds, exceptfds, timeout, sigmask);
+#else
   /* The Linux kernel can in some situations update the timeout value.
      We do not want that so use a local variable.  */
   struct timespec tval;
@@ -47,6 +52,7 @@ __pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
 
   return SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds,
                          timeout, &data);
+#endif
 }
 #ifndef __pselect
 weak_alias (__pselect, pselect)
diff --git a/sysdeps/unix/sysv/linux/ptsname.c b/sysdeps/unix/sysv/linux/ptsname.c
index 3e9be3f0d4..81d9d26f1e 100644
--- a/sysdeps/unix/sysv/linux/ptsname.c
+++ b/sysdeps/unix/sysv/linux/ptsname.c
@@ -21,14 +21,39 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
 #include <termios.h>
 #include <unistd.h>
 
 #include <_itoa.h>
 
+/* Check if DEV corresponds to a master pseudo terminal device.  */
+#define MASTER_P(Dev)							\
+  (__gnu_dev_major ((Dev)) == 2						\
+   || (__gnu_dev_major ((Dev)) == 4					\
+       && __gnu_dev_minor ((Dev)) >= 128 && __gnu_dev_minor ((Dev)) < 192) \
+   || (__gnu_dev_major ((Dev)) >= 128 && __gnu_dev_major ((Dev)) < 136))
+
+/* Check if DEV corresponds to a slave pseudo terminal device.  */
+#define SLAVE_P(Dev)							\
+  (__gnu_dev_major ((Dev)) == 3						\
+   || (__gnu_dev_major ((Dev)) == 4					\
+       && __gnu_dev_minor ((Dev)) >= 192 && __gnu_dev_minor ((Dev)) < 256) \
+   || (__gnu_dev_major ((Dev)) >= 136 && __gnu_dev_major ((Dev)) < 144))
+
+/* Note that major number 4 corresponds to the old BSD style pseudo
+   terminal devices.  As of Linux 2.1.115 these are no longer
+   supported.  They have been replaced by major numbers 2 (masters)
+   and 3 (slaves).  */
+
 /* Directory where we can find the slave pty nodes.  */
 #define _PATH_DEVPTS "/dev/pts/"
 
+/* The are declared in getpt.c.  */
+extern const char __libc_ptyname1[] attribute_hidden;
+extern const char __libc_ptyname2[] attribute_hidden;
+
 /* Static buffer for `ptsname'.  */
 static char buffer[sizeof (_PATH_DEVPTS) + 20];
 
@@ -43,15 +68,19 @@ ptsname (int fd)
 }
 
 
-/* Store at most BUFLEN characters of the pathname of the slave pseudo
-   terminal associated with the master FD is open on in BUF.
-   Return 0 on success, otherwise an error number.  */
 int
-__ptsname_r (int fd, char *buf, size_t buflen)
+__ptsname_internal (int fd, char *buf, size_t buflen, struct stat64 *stp)
 {
   int save_errno = errno;
   unsigned int ptyno;
 
+  if (!__isatty (fd))
+    {
+      __set_errno (ENOTTY);
+      return ENOTTY;
+    }
+
+#ifdef TIOCGPTN
   if (__ioctl (fd, TIOCGPTN, &ptyno) == 0)
     {
       /* Buffer we use to print the number in.  For a maximum size for
@@ -72,11 +101,67 @@ __ptsname_r (int fd, char *buf, size_t buflen)
 
       memcpy (__stpcpy (buf, devpts), p, &numbuf[sizeof (numbuf)] - p);
     }
+  else if (errno != EINVAL)
+    return errno;
   else
-    /* Bad file descriptor, or not a ptmx descriptor.  */
+#endif
+    {
+      char *p;
+
+      if (buflen < strlen (_PATH_TTY) + 3)
+	{
+	  __set_errno (ERANGE);
+	  return ERANGE;
+	}
+
+      if (__fxstat64 (_STAT_VER, fd, stp) < 0)
+	return errno;
+
+      /* Check if FD really is a master pseudo terminal.  */
+      if (! MASTER_P (stp->st_rdev))
+	{
+	  __set_errno (ENOTTY);
+	  return ENOTTY;
+	}
+
+      ptyno = __gnu_dev_minor (stp->st_rdev);
+
+      if (ptyno / 16 >= strlen (__libc_ptyname1))
+	{
+	  __set_errno (ENOTTY);
+	  return ENOTTY;
+	}
+
+      p = __stpcpy (buf, _PATH_TTY);
+      p[0] = __libc_ptyname1[ptyno / 16];
+      p[1] = __libc_ptyname2[ptyno % 16];
+      p[2] = '\0';
+    }
+
+  if (__xstat64 (_STAT_VER, buf, stp) < 0)
     return errno;
 
+  /* Check if the name we're about to return really corresponds to a
+     slave pseudo terminal.  */
+  if (! S_ISCHR (stp->st_mode) || ! SLAVE_P (stp->st_rdev))
+    {
+      /* This really is a configuration problem.  */
+      __set_errno (ENOTTY);
+      return ENOTTY;
+    }
+
   __set_errno (save_errno);
   return 0;
 }
+
+
+/* Store at most BUFLEN characters of the pathname of the slave pseudo
+   terminal associated with the master FD is open on in BUF.
+   Return 0 on success, otherwise an error number.  */
+int
+__ptsname_r (int fd, char *buf, size_t buflen)
+{
+  struct stat64 st;
+  return __ptsname_internal (fd, buf, buflen, &st);
+}
 weak_alias (__ptsname_r, ptsname_r)
diff --git a/sysdeps/unix/sysv/linux/pwrite64.c b/sysdeps/unix/sysv/linux/pwrite64.c
index 632f001f5b..2e90810cfe 100644
--- a/sysdeps/unix/sysv/linux/pwrite64.c
+++ b/sysdeps/unix/sysv/linux/pwrite64.c
@@ -19,6 +19,8 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+
 #ifndef __NR_pwrite64
 # define __NR_pwrite64 __NR_pwrite
 #endif
@@ -26,7 +28,11 @@
 ssize_t
 __libc_pwrite64 (int fd, const void *buf, size_t count, off64_t offset)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pwrite64 (fd, buf, count, offset);
+#else
   return SYSCALL_CANCEL (pwrite64, fd, buf, count, SYSCALL_LL64_PRW (offset));
+#endif
 }
 
 weak_alias (__libc_pwrite64, __pwrite64)
diff --git a/sysdeps/unix/sysv/linux/pwritev64.c b/sysdeps/unix/sysv/linux/pwritev64.c
index 9bb0399c44..1fd9b66c4a 100644
--- a/sysdeps/unix/sysv/linux/pwritev64.c
+++ b/sysdeps/unix/sysv/linux/pwritev64.c
@@ -18,6 +18,8 @@
 #include <sys/uio.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+
 #ifdef __ASSUME_PWRITEV
 
 # ifndef __NR_pwritev64
@@ -27,7 +29,11 @@
 ssize_t
 pwritev64 (int fd, const struct iovec *vector, int count, off64_t offset)
 {
+# if !IS_IN(rtld) && defined SHARED
+  return pcn_pwritev64 (fd, vector, count, offset);
+# else
   return SYSCALL_CANCEL (pwritev64, fd, vector, count, LO_HI_LONG (offset));
+# endif
 }
 #else
 static ssize_t __atomic_pwritev64_replacement (int, const struct iovec *,
diff --git a/sysdeps/unix/sysv/linux/read.c b/sysdeps/unix/sysv/linux/read.c
index 64f558a587..f6fc16f693 100644
--- a/sysdeps/unix/sysv/linux/read.c
+++ b/sysdeps/unix/sysv/linux/read.c
@@ -18,12 +18,13 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
 
 /* Read NBYTES into BUF from FD.  Return the number read or -1.  */
 ssize_t
 __libc_read (int fd, void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (read, fd, buf, nbytes);
+  return pcn_read (fd, buf, nbytes);
 }
 libc_hidden_def (__libc_read)
 
diff --git a/sysdeps/unix/sysv/linux/read_nocancel.c b/sysdeps/unix/sysv/linux/read_nocancel.c
index f9d8a3b563..b7839cc224 100644
--- a/sysdeps/unix/sysv/linux/read_nocancel.c
+++ b/sysdeps/unix/sysv/linux/read_nocancel.c
@@ -19,10 +19,15 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <remote_io/remote_io.h>
 
 ssize_t
 __read_nocancel (int fd, void *buf, size_t nbytes)
 {
+#if IS_IN(libc) && defined SHARED
+  return pcn_read (fd, buf, nbytes);
+#else
   return INLINE_SYSCALL_CALL (read, fd, buf, nbytes);
+#endif
 }
 hidden_def (__read_nocancel)
diff --git a/sysdeps/unix/sysv/linux/readlink.c b/sysdeps/unix/sysv/linux/readlink.c
new file mode 100644
index 0000000000..0859c78343
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/readlink.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <remote_io/remote_io.h>
+
+/* Read the contents of the symbolic link PATH into no more than
+   LEN bytes of BUF.  The contents are not null-terminated.
+   Returns the number of characters read, or -1 for errors.  */
+ssize_t
+__readlink (const char *path, char *buf, size_t len)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_readlink (path, buf, len);
+#else
+  return INLINE_SYSCALL (readlink, 3, path, buf, len);
+#endif
+}
+libc_hidden_def (__readlink)
+weak_alias (__readlink, readlink)
diff --git a/sysdeps/unix/sysv/linux/recv.c b/sysdeps/unix/sysv/linux/recv.c
index 79fb3c32d1..d378bf8163 100644
--- a/sysdeps/unix/sysv/linux/recv.c
+++ b/sysdeps/unix/sysv/linux/recv.c
@@ -19,9 +19,14 @@
 #include <sysdep-cancel.h>
 #include <socketcall.h>
 
+#include <remote_io/remote_io.h>
+
 ssize_t
 __libc_recv (int fd, void *buf, size_t len, int flags)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_recvfrom (fd, buf, len, flags, NULL, NULL);
+#else
 #ifdef __ASSUME_RECV_SYSCALL
   return SYSCALL_CANCEL (recv, fd, buf, len, flags);
 #elif defined __ASSUME_RECVFROM_SYSCALL
@@ -29,6 +34,7 @@ __libc_recv (int fd, void *buf, size_t len, int flags)
 #else
   return SOCKETCALL_CANCEL (recv, fd, buf, len, flags);
 #endif
+#endif
 }
 weak_alias (__libc_recv, recv)
 weak_alias (__libc_recv, __recv)
diff --git a/sysdeps/unix/sysv/linux/recvfrom.c b/sysdeps/unix/sysv/linux/recvfrom.c
index 70532529c9..4c34d2daf7 100644
--- a/sysdeps/unix/sysv/linux/recvfrom.c
+++ b/sysdeps/unix/sysv/linux/recvfrom.c
@@ -19,10 +19,16 @@
 #include <sysdep-cancel.h>
 #include <socketcall.h>
 
+#include <remote_io/remote_io.h>
+
 ssize_t
 __libc_recvfrom (int fd, void *buf, size_t len, int flags,
 		 __SOCKADDR_ARG addr, socklen_t *addrlen)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_recvfrom (fd, buf, len, flags, addr.__sockaddr__,
+                       addrlen);
+#else
 #ifdef __ASSUME_RECVFROM_SYSCALL
   return SYSCALL_CANCEL (recvfrom, fd, buf, len, flags, addr.__sockaddr__,
                          addrlen);
@@ -30,6 +36,7 @@ __libc_recvfrom (int fd, void *buf, size_t len, int flags,
   return SOCKETCALL_CANCEL (recvfrom, fd, buf, len, flags, addr.__sockaddr__,
 			    addrlen);
 #endif
+#endif
 }
 weak_alias (__libc_recvfrom, recvfrom)
 weak_alias (__libc_recvfrom, __recvfrom)
diff --git a/sysdeps/unix/sysv/linux/recvmsg.c b/sysdeps/unix/sysv/linux/recvmsg.c
index a86d502922..e46d577d1e 100644
--- a/sysdeps/unix/sysv/linux/recvmsg.c
+++ b/sysdeps/unix/sysv/linux/recvmsg.c
@@ -21,14 +21,20 @@
 #include <socketcall.h>
 #include <shlib-compat.h>
 
+#include <remote_io/remote_io.h>
+
 ssize_t
 __libc_recvmsg (int fd, struct msghdr *msg, int flags)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_recvmsg (fd, msg, flags);
+#else
 # ifdef __ASSUME_RECVMSG_SYSCALL
   return SYSCALL_CANCEL (recvmsg, fd, msg, flags);
 # else
   return SOCKETCALL_CANCEL (recvmsg, fd, msg, flags);
 # endif
+#endif
 }
 weak_alias (__libc_recvmsg, recvmsg)
 weak_alias (__libc_recvmsg, __recvmsg)
diff --git a/sysdeps/unix/sysv/linux/rename.c b/sysdeps/unix/sysv/linux/rename.c
index bfd3ea63da..21f22289f2 100644
--- a/sysdeps/unix/sysv/linux/rename.c
+++ b/sysdeps/unix/sysv/linux/rename.c
@@ -21,10 +21,15 @@
 #include <sysdep.h>
 #include <errno.h>
 
+#include <remote_io/remote_io.h>
+
 /* Rename the file OLD to NEW.  */
 int
 rename (const char *old, const char *new)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_rename (old, new);
+#else
 #if defined (__NR_rename)
   return INLINE_SYSCALL_CALL (rename, old, new);
 #elif defined (__NR_renameat)
@@ -32,4 +37,5 @@ rename (const char *old, const char *new)
 #else
   return INLINE_SYSCALL_CALL (renameat2, AT_FDCWD, old, AT_FDCWD, new, 0);
 #endif
+#endif
 }
diff --git a/sysdeps/unix/sysv/linux/rmdir.c b/sysdeps/unix/sysv/linux/rmdir.c
new file mode 100644
index 0000000000..d375777076
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/rmdir.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <remote_io/remote_io.h>
+
+/* Remove the directory PATH.  */
+int
+__rmdir (const char *path)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_rmdir (path);
+#else
+  return INLINE_SYSCALL (rmdir, 1, path);
+#endif
+}
+libc_hidden_def (__rmdir)
+weak_alias (__rmdir, rmdir)
diff --git a/sysdeps/unix/sysv/linux/select.c b/sysdeps/unix/sysv/linux/select.c
index 54c50edba2..2b130e4d9d 100644
--- a/sysdeps/unix/sysv/linux/select.c
+++ b/sysdeps/unix/sysv/linux/select.c
@@ -22,6 +22,8 @@
 #include <errno.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+
 /* Check the first NFDS descriptors each in READFDS (if not NULL) for read
    readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
    (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
@@ -38,8 +40,12 @@ __select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
 	  struct timeval *timeout)
 {
 #ifdef __NR_select
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_select (nfds, readfds, writefds, exceptfds, timeout);
+#else
   return SYSCALL_CANCEL (select, nfds, readfds, writefds, exceptfds,
 			 timeout);
+#endif
 #else
   int result;
   struct timespec ts, *tsp = NULL;
@@ -50,8 +56,12 @@ __select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
       tsp = &ts;
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  result = pcn_pselect (nfds, readfds, writefds, exceptfds, tsp, NULL);
+#else
   result = SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds, tsp,
 			   NULL);
+#endif
 
   if (timeout)
     {
diff --git a/sysdeps/unix/sysv/linux/send.c b/sysdeps/unix/sysv/linux/send.c
index aed7d06585..3d88397ebc 100644
--- a/sysdeps/unix/sysv/linux/send.c
+++ b/sysdeps/unix/sysv/linux/send.c
@@ -19,9 +19,14 @@
 #include <sysdep-cancel.h>
 #include <socketcall.h>
 
+#include <remote_io/remote_io.h>
+
 ssize_t
 __libc_send (int fd, const void *buf, size_t len, int flags)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_send (fd, buf, len, flags);
+#else
 #ifdef __ASSUME_SEND_SYSCALL
   return SYSCALL_CANCEL (send, fd, buf, len, flags);
 #elif defined __ASSUME_SENDTO_SYSCALL
@@ -29,6 +34,7 @@ __libc_send (int fd, const void *buf, size_t len, int flags)
 #else
   return SOCKETCALL_CANCEL (send, fd, buf, len, flags);
 #endif
+#endif
 }
 weak_alias (__libc_send, send)
 weak_alias (__libc_send, __send)
diff --git a/sysdeps/unix/sysv/linux/sendto.c b/sysdeps/unix/sysv/linux/sendto.c
index 670d0679ea..de376b197c 100644
--- a/sysdeps/unix/sysv/linux/sendto.c
+++ b/sysdeps/unix/sysv/linux/sendto.c
@@ -19,10 +19,15 @@
 #include <sysdep-cancel.h>
 #include <socketcall.h>
 
+#include <remote_io/remote_io.h>
+
 ssize_t
 __libc_sendto (int fd, const void *buf, size_t len, int flags,
 	       __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_sendto (fd, buf, len, flags, addr.__sockaddr__, addrlen);
+#else
 #ifdef __ASSUME_SENDTO_SYSCALL
   return SYSCALL_CANCEL (sendto, fd, buf, len, flags, addr.__sockaddr__,
                          addrlen);
@@ -30,6 +35,7 @@ __libc_sendto (int fd, const void *buf, size_t len, int flags,
   return SOCKETCALL_CANCEL (sendto, fd, buf, len, flags, addr.__sockaddr__,
 			    addrlen);
 #endif
+#endif
 }
 weak_alias (__libc_sendto, sendto)
 weak_alias (__libc_sendto, __sendto)
diff --git a/sysdeps/unix/sysv/linux/setitimer.c b/sysdeps/unix/sysv/linux/setitimer.c
new file mode 100644
index 0000000000..2013547a26
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/setitimer.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sysdep-cancel.h>
+
+#include <remote_io/remote_io.h>
+
+/* Set the timer WHICH to *NEW.  If OLD is not NULL,
+   set *OLD to the old value of timer WHICH.
+   Returns 0 on success, -1 on errors.  */
+int
+__setitimer (enum __itimer_which which, const struct itimerval *new,
+	     struct itimerval *old)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_setitimer (which, new, old);
+#else
+  return SYSCALL_CANCEL (setitimer, which, new, old);
+#endif
+}
+
+weak_alias (__setitimer, setitimer)
diff --git a/sysdeps/unix/sysv/linux/setsockopt.c b/sysdeps/unix/sysv/linux/setsockopt.c
index 20c0868783..081a357246 100644
--- a/sysdeps/unix/sysv/linux/setsockopt.c
+++ b/sysdeps/unix/sysv/linux/setsockopt.c
@@ -22,14 +22,19 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 setsockopt (int fd, int level, int optname, const void *optval, socklen_t len)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_setsockopt (fd, level, optname, optval, len);
+#else
 #ifdef __ASSUME_SETSOCKOPT_SYSCALL
   return INLINE_SYSCALL (setsockopt, 5, fd, level, optname, optval, len);
 #else
   return SOCKETCALL (setsockopt, fd, level, optname, optval, len);
 #endif
+#endif
 }
 weak_alias (setsockopt, __setsockopt)
diff --git a/sysdeps/unix/sysv/linux/shm-directory.c b/sysdeps/unix/sysv/linux/shm-directory.c
index 43f044d77c..86e3201ff7 100644
--- a/sysdeps/unix/sysv/linux/shm-directory.c
+++ b/sysdeps/unix/sysv/linux/shm-directory.c
@@ -26,7 +26,8 @@
 #include <sys/statfs.h>
 #include <libc-lock.h>
 #include "linux_fsinfo.h"
-
+#include <elf/popcorn.h>
+#include <remote_io/server.h>
 
 /* Mount point of the shared memory filesystem.  */
 static struct
@@ -52,6 +53,14 @@ where_is_shmfs (void)
   struct mntent *mp;
   FILE *fp;
 
+  if (pcn_data->pcn_storage_shm)
+    {
+      mountpoint.dir = pcn_data->pcn_storage_shm;
+      mountpoint.dirlen = pcn_data->pcn_storage_shm_len;
+
+      return;
+    }
+
   /* The canonical place is /dev/shm.  This is at least what the
      documentation tells everybody to do.  */
   if (__statfs (defaultdir, &f) == 0 && (f.f_type == SHMFS_SUPER_MAGIC
@@ -120,8 +129,11 @@ where_is_shmfs (void)
 const char *
 __shm_directory (size_t *len)
 {
+  int t = rio_disable ();
+
   /* Determine where the shmfs is mounted.  */
   __libc_once (once, where_is_shmfs);
+  rio_restore (t);
 
   /* If we don't know the mount points there is nothing we can do.  Ever.  */
   if (__glibc_unlikely (mountpoint.dir == NULL))
diff --git a/sysdeps/unix/sysv/linux/sigaction.c b/sysdeps/unix/sysv/linux/sigaction.c
index 4e6d11a6ae..8975fb757c 100644
--- a/sysdeps/unix/sysv/linux/sigaction.c
+++ b/sysdeps/unix/sysv/linux/sigaction.c
@@ -26,6 +26,8 @@
    architecture requires for compat mode and/or due old ABI.  */
 #include <kernel_sigaction.h>
 
+#include <remote_io/remote_io.h>
+
 #ifndef SA_RESTORER
 # define SET_SA_RESTORER(kact, act)
 # define RESET_SA_RESTORER(act, kact)
@@ -55,9 +57,15 @@ __libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
 
   /* XXX The size argument hopefully will have to be changed to the
      real size of the user-level sigset_t.  */
+#if !IS_IN(rtld) && defined SHARED
+  result = pcn_sigaction (sig,
+			  act ? &kact : NULL,
+			  oact ? &koact : NULL, STUB (act, _NSIG / 8));
+#else
   result = INLINE_SYSCALL_CALL (rt_sigaction, sig,
 				act ? &kact : NULL,
 				oact ? &koact : NULL, STUB (act, _NSIG / 8));
+#endif
 
   if (oact && result >= 0)
     {
diff --git a/sysdeps/unix/sysv/linux/signalfd.c b/sysdeps/unix/sysv/linux/signalfd.c
index 64d7bccba9..2731a9ca4c 100644
--- a/sysdeps/unix/sysv/linux/signalfd.c
+++ b/sysdeps/unix/sysv/linux/signalfd.c
@@ -20,9 +20,14 @@
 #include <sys/signalfd.h>
 #include <sysdep.h>
 
+#include <remote_io/remote_io.h>
 
 int
 signalfd (int fd, const sigset_t *mask, int flags)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_signalfd (fd, mask, flags);
+#else
   return INLINE_SYSCALL (signalfd4, 4, fd, mask, _NSIG / 8, flags);
+#endif
 }
diff --git a/sysdeps/unix/sysv/linux/sigprocmask.c b/sysdeps/unix/sysv/linux/sigprocmask.c
index eb9e4d5e83..2e7262d124 100644
--- a/sysdeps/unix/sysv/linux/sigprocmask.c
+++ b/sysdeps/unix/sysv/linux/sigprocmask.c
@@ -18,6 +18,8 @@
 #include <signal.h>
 #include <nptl/pthreadP.h>              /* SIGCANCEL, SIGSETXID */
 
+#include <remote_io/remote_io.h>
+
 /* Get and/or change the set of blocked signals.  */
 int
 __sigprocmask (int how, const sigset_t *set, sigset_t *oset)
@@ -36,7 +38,11 @@ __sigprocmask (int how, const sigset_t *set, sigset_t *oset)
       set = &local_newmask;
     }
 
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_sigprocmask (how, set, oset);
+#else
   return INLINE_SYSCALL_CALL (rt_sigprocmask, how, set, oset, _NSIG / 8);
+#endif
 }
 libc_hidden_def (__sigprocmask)
 weak_alias (__sigprocmask, sigprocmask)
diff --git a/sysdeps/unix/sysv/linux/socket.c b/sysdeps/unix/sysv/linux/socket.c
index efa0e34467..75389e8066 100644
--- a/sysdeps/unix/sysv/linux/socket.c
+++ b/sysdeps/unix/sysv/linux/socket.c
@@ -22,15 +22,20 @@
 #include <socketcall.h>
 #include <kernel-features.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 int
 __socket (int fd, int type, int domain)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_socket (fd, type, domain);
+#else
 #ifdef __ASSUME_SOCKET_SYSCALL
   return INLINE_SYSCALL (socket, 3, fd, type, domain);
 #else
   return SOCKETCALL (socket, fd, type, domain);
 #endif
+#endif
 }
 libc_hidden_def (__socket)
 weak_alias (__socket, socket)
diff --git a/sysdeps/unix/sysv/linux/spawni.c b/sysdeps/unix/sysv/linux/spawni.c
index f157bfffd2..357c56e380 100644
--- a/sysdeps/unix/sysv/linux/spawni.c
+++ b/sysdeps/unix/sysv/linux/spawni.c
@@ -32,6 +32,8 @@
 #include <libc-pointer-arith.h>
 #include <ldsodefs.h>
 #include "spawn_int.h"
+#include <remote_io/remote_io.h>
+#include <elf/popcorn.h>
 
 /* The Linux implementation of posix_spawn{p} uses the clone syscall directly
    with CLONE_VM and CLONE_VFORK flags and an allocated stack.  The new stack
@@ -426,8 +428,18 @@ __spawni (pid_t * pid, const char *file,
 	  const posix_spawnattr_t * attrp, char *const argv[],
 	  char *const envp[], int xflags)
 {
+  int res, rio_server_port = -1;
+
+  if (pcn_data->pcn_remote_io_active)
+    rio_server_port = pcn_server_fork ();
+
   /* It uses __execvpex to avoid run ENOEXEC in non compatibility mode (it
      will be handled by maybe_script_execute).  */
-  return __spawnix (pid, file, acts, attrp, argv, envp, xflags,
-		    xflags & SPAWN_XFLAGS_USE_PATH ? __execvpex :__execve);
+  res = __spawnix (pid, file, acts, attrp, argv, envp, xflags,
+		   xflags & SPAWN_XFLAGS_USE_PATH ? __execvpex :__execve);
+
+  if (res == 0 && pcn_data->pcn_remote_io_active)
+    pcn_server_attach (rio_server_port);
+
+  return 0;
 }
diff --git a/sysdeps/unix/sysv/linux/symlink.c b/sysdeps/unix/sysv/linux/symlink.c
new file mode 100644
index 0000000000..36308b2076
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/symlink.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <remote_io/remote_io.h>
+
+/* Make a link to FROM called TO.  */
+int
+__symlink (const char *from, const char *to)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_symlink (from, to);
+#else
+  return INLINE_SYSCALL (symlink, 2, from, to);
+#endif
+}
+libc_hidden_def (__symlink)
+weak_alias (__symlink, symlink)
diff --git a/sysdeps/unix/sysv/linux/sync_file_range.c b/sysdeps/unix/sysv/linux/sync_file_range.c
index 18c43c54a8..1e568b711c 100644
--- a/sysdeps/unix/sysv/linux/sync_file_range.c
+++ b/sysdeps/unix/sysv/linux/sync_file_range.c
@@ -19,9 +19,14 @@
 #include <fcntl.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+
 int
 sync_file_range (int fd, __off64_t offset, __off64_t len, unsigned int flags)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_sync_file_range (fd, offset, len, flags);
+#else
 #if defined (__NR_sync_file_range2)
   return SYSCALL_CANCEL (sync_file_range2, fd, flags, SYSCALL_LL64 (offset),
 			 SYSCALL_LL64 (len));
@@ -30,4 +35,5 @@ sync_file_range (int fd, __off64_t offset, __off64_t len, unsigned int flags)
 			 __ALIGNMENT_ARG SYSCALL_LL64 (offset),
 			 SYSCALL_LL64 (len), flags);
 #endif
+#endif
 }
diff --git a/sysdeps/unix/sysv/linux/syscalls.list b/sysdeps/unix/sysv/linux/syscalls.list
index 52e6dafc86..6baa54e70a 100644
--- a/sysdeps/unix/sysv/linux/syscalls.list
+++ b/sysdeps/unix/sysv/linux/syscalls.list
@@ -7,11 +7,7 @@ capset		EXTRA	capset		i:pp	capset
 clock_adjtime	EXTRA	clock_adjtime	i:ip	__clock_adjtime		clock_adjtime
 create_module	EXTRA	create_module	3	__compat_create_module	create_module@GLIBC_2.0:GLIBC_2.23
 delete_module	EXTRA	delete_module	3	delete_module
-epoll_create	EXTRA	epoll_create	i:i	epoll_create
-epoll_create1	EXTRA	epoll_create1	i:i	epoll_create1
-epoll_ctl	EXTRA	epoll_ctl	i:iiip	epoll_ctl
 eventfd		EXTRA	eventfd2	i:ii	eventfd
-execve		-	execve		i:spp	__execve	execve
 flock		-	flock		i:ii	__flock		flock
 get_kernel_syms	EXTRA	get_kernel_syms	i:p	__compat_get_kernel_syms	get_kernel_syms@GLIBC_2.0:GLIBC_2.23
 getpid          -       getpid          Ei:     __getpid        getpid
diff --git a/sysdeps/unix/sysv/linux/truncate64.c b/sysdeps/unix/sysv/linux/truncate64.c
index d4b46574dc..bb9e49d488 100644
--- a/sysdeps/unix/sysv/linux/truncate64.c
+++ b/sysdeps/unix/sysv/linux/truncate64.c
@@ -19,6 +19,8 @@
 #include <sysdep.h>
 #include <errno.h>
 
+#include <remote_io/remote_io.h>
+
 #ifndef __NR_truncate64
 # define __NR_truncate64 __NR_truncate
 #endif
@@ -27,8 +29,12 @@
 int
 __truncate64 (const char *path, off64_t length)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_truncate64 (path, length);
+#else
   return INLINE_SYSCALL_CALL (truncate64, path,
 			      __ALIGNMENT_ARG SYSCALL_LL64 (length));
+#endif
 }
 weak_alias (__truncate64, truncate64)
 
diff --git a/sysdeps/unix/sysv/linux/tst-getcwd-smallbuff.c b/sysdeps/unix/sysv/linux/tst-getcwd-smallbuff.c
deleted file mode 100644
index 55362f6060..0000000000
--- a/sysdeps/unix/sysv/linux/tst-getcwd-smallbuff.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/* Verify that getcwd returns ERANGE for size 1 byte and does not underflow
-   buffer when the CWD is too long and is also a mount target of /.  See bug
-   #28769 or CVE-2021-3999 for more context.
-   Copyright The GNU Toolchain Authors.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <intprops.h>
-#include <limits.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/mount.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <support/check.h>
-#include <support/temp_file.h>
-#include <support/test-driver.h>
-#include <support/xsched.h>
-#include <support/xunistd.h>
-
-static char *base;
-#define BASENAME "tst-getcwd-smallbuff"
-#define MOUNT_NAME "mpoint"
-static int sockfd[2];
-
-static void
-do_cleanup (void)
-{
-  support_chdir_toolong_temp_directory (base);
-  TEST_VERIFY_EXIT (rmdir (MOUNT_NAME) == 0);
-  free (base);
-}
-
-static void
-send_fd (const int sock, const int fd)
-{
-  struct msghdr msg = {0};
-  union
-    {
-      struct cmsghdr hdr;
-      char buf[CMSG_SPACE (sizeof (int))];
-    } cmsgbuf = {0};
-  struct cmsghdr *cmsg;
-  struct iovec vec;
-  char ch = 'A';
-  ssize_t n;
-
-  msg.msg_control = &cmsgbuf.buf;
-  msg.msg_controllen = sizeof (cmsgbuf.buf);
-
-  cmsg = CMSG_FIRSTHDR (&msg);
-  cmsg->cmsg_len = CMSG_LEN (sizeof (int));
-  cmsg->cmsg_level = SOL_SOCKET;
-  cmsg->cmsg_type = SCM_RIGHTS;
-  memcpy (CMSG_DATA (cmsg), &fd, sizeof (fd));
-
-  vec.iov_base = &ch;
-  vec.iov_len = 1;
-  msg.msg_iov = &vec;
-  msg.msg_iovlen = 1;
-
-  while ((n = sendmsg (sock, &msg, 0)) == -1 && errno == EINTR);
-
-  TEST_VERIFY_EXIT (n == 1);
-}
-
-static int
-recv_fd (const int sock)
-{
-  struct msghdr msg = {0};
-  union
-    {
-      struct cmsghdr hdr;
-      char buf[CMSG_SPACE(sizeof(int))];
-    } cmsgbuf = {0};
-  struct cmsghdr *cmsg;
-  struct iovec vec;
-  ssize_t n;
-  char ch = '\0';
-  int fd = -1;
-
-  vec.iov_base = &ch;
-  vec.iov_len = 1;
-  msg.msg_iov = &vec;
-  msg.msg_iovlen = 1;
-
-  msg.msg_control = &cmsgbuf.buf;
-  msg.msg_controllen = sizeof (cmsgbuf.buf);
-
-  while ((n = recvmsg (sock, &msg, 0)) == -1 && errno == EINTR);
-  if (n != 1 || ch != 'A')
-    return -1;
-
-  cmsg = CMSG_FIRSTHDR (&msg);
-  if (cmsg == NULL)
-    return -1;
-  if (cmsg->cmsg_type != SCM_RIGHTS)
-    return -1;
-  memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));
-  if (fd < 0)
-    return -1;
-  return fd;
-}
-
-static int
-child_func (void * const arg)
-{
-  xclose (sockfd[0]);
-  const int sock = sockfd[1];
-  char ch;
-
-  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);
-  TEST_VERIFY_EXIT (ch == '1');
-
-  if (mount ("/", MOUNT_NAME, NULL, MS_BIND | MS_REC, NULL))
-    FAIL_EXIT1 ("mount failed: %m\n");
-  const int fd = xopen ("mpoint",
-			O_RDONLY | O_PATH | O_DIRECTORY | O_NOFOLLOW, 0);
-
-  send_fd (sock, fd);
-  xclose (fd);
-
-  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);
-  TEST_VERIFY_EXIT (ch == 'a');
-
-  xclose (sock);
-  return 0;
-}
-
-static void
-update_map (char * const mapping, const char * const map_file)
-{
-  const size_t map_len = strlen (mapping);
-
-  const int fd = xopen (map_file, O_WRONLY, 0);
-  xwrite (fd, mapping, map_len);
-  xclose (fd);
-}
-
-static void
-proc_setgroups_write (const long child_pid, const char * const str)
-{
-  const size_t str_len = strlen(str);
-
-  char setgroups_path[sizeof ("/proc//setgroups") + INT_STRLEN_BOUND (long)];
-
-  snprintf (setgroups_path, sizeof (setgroups_path),
-	    "/proc/%ld/setgroups", child_pid);
-
-  const int fd = open (setgroups_path, O_WRONLY);
-
-  if (fd < 0)
-    {
-      TEST_VERIFY_EXIT (errno == ENOENT);
-      FAIL_UNSUPPORTED ("/proc/%ld/setgroups not found\n", child_pid);
-    }
-
-  xwrite (fd, str, str_len);
-  xclose(fd);
-}
-
-static char child_stack[1024 * 1024];
-
-int
-do_test (void)
-{
-  base = support_create_and_chdir_toolong_temp_directory (BASENAME);
-
-  xmkdir (MOUNT_NAME, S_IRWXU);
-  atexit (do_cleanup);
-
-  /* Check whether user namespaces are supported.  */
-  {
-    pid_t pid = xfork ();
-    if (pid == 0)
-      {
-	if (unshare (CLONE_NEWUSER | CLONE_NEWNS) != 0)
-	  _exit (EXIT_UNSUPPORTED);
-	else
-	  _exit (0);
-      }
-    int status;
-    xwaitpid (pid, &status, 0);
-    TEST_VERIFY_EXIT (WIFEXITED (status));
-    if (WEXITSTATUS (status) != 0)
-      return WEXITSTATUS (status);
-  }
-
-  TEST_VERIFY_EXIT (socketpair (AF_UNIX, SOCK_STREAM, 0, sockfd) == 0);
-  pid_t child_pid = xclone (child_func, NULL, child_stack,
-			    sizeof (child_stack),
-			    CLONE_NEWUSER | CLONE_NEWNS | SIGCHLD);
-
-  xclose (sockfd[1]);
-  const int sock = sockfd[0];
-
-  char map_path[sizeof ("/proc//uid_map") + INT_STRLEN_BOUND (long)];
-  char map_buf[sizeof ("0  1") + INT_STRLEN_BOUND (long)];
-
-  snprintf (map_path, sizeof (map_path), "/proc/%ld/uid_map",
-	    (long) child_pid);
-  snprintf (map_buf, sizeof (map_buf), "0 %ld 1", (long) getuid());
-  update_map (map_buf, map_path);
-
-  proc_setgroups_write ((long) child_pid, "deny");
-  snprintf (map_path, sizeof (map_path), "/proc/%ld/gid_map",
-	    (long) child_pid);
-  snprintf (map_buf, sizeof (map_buf), "0 %ld 1", (long) getgid());
-  update_map (map_buf, map_path);
-
-  TEST_VERIFY_EXIT (send (sock, "1", 1, MSG_NOSIGNAL) == 1);
-  const int fd = recv_fd (sock);
-  TEST_VERIFY_EXIT (fd >= 0);
-  TEST_VERIFY_EXIT (fchdir (fd) == 0);
-
-  static char buf[2 * 10 + 1];
-  memset (buf, 'A', sizeof (buf));
-
-  /* Finally, call getcwd and check if it resulted in a buffer underflow.  */
-  char * cwd = getcwd (buf + sizeof (buf) / 2, 1);
-  TEST_VERIFY (cwd == NULL);
-  TEST_VERIFY (errno == ERANGE);
-
-  for (int i = 0; i < sizeof (buf); i++)
-    if (buf[i] != 'A')
-      {
-	printf ("buf[%d] = %02x\n", i, (unsigned int) buf[i]);
-	support_record_failure ();
-      }
-
-  TEST_VERIFY_EXIT (send (sock, "a", 1, MSG_NOSIGNAL) == 1);
-  xclose (sock);
-  TEST_VERIFY_EXIT (xwaitpid (child_pid, NULL, 0) == child_pid);
-
-  return 0;
-}
-
-#define CLEANUP_HANDLER do_cleanup
-#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/umask.c b/sysdeps/unix/sysv/linux/umask.c
new file mode 100644
index 0000000000..c9c08dfbe9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/umask.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+#include <remote_io/remote_io.h>
+
+/* Set the umask.  */
+__mode_t
+__umask (__mode_t __mask)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_umask (__mask);
+#else
+  return INLINE_SYSCALL (umask, 1, __mask);
+#endif
+}
+libc_hidden_def (__umask)
+weak_alias (__umask, umask)
diff --git a/support/xchdir.c b/sysdeps/unix/sysv/linux/uname.c
similarity index 65%
rename from support/xchdir.c
rename to sysdeps/unix/sysv/linux/uname.c
index beb4feff72..5d13c2e383 100644
--- a/support/xchdir.c
+++ b/sysdeps/unix/sysv/linux/uname.c
@@ -1,4 +1,4 @@
-/* chdir with error checking.
+/* uname - Linux specific syscall.
    Copyright (C) 2020 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -16,13 +16,27 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <support/check.h>
-#include <support/xunistd.h>
-#include <unistd.h>
+#include <sysdep.h>
+#include <stdarg.h>
+#include <sys/utsname.h>
 
-void
-xchdir (const char *path)
+#include <sys/syscall.h>
+#include <remote_io.h>
+
+int
+__uname (struct utsname *buf)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_uname (buf);
+#else
+  return INLINE_SYSCALL (uname, 1, buf);
+#endif
+}
+libc_hidden_def (__uname)
+
+int
+uname (struct utsname *buf)
 {
-  if (chdir (path) != 0)
-    FAIL_EXIT1 ("chdir (\"%s\"): %m", path);
+  return __uname (buf);
 }
+libc_hidden_def (uname)
diff --git a/sysdeps/unix/sysv/linux/unlink.c b/sysdeps/unix/sysv/linux/unlink.c
new file mode 100644
index 0000000000..d9e42e847a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/unlink.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <remote_io/remote_io.h>
+
+/* Remove the link named NAME.  */
+int
+__unlink (const char *name)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_unlink (name);
+#else
+  return INLINE_SYSCALL (unlink, 1, name);
+#endif
+}
+libc_hidden_def (__unlink)
+weak_alias (__unlink, unlink)
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/fstatfs.c b/sysdeps/unix/sysv/linux/wordsize-64/fstatfs.c
new file mode 100644
index 0000000000..56564c0180
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/wordsize-64/fstatfs.c
@@ -0,0 +1,37 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 1996-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <stddef.h>
+
+#include <remote_io/remote_io.h>
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs (int fd, struct statfs *buf)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_fstatfs (fd, buf);
+#else
+  return SYSCALL_CANCEL (fstatfs, fd, buf);
+#endif
+}
+libc_hidden_weak (__fstatfs)
+weak_alias (__fstatfs, fstatfs)
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c b/sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c
index 2be4e59ba4..1e6fe561ee 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c
@@ -1 +1,35 @@
-/* fstatfs64 is the same as fstatfs. */
+/* Copyright (C) 1998-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <stddef.h>
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs64 (int fd, struct statfs64 *buf)
+{
+#ifdef __NR_fstatfs64
+  int rc = INLINE_SYSCALL (fstatfs64, 3, fd, sizeof (*buf), buf);
+  return rc ?: statfs_overflow (buf);
+#else
+  return INLINE_SYSCALL (fstatfs, 2, fd, buf);
+#endif
+}
+weak_alias (__fstatfs64, fstatfs64)
+
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c b/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
index 24bfe847d7..c4cac5ed94 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
@@ -26,13 +26,19 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <fcntl.h>
+#include <remote_io.h>
 
 /* Get information about the file FD in BUF.  */
 int
 __fxstat (int vers, int fd, struct stat *buf)
 {
   if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
+#if IS_IN(libc) && defined SHARED
+    return pcn_fxstatat (_STAT_VER_LINUX, fd, "", buf, AT_EMPTY_PATH);
+#else
     return INLINE_SYSCALL (fstat, 2, fd, buf);
+#endif
 
   __set_errno (EINVAL);
   return -1;
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c b/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c
index b8f5ab562e..5fc6350c71 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/fxstatat.c
@@ -28,7 +28,8 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
-
+#include <remote_io/remote_io.h>
+#include <remote_io/server.h>
 
 /* Get information about the file NAME relative to FD in ST.  */
 int
@@ -40,7 +41,11 @@ __fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
       return -1;
     }
 
+#if IS_IN(libc) && defined SHARED
+  return pcn_fxstatat (vers, fd, file, st, flag);
+#else
   return INLINE_SYSCALL (newfstatat, 4, fd, file, st, flag);
+#endif
 }
 libc_hidden_def (__fxstatat)
 #undef __fxstatat64
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/lxstat.c b/sysdeps/unix/sysv/linux/wordsize-64/lxstat.c
index 156fbe7c64..9608b7a38b 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/lxstat.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/lxstat.c
@@ -23,19 +23,25 @@
 #include <errno.h>
 #include <stddef.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 /* Get information about the file FD in BUF.  */
 int
 __lxstat (int vers, const char *name, struct stat *buf)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_fxstatat (vers, AT_FDCWD, name, buf, AT_SYMLINK_NOFOLLOW);
+#else
   if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
     return INLINE_SYSCALL (lstat, 2, name, buf);
 
   __set_errno (EINVAL);
   return -1;
+#endif
 }
 
 hidden_def (__lxstat)
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/statfs.c b/sysdeps/unix/sysv/linux/wordsize-64/statfs.c
new file mode 100644
index 0000000000..c34e96dbae
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/wordsize-64/statfs.c
@@ -0,0 +1,37 @@
+/* statfs -- Return information about the filesystem on which FILE resides.
+   Copyright (C) 1996-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <stddef.h>
+
+#include <remote_io/remote_io.h>
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statfs (const char *file, struct statfs *buf)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_statfs (file, buf);
+#else
+  return SYSCALL_CANCEL (statfs, file, buf);
+#endif
+}
+libc_hidden_weak (__statfs)
+weak_alias (__statfs, statfs)
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/statfs64.c b/sysdeps/unix/sysv/linux/wordsize-64/statfs64.c
index 06bc68826f..1f748de036 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/statfs64.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/statfs64.c
@@ -1 +1,37 @@
-/* statfs64 is the same as statfs. */
+/* statfs64 -- Return information about the filesystem on which FILE resides.
+   Copyright (C) 1996-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <stddef.h>
+
+#include <remote_io/remote_io.h>
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statfs64 (const char *file, struct statfs64 *buf)
+{
+#ifdef __NR_statfs64
+  return SYSCALL_CANCEL (statfs64, file, buf);
+#else
+  return SYSCALL_CANCEL (statfs, file, buf);
+#endif
+}
+weak_alias (__statfs64, statfs64)
+
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/syscalls.list b/sysdeps/unix/sysv/linux/wordsize-64/syscalls.list
index 5de6ec823a..606a6e3c81 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/syscalls.list
+++ b/sysdeps/unix/sysv/linux/wordsize-64/syscalls.list
@@ -1,7 +1,4 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
-
-fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs fstatfs64 __fstatfs64
-statfs		-	statfs		i:sp	__statfs	statfs statfs64
 sendfile	-	sendfile	i:iipi	sendfile	sendfile64
 prlimit		EXTRA	prlimit64	i:iipp	prlimit		prlimit64
 
diff --git a/sysdeps/unix/sysv/linux/wordsize-64/xstat.c b/sysdeps/unix/sysv/linux/wordsize-64/xstat.c
index 438d54d291..39250b7fa6 100644
--- a/sysdeps/unix/sysv/linux/wordsize-64/xstat.c
+++ b/sysdeps/unix/sysv/linux/wordsize-64/xstat.c
@@ -23,19 +23,25 @@
 #include <errno.h>
 #include <stddef.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <remote_io/remote_io.h>
 
 /* Get information about the file NAME in BUF.  */
 int
 __xstat (int vers, const char *name, struct stat *buf)
 {
+#if IS_IN(libc) && defined SHARED
+  return pcn_fxstatat (vers, AT_FDCWD, name, buf, 0);
+#else
   if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
     return INLINE_SYSCALL (stat, 2, name, buf);
 
   __set_errno (EINVAL);
   return -1;
+#endif
 }
 hidden_def (__xstat)
 weak_alias (__xstat, _xstat);
diff --git a/sysdeps/unix/sysv/linux/write.c b/sysdeps/unix/sysv/linux/write.c
index 7848f7de27..7ddcddc0ac 100644
--- a/sysdeps/unix/sysv/linux/write.c
+++ b/sysdeps/unix/sysv/linux/write.c
@@ -18,12 +18,18 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <elf/popcorn.h>
+#include <remote_io/remote_io.h>
 
 /* Write NBYTES of BUF to FD.  Return the number written, or -1.  */
 ssize_t
 __libc_write (int fd, const void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (write, fd, buf, nbytes);
+
+  //rio_dbg_printf ("%s: fd = %d, bytes = %d\n", __FUNCTION__, fd, nbytes);
+
+  return pcn_write (fd, buf, nbytes);
+  //return SYSCALL_CANCEL (write, fd, buf, nbytes);
 }
 libc_hidden_def (__libc_write)
 
diff --git a/sysdeps/unix/sysv/linux/writev.c b/sysdeps/unix/sysv/linux/writev.c
index 8d628535f8..c9e2bb4493 100644
--- a/sysdeps/unix/sysv/linux/writev.c
+++ b/sysdeps/unix/sysv/linux/writev.c
@@ -20,10 +20,16 @@
 #include <sys/uio.h>
 #include <sysdep-cancel.h>
 
+#include <remote_io/remote_io.h>
+
 ssize_t
 __writev (int fd, const struct iovec *iov, int iovcnt)
 {
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_writev (fd, iov, iovcnt);
+#else
   return SYSCALL_CANCEL (writev, fd, iov, iovcnt);
+#endif
 }
 libc_hidden_def (__writev)
 weak_alias (__writev, writev)
diff --git a/sysdeps/unix/sysv/linux/x86/bits/epoll.h b/sysdeps/unix/sysv/linux/x86/bits/epoll.h
index 0b34b3d623..6107197674 100644
--- a/sysdeps/unix/sysv/linux/x86/bits/epoll.h
+++ b/sysdeps/unix/sysv/linux/x86/bits/epoll.h
@@ -26,4 +26,6 @@ enum
 #define EPOLL_CLOEXEC EPOLL_CLOEXEC
   };
 
+#ifndef __x86_64__
 #define __EPOLL_PACKED __attribute__ ((__packed__))
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86/bits/stat.h b/sysdeps/unix/sysv/linux/x86/bits/stat.h
index 25dec69dda..d367667246 100644
--- a/sysdeps/unix/sysv/linux/x86/bits/stat.h
+++ b/sysdeps/unix/sysv/linux/x86/bits/stat.h
@@ -41,9 +41,69 @@
 # define _MKNOD_VER_LINUX	0
 #endif
 
-#define _STAT_VER		_STAT_VER_LINUX
+#define _STAT_VER_PCN		4
+#define _STAT_VER		_STAT_VER_PCN
+
+/* Generic struct stat from linux/generic/bits/stat.h.  */
+
+#if defined __USE_FILE_OFFSET64
+# define __field64(type, type64, name) type64 name
+#elif __WORDSIZE == 64 || defined __INO_T_MATCHES_INO64_T
+# if defined __INO_T_MATCHES_INO64_T && !defined __OFF_T_MATCHES_OFF64_T
+#  error "ino_t and off_t must both be the same type"
+# endif
+# define __field64(type, type64, name) type name
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
+# define __field64(type, type64, name) \
+  type name __attribute__((__aligned__ (__alignof__ (type64)))); int __##name##_pad
+#else
+# define __field64(type, type64, name) \
+  int __##name##_pad __attribute__((__aligned__ (__alignof__ (type64)))); type name
+#endif
 
 struct stat
+  {
+    __dev_t st_dev;		/* Device.  */
+    __field64(__ino_t, __ino64_t, st_ino);  /* File serial number. */
+    __mode_t st_mode;		/* File mode.  */
+    unsigned int st_nlink;	/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __dev_t __pad1;
+    __field64(__off_t, __off64_t, st_size);  /* Size of file, in bytes. */
+    unsigned int st_blksize;	/* Optimal block size for I/O.  */
+    int __pad2;
+    __field64(__blkcnt_t, __blkcnt64_t, st_blocks);  /* 512-byte blocks */
+#ifdef __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+    int __glibc_reserved[2];
+  };
+
+#undef __field64
+
+
+/* Legacy struct stat for non-Popcorn applications.  */
+struct stat_legacy
   {
     __dev_t st_dev;		/* Device.  */
 #ifndef __x86_64__
@@ -115,8 +175,46 @@ struct stat
   };
 
 #ifdef __USE_LARGEFILE64
-/* Note stat64 has the same shape as stat for x86-64.  */
 struct stat64
+  {
+    __dev_t st_dev;		/* Device.  */
+    __ino64_t st_ino;		/* File serial number. */
+    __mode_t st_mode;		/* File mode.  */
+    unsigned int st_nlink;		/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __dev_t __pad1;
+    __off64_t st_size;		/* Size of file, in bytes. */
+    unsigned int st_blksize;	/* Optimal block size for I/O.  */
+    int __pad2;
+    __blkcnt64_t st_blocks;	/* 512-byte blocks */
+#ifdef __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+    int __glibc_reserved[2];
+  };
+
+/* Note stat64 has the same shape as stat for x86-64.  */
+struct stat64_legacy
   {
     __dev_t st_dev;		/* Device.  */
 # ifdef __x86_64__
diff --git a/sysdeps/unix/sysv/linux/x86/gettimeofday.c b/sysdeps/unix/sysv/linux/x86/gettimeofday.c
index 1b7aa880a2..361f09ff8a 100644
--- a/sysdeps/unix/sysv/linux/x86/gettimeofday.c
+++ b/sysdeps/unix/sysv/linux/x86/gettimeofday.c
@@ -16,5 +16,5 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define USE_IFUNC_GETTIMEOFDAY
+/* #define USE_IFUNC_GETTIMEOFDAY */
 #include <sysdeps/unix/sysv/linux/gettimeofday.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/64/jmp_buf-macros.h b/sysdeps/unix/sysv/linux/x86_64/64/jmp_buf-macros.h
index 3ae63ab5c5..608a7ad1f7 100644
--- a/sysdeps/unix/sysv/linux/x86_64/64/jmp_buf-macros.h
+++ b/sysdeps/unix/sysv/linux/x86_64/64/jmp_buf-macros.h
@@ -1,6 +1,6 @@
-#define JMP_BUF_SIZE 200
-#define SIGJMP_BUF_SIZE 200
+#define JMP_BUF_SIZE 312
+#define SIGJMP_BUF_SIZE 312
 #define JMP_BUF_ALIGN 8
 #define SIGJMP_BUF_ALIGN 8
-#define MASK_WAS_SAVED_OFFSET 64
-#define SAVED_MASK_OFFSET 72
+#define MASK_WAS_SAVED_OFFSET 176
+#define SAVED_MASK_OFFSET 184
diff --git a/sysdeps/unix/sysv/linux/x86_64/Versions b/sysdeps/unix/sysv/linux/x86_64/Versions
index 2a7ed280fd..a2cf993722 100644
--- a/sysdeps/unix/sysv/linux/x86_64/Versions
+++ b/sysdeps/unix/sysv/linux/x86_64/Versions
@@ -6,6 +6,10 @@ libc {
 
     modify_ldt;
   }
+  GLIBC_2.31.1 {
+    epoll_ctl;
+    epoll_wait;
+  }
 }
 
 librt {
@@ -13,5 +17,7 @@ librt {
     # Changed timer_t.
     timer_create; timer_delete; timer_getoverrun; timer_gettime;
     timer_settime;
+    __do_epoll_wait;
+    __do_epoll_pwait;
   }
 }
diff --git a/sysdeps/unix/sysv/linux/x86_64/do_fxstatat.c b/sysdeps/unix/sysv/linux/x86_64/do_fxstatat.c
new file mode 100644
index 0000000000..ac6c4ef0b1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/do_fxstatat.c
@@ -0,0 +1,79 @@
+/* Copyright (C) 2005-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Ho hum, if fxstatat == fxstatat64 we must get rid of the prototype or gcc
+   will complain since they don't strictly match.  */
+#define __fxstatat64 __fxstatat64_disable
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <remote_io/remote_io.h>
+#include <remote_io/server.h>
+
+#include <xstatconv.h>
+
+void
+x86_stat_xconv (struct stat *st, struct stat_legacy *sl)
+{
+  st->st_dev = sl->st_dev;
+  st->st_ino = sl->st_ino;
+  st->st_mode = sl->st_mode;
+  st->st_nlink = sl->st_nlink;
+  st->st_uid = sl->st_uid;
+  st->st_gid = sl->st_gid;
+  st->st_rdev = sl->st_rdev;
+  st->st_size = sl->st_size;
+  st->st_blksize = sl->st_blksize;
+  st->st_blocks = sl->st_blocks;
+  memcpy (&st->st_atim, &sl->st_atim, sizeof (struct timespec));
+  memcpy (&st->st_mtim, &sl->st_ctim, sizeof (struct timespec));
+  memcpy (&st->st_ctim, &sl->st_mtim, sizeof (struct timespec));
+}
+
+int
+__do_fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+  int result;
+  INTERNAL_SYSCALL_DECL (err);
+  struct stat_legacy kst;
+
+  if (vers == _STAT_VER_LINUX)
+    result = INTERNAL_SYSCALL (newfstatat, err, 4, fd, file, st, flag);
+  else
+    result = INTERNAL_SYSCALL (newfstatat, err, 4, fd, file, &kst, flag);
+
+  if (!__builtin_expect (INTERNAL_SYSCALL_ERROR_P (result, err), 1))
+    {
+      if (vers == _STAT_VER_PCN)
+	x86_stat_xconv (st, &kst);
+
+      return 0;
+    }
+  else
+    return INLINE_SYSCALL_ERROR_RETURN_VALUE (INTERNAL_SYSCALL_ERRNO (result,
+								      err));
+}
+libc_hidden_def (__do_fxstatat)
+
diff --git a/sysdeps/unix/sysv/linux/x86_64/epoll_ctl.c b/sysdeps/unix/sysv/linux/x86_64/epoll_ctl.c
new file mode 100644
index 0000000000..ed5e27cccd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/epoll_ctl.c
@@ -0,0 +1,89 @@
+/* Linux epoll_ctl implementation.
+   Copyright (C) 2017-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/epoll.h>
+#include <shlib-compat.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <remote_io/remote_io.h>
+
+#define PCN_EPOLL_OLD 0
+#define PCN_EPOLL_NEW 1
+
+struct linux_epoll_event
+{
+  uint32_t events;      /* Epoll events */
+  epoll_data_t data;    /* User data variable */
+} __attribute__ ((packed));
+
+int __new_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event);
+int __old_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event);
+
+libc_hidden_proto (__new_epoll_ctl)
+libc_hidden_proto (__old_epoll_ctl)
+
+int
+__do_epoll_ctl (int ver, int epfd, int op, int fd, struct epoll_event *event)
+{
+  int res;
+  struct linux_epoll_event lee;
+
+  if (ver == PCN_EPOLL_OLD || event == NULL)
+    return INLINE_SYSCALL (epoll_ctl, 4, epfd, op, fd, event);
+
+  lee.events = event->events;
+  lee.data.u64 = event->data.u64;
+
+  res = INLINE_SYSCALL (epoll_ctl, 4, epfd, op, fd, &lee);
+
+  return res;
+}
+
+int
+__new_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_ctl (PCN_EPOLL_NEW, epfd, op, fd, event);
+#else
+  return __do_epoll_ctl (PCN_EPOLL_NEW, epfd, op, fd, event);
+#endif
+}
+libc_hidden_def (__new_epoll_ctl)
+//libc_hidden_ver (__new_epoll_ctl, epoll_ctl)
+
+versioned_symbol (libc, __new_epoll_ctl, epoll_ctl, GLIBC_2_31_1);
+//strong_alias (__new_epoll_ctl, epoll_ctl)
+//default_symbol_version (__new_epoll_ctl, epoll_ctl, GLIBC_2_31_1);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_2, GLIBC_2_31_1)
+
+int
+attribute_compat_text_section
+__old_epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_ctl (PCN_EPOLL_OLD, epfd, op, fd, event);
+#else
+  return __do_epoll_ctl (PCN_EPOLL_OLD, epfd, op, fd, event);
+#endif
+}
+libc_hidden_def (__old_epoll_ctl)
+compat_symbol (libc, __old_epoll_ctl, epoll_ctl, GLIBC_2_3_2);
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/epoll_pwait.c b/sysdeps/unix/sysv/linux/x86_64/epoll_pwait.c
new file mode 100644
index 0000000000..a4003e7ad2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/epoll_pwait.c
@@ -0,0 +1,104 @@
+/* Linux epoll_pwait syscall implementation.
+   Copyright (C) 2017-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/epoll.h>
+
+#include <shlib-compat.h>
+#include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
+
+#define PCN_EPOLL_OLD 0
+#define PCN_EPOLL_NEW 1
+
+struct linux_epoll_event
+{
+  uint32_t events;      /* Epoll events */
+  epoll_data_t data;    /* User data variable */
+} __attribute__ ((packed));
+
+int __new_epoll_pwait (int epfd, struct epoll_event *events,
+		       int maxevents, int timeout, const sigset_t *set);
+int __old_epoll_pwait (int epfd, struct epoll_event *events,
+		       int maxevents, int timeout, const sigset_t *set);
+
+libc_hidden_proto (__new_epoll_pwait)
+libc_hidden_proto (__old_epoll_pwait)
+
+int
+__do_epoll_pwait (int ver, int epfd, struct epoll_event *events,
+		  int maxevents, int timeout, const sigset_t *set)
+{
+  /* Disable this, because the external remote_io isn't
+     multi-versioned.  */
+  if (0 && ver == PCN_EPOLL_OLD)
+    return SYSCALL_CANCEL (epoll_pwait, epfd, events, maxevents,
+			   timeout, set, _NSIG / 8);
+
+  int res, i;
+  struct linux_epoll_event lee[maxevents];
+
+  res = SYSCALL_CANCEL (epoll_pwait, epfd, lee, maxevents,
+			timeout, set, _NSIG / 8);
+
+  if (res <= 0)
+    return res;
+
+  for (i = 0; i < res; i++)
+    {
+      events[i].events = lee[i].events;
+      events[i].data.u64 = lee[i].data.u64;
+    }
+
+  return res;
+}
+
+int
+__new_epoll_pwait (int epfd, struct epoll_event *events, int maxevents,
+		   int timeout, const sigset_t *set)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_pwait (PCN_EPOLL_NEW, epfd, events, maxevents,
+			  timeout, set);
+#else
+  return __do_epoll_pwait (PCN_EPOLL_NEW, epfd, events, maxevents,
+			   timeout, set);
+#endif
+}
+libc_hidden_def (__new_epoll_pwait)
+versioned_symbol (libc, __new_epoll_pwait, epoll_pwait, GLIBC_2_31_1);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_2, GLIBC_2_31)
+int
+attribute_compat_text_section
+__old_epoll_pwait (int epfd, struct epoll_event *events, int maxevents,
+		   int timeout, const sigset_t *set)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_pwait (PCN_EPOLL_OLD, epfd, events, maxevents,
+			  timeout, set);
+#else
+  return __do_epoll_pwait (PCN_EPOLL_OLD, epfd, events, maxevents,
+			   timeout, set);
+#endif
+}
+libc_hidden_def (__old_epoll_pwait);
+compat_symbol (libc, __old_epoll_pwait, epoll_pwait, GLIBC_2_3_2);
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/epoll_wait.c b/sysdeps/unix/sysv/linux/x86_64/epoll_wait.c
new file mode 100644
index 0000000000..745158f1db
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/epoll_wait.c
@@ -0,0 +1,100 @@
+/* Linux epoll_wait syscall implementation.
+   Copyright (C) 2017-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/epoll.h>
+
+#include <shlib-compat.h>
+#include <sysdep-cancel.h>
+#include <remote_io/remote_io.h>
+
+#define PCN_EPOLL_OLD 0
+#define PCN_EPOLL_NEW 1
+
+struct linux_epoll_event
+{
+  uint32_t events;      /* Epoll events */
+  epoll_data_t data;    /* User data variable */
+} __attribute__ ((packed));
+
+int __new_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout);
+int __old_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout);
+
+libc_hidden_proto (__new_epoll_wait)
+libc_hidden_proto (__old_epoll_wait)
+
+int
+__do_epoll_wait (int ver, int epfd, struct epoll_event *events,
+		 int maxevents, int timeout)
+{
+  if (ver == PCN_EPOLL_OLD)
+#ifdef __NR_epoll_wait
+    return SYSCALL_CANCEL (epoll_wait, epfd, events, maxevents, timeout);
+#else
+    return epoll_pwait (epfd, events, maxevents, timeout, NULL);
+#endif
+
+  int res, i;
+  struct linux_epoll_event lee[maxevents];
+
+#ifdef __NR_epoll_wait
+  res = SYSCALL_CANCEL (epoll_wait, epfd, lee, maxevents, timeout);
+#else
+  res = epoll_pwait (epfd, lee, maxevents, timeout, NULL);
+#endif
+
+  if (res <= 0)
+    return res;
+
+  for (i = 0; i < res; i++)
+    {
+      events[i].events = lee[i].events;
+      events[i].data.u64 = lee[i].data.u64;
+    }
+
+  return res;
+}
+
+int
+__new_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_wait (PCN_EPOLL_NEW, epfd, events, maxevents, timeout);
+#else
+  return __do_epoll_wait (PCN_EPOLL_NEW, epfd, events, maxevents, timeout);
+#endif
+}
+libc_hidden_def (__new_epoll_wait)
+versioned_symbol (libc, __new_epoll_wait, epoll_wait, GLIBC_2_31_1);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_2, GLIBC_2_31)
+int
+attribute_compat_text_section
+__old_epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_epoll_wait (PCN_EPOLL_OLD, epfd, events, maxevents, timeout);
+#else
+  return __do_epoll_wait (PCN_EPOLL_OLD, epfd, events, maxevents, timeout);
+#endif
+}
+libc_hidden_def (__old_epoll_wait);
+compat_symbol (libc, __old_epoll_wait, epoll_wait, GLIBC_2_3_2);
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/fxstat.c b/sysdeps/unix/sysv/linux/x86_64/fxstat.c
new file mode 100644
index 0000000000..06085f8410
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/fxstat.c
@@ -0,0 +1,69 @@
+/* fxstat using old-style Unix fstat system call.
+   Copyright (C) 1991-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Ho hum, if xstat == xstat64 we must get rid of the prototype or gcc
+   will complain since they don't strictly match.  */
+#define __fxstat64 __fxstat64_disable
+
+#include <errno.h>
+#include <stddef.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <xstatconv.h>
+
+#include <remote_io/remote_io.h>
+
+extern void x86_stat_xconv (struct stat *st, struct stat_legacy *sl);
+
+/* Get information about the file FD in BUF.  */
+int
+__fxstat (int vers, int fd, struct stat *buf)
+{
+#if IS_IN(libc) && defined SHARED
+  return pcn_fxstatat (vers, fd, "", buf, AT_EMPTY_PATH);
+#else
+  struct stat_legacy sl;
+  int res;
+
+  if (vers == _STAT_VER_KERNEL)
+    return INLINE_SYSCALL (fstat, 2, fd, buf);
+
+  res = INLINE_SYSCALL (fstat, 2, fd, &sl);
+
+  if (res)
+    return res;
+
+  x86_stat_xconv (buf, &sl);
+
+  return 0;
+#endif
+}
+
+hidden_def (__fxstat)
+weak_alias (__fxstat, _fxstat);
+
+#undef __fxstat64
+strong_alias (__fxstat, __fxstat64);
+hidden_ver (__fxstat, __fxstat64)
+
diff --git a/sysdeps/unix/sysv/linux/x86_64/kernel-features.h b/sysdeps/unix/sysv/linux/x86_64/kernel-features.h
index 80ff5684a7..8185c060af 100644
--- a/sysdeps/unix/sysv/linux/x86_64/kernel-features.h
+++ b/sysdeps/unix/sysv/linux/x86_64/kernel-features.h
@@ -23,4 +23,14 @@
 # define __ASSUME_WORDSIZE64_ILP32	1
 #endif
 
+# define __ASSUME_SOCKET_SYSCALL             1
+# define __ASSUME_SOCKETPAIR_SYSCALL         1
+# define __ASSUME_BIND_SYSCALL               1
+# define __ASSUME_LISTEN_SYSCALL             1
+# define __ASSUME_GETSOCKOPT_SYSCALL         1
+# define __ASSUME_SETSOCKOPT_SYSCALL         1
+# define __ASSUME_GETSOCKNAME_SYSCALL        1
+# define __ASSUME_GETPEERNAME_SYSCALL        1
+# define __ASSUME_SHUTDOWN_SYSCALL           1
+
 #include_next <kernel-features.h>
diff --git a/sysdeps/unix/sysv/linux/x86_64/pipe.c b/sysdeps/unix/sysv/linux/x86_64/pipe.c
new file mode 100644
index 0000000000..005f58debc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/pipe.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <remote_io/remote_io.h>
+
+/* Create a one-way communication channel (__pipe).
+   If successful, two file descriptors are stored in PIPEDES;
+   bytes written on PIPEDES[1] can be read from PIPEDES[0].
+   Returns 0 if successful, -1 if not.  */
+int
+__pipe (int __pipedes[2])
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pipe (__pipedes, 0);
+#else
+  return INLINE_SYSCALL (pipe, 1, __pipedes);
+#endif
+}
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
diff --git a/sysdeps/unix/sysv/linux/x86_64/pipe2.c b/sysdeps/unix/sysv/linux/x86_64/pipe2.c
new file mode 100644
index 0000000000..b6ea98a6d3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/pipe2.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2011-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <remote_io/remote_io.h>
+
+/* Create a one-way communication channel (__pipe).
+   If successful, two file descriptors are stored in PIPEDES;
+   bytes written on PIPEDES[1] can be read from PIPEDES[0].
+   Returns 0 if successful, -1 if not.  */
+int
+__pipe2 (int __pipedes[2], int flags)
+{
+#if !IS_IN(rtld) && defined SHARED
+  return pcn_pipe (__pipedes, flags);
+#else
+  return INLINE_SYSCALL (pipe2, 2, __pipedes, flags);
+#endif
+}
+libc_hidden_def (__pipe2)
+weak_alias (__pipe2, pipe2)
diff --git a/sysdeps/unix/sysv/linux/x86_64/syscalls.list b/sysdeps/unix/sysv/linux/x86_64/syscalls.list
index d46524eff3..866acfb15c 100644
--- a/sysdeps/unix/sysv/linux/x86_64/syscalls.list
+++ b/sysdeps/unix/sysv/linux/x86_64/syscalls.list
@@ -6,12 +6,5 @@ syscall_clock_gettime	EXTRA	clock_gettime	Ei:ip		__syscall_clock_gettime
 
 
 # proper socket implementations:
-bind		-	bind		i:ipi	__bind		bind
-getpeername	-	getpeername	i:ipp	__getpeername	getpeername
-getsockname	-	getsockname	i:ipp	__getsockname	getsockname
-getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
-listen		-	listen		i:ii	__listen	listen
-setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
 shutdown	-	shutdown	i:ii	__shutdown	shutdown
-socket		-	socket		i:iii	__socket	socket
 socketpair	-	socketpair	i:iiif	__socketpair	socketpair
diff --git a/sysdeps/unix/sysv/linux/x86_64/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
index c7f740a1df..015cc95b4b 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
@@ -420,9 +420,10 @@
 
 #endif	/* __ASSEMBLER__ */
 
-
 /* Pointer mangling support.  */
-#if IS_IN (rtld)
+#if (IS_IN (rtld) \
+     || (!defined SHARED && (IS_IN (libc) \
+			     || IS_IN (libpthread))))
 /* We cannot use the thread descriptor because in ld.so we use setjmp
    earlier than the descriptor is initialized.  */
 # ifdef __ASSEMBLER__
@@ -431,32 +432,34 @@
 #  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			     \
 				xor __pointer_chk_guard_local(%rip), reg
 # else
-#  define PTR_MANGLE(reg)	asm ("xor __pointer_chk_guard_local(%%rip), %0\n" \
-				     "rol $2*" LP_SIZE "+1, %0"			  \
-				     : "=r" (reg) : "0" (reg))
-#  define PTR_DEMANGLE(reg)	asm ("ror $2*" LP_SIZE "+1, %0\n"		  \
-				     "xor __pointer_chk_guard_local(%%rip), %0"   \
-				     : "=r" (reg) : "0" (reg))
+extern uintptr_t __pointer_chk_guard_local attribute_relro attribute_hidden;
+#  define PTR_MANGLE(reg)						     \
+	asm ("xor __pointer_chk_guard_local(%%rip), %0\n"		     \
+	     "rol $2*" LP_SIZE "+1, %0"					     \
+	     : "=r" (reg) : "0" (reg))
+#  define PTR_DEMANGLE(reg)	\
+	asm ("ror $2*" LP_SIZE "+1, %0\n"				     \
+	     "xor __pointer_chk_guard_local(%%rip), %0"			     \
+	     : "=r" (reg) : "0" (reg))
 # endif
 #else
 # ifdef __ASSEMBLER__
-#  define PTR_MANGLE(reg)	xor %fs:POINTER_GUARD, reg;		      \
+#  define PTR_MANGLE(reg)	xor __pointer_chk_guard@GOTPCREL(%rip), reg; \
 				rol $2*LP_SIZE+1, reg
-#  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			      \
-				xor %fs:POINTER_GUARD, reg
+#  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			     \
+				xor __pointer_chk_guard@GOTPCREL(%rip), reg
 # else
-#  define PTR_MANGLE(var)	asm ("xor %%fs:%c2, %0\n"		      \
-				     "rol $2*" LP_SIZE "+1, %0"		      \
-				     : "=r" (var)			      \
-				     : "0" (var),			      \
-				       "i" (offsetof (tcbhead_t,	      \
-						      pointer_guard)))
-#  define PTR_DEMANGLE(var)	asm ("ror $2*" LP_SIZE "+1, %0\n"	      \
-				     "xor %%fs:%c2, %0"			      \
-				     : "=r" (var)			      \
-				     : "0" (var),			      \
-				       "i" (offsetof (tcbhead_t,	      \
-						      pointer_guard)))
+//extern uintptr_t __pointer_chk_guard attribute_relro;
+#  define PTR_MANGLE(var)						     \
+	asm ("xor __pointer_chk_guard@GOTPCREL(%%rip), %0\n"		     \
+	     "rol $2*" LP_SIZE "+1, %0"					     \
+	     : "=r" (var)						     \
+	     : "0" (var))
+#  define PTR_DEMANGLE(var)						     \
+	asm ("ror $2*" LP_SIZE "+1, %0\n"				     \
+	     "xor __pointer_chk_guard@GOTPCREL(%%rip), %0"		     \
+	     : "=r" (var)						     \
+	     : "0" (var))
 # endif
 #endif
 
diff --git a/sysdeps/x86/atomic-machine.h b/sysdeps/x86/atomic-machine.h
index bb49648374..c2b4bb361e 100644
--- a/sysdeps/x86/atomic-machine.h
+++ b/sysdeps/x86/atomic-machine.h
@@ -88,7 +88,7 @@ typedef uintmax_t uatomic_max_t;
 		       "0:\tcmpxchgb %b2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
 		       : BR_CONSTRAINT (newval), "m" (*mem), "0" (oldval),    \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
+			 "i" (offsetof (struct pthread, header.multiple_threads)));	      \
      ret; })
 
 #define __arch_c_compare_and_exchange_val_16_acq(mem, newval, oldval) \
@@ -99,7 +99,7 @@ typedef uintmax_t uatomic_max_t;
 		       "0:\tcmpxchgw %w2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
 		       : BR_CONSTRAINT (newval), "m" (*mem), "0" (oldval),    \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
+			 "i" (offsetof (struct pthread, header.multiple_threads)));	      \
      ret; })
 
 #define __arch_c_compare_and_exchange_val_32_acq(mem, newval, oldval) \
@@ -110,7 +110,7 @@ typedef uintmax_t uatomic_max_t;
 		       "0:\tcmpxchgl %2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
 		       : BR_CONSTRAINT (newval), "m" (*mem), "0" (oldval),    \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));       \
+			 "i" (offsetof (struct pthread, header.multiple_threads)));       \
      ret; })
 
 #ifdef __x86_64__
@@ -124,7 +124,7 @@ typedef uintmax_t uatomic_max_t;
 		       : "q" ((atomic64_t) cast_to_integer (newval)),	      \
 			 "m" (*mem),					      \
 			 "0" ((atomic64_t) cast_to_integer (oldval)),	      \
-			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
+		       "i" (offsetof (struct pthread, header.multiple_threads)));		\
      ret; })
 # define do_exchange_and_add_val_64_acq(pfx, mem, value) 0
 # define do_add_val_64_acq(pfx, mem, value) do { } while (0)
@@ -210,23 +210,23 @@ typedef uintmax_t uatomic_max_t;
        __asm __volatile (lock "xaddb %b0, %1"				      \
 			 : "=q" (__result), "=m" (*mem)			      \
 			 : "0" (__addval), "m" (*mem),			      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else if (sizeof (*mem) == 2)					      \
        __asm __volatile (lock "xaddw %w0, %1"				      \
 			 : "=r" (__result), "=m" (*mem)			      \
 			 : "0" (__addval), "m" (*mem),			      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else if (sizeof (*mem) == 4)					      \
        __asm __volatile (lock "xaddl %0, %1"				      \
 			 : "=r" (__result), "=m" (*mem)			      \
 			 : "0" (__addval), "m" (*mem),			      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else if (__HAVE_64B_ATOMICS)					      \
        __asm __volatile (lock "xaddq %q0, %1"				      \
 			 : "=r" (__result), "=m" (*mem)			      \
 			 : "0" ((atomic64_t) cast_to_integer (__addval)),     \
 			   "m" (*mem),					      \
-			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
+			   "i" (offsetof (struct pthread, header.multiple_threads)));     \
      else								      \
        __result = do_exchange_and_add_val_64_acq (pfx, (mem), __addval);      \
      __result; })
@@ -252,23 +252,23 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "addb %b1, %0"				      \
 			: "=m" (*mem)					      \
 			: IBR_CONSTRAINT (value), "m" (*mem),		      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "addw %w1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (value), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "addl %1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (value), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "addq %q1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" ((atomic64_t) cast_to_integer (value)),	      \
 			  "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       do_add_val_64_acq (apfx, (mem), (value));				      \
   } while (0)
@@ -337,22 +337,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "incb %b0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "incw %w0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "incl %0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "incq %q0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       do_add_val_64_acq (pfx, mem, 1);					      \
   } while (0)
@@ -395,22 +395,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "decb %b0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "decw %w0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "decl %0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "decq %q0"					      \
 			: "=m" (*mem)					      \
 			: "m" (*mem),					      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       do_add_val_64_acq (pfx, mem, -1);					      \
   } while (0)
@@ -501,22 +501,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "andb %b1, %0"				      \
 			: "=m" (*mem)					      \
 			: IBR_CONSTRAINT (mask), "m" (*mem),		      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "andw %w1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "andl %1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "andq %q1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       __atomic_link_error ();						      \
   } while (0)
@@ -535,22 +535,22 @@ typedef uintmax_t uatomic_max_t;
       __asm __volatile (lock "orb %b1, %0"				      \
 			: "=m" (*mem)					      \
 			: IBR_CONSTRAINT (mask), "m" (*mem),		      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 2)					      \
       __asm __volatile (lock "orw %w1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (sizeof (*mem) == 4)					      \
       __asm __volatile (lock "orl %1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else if (__HAVE_64B_ATOMICS)					      \
       __asm __volatile (lock "orq %q1, %0"				      \
 			: "=m" (*mem)					      \
 			: "ir" (mask), "m" (*mem),			      \
-			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
+			  "i" (offsetof (struct pthread, header.multiple_threads)));      \
     else								      \
       __atomic_link_error ();						      \
   } while (0)
diff --git a/sysdeps/x86/bits/select.h b/sysdeps/x86/bits/select.h
index b2e3ac800a..c06e3fa48f 100644
--- a/sysdeps/x86/bits/select.h
+++ b/sysdeps/x86/bits/select.h
@@ -21,8 +21,10 @@
 
 #include <bits/wordsize.h>
 
-
-#if defined __GNUC__ && __GNUC__ >= 2
+/* Disable this optmized version of __FD_ZERO to establish multi-ISA
+   compatible. Otherwise, the stack cannot be rewritten because both
+   macros use different type of local variable.  */
+#if defined __GNUC__ && __GNUC__ >= 2 && 0
 
 # if __WORDSIZE == 64
 #  define __FD_ZERO_STOS "stosq"
diff --git a/sysdeps/x86/bits/setjmp.h b/sysdeps/x86/bits/setjmp.h
index 9e9329dded..f1ecf79f18 100644
--- a/sysdeps/x86/bits/setjmp.h
+++ b/sysdeps/x86/bits/setjmp.h
@@ -28,9 +28,9 @@
 #ifndef _ASM
 
 # if __WORDSIZE == 64
-typedef long int __jmp_buf[8];
+typedef long int __jmp_buf[22];
 # elif defined  __x86_64__
-__extension__ typedef long long int __jmp_buf[8];
+__extension__ typedef long long int __jmp_buf[22];
 # else
 typedef int __jmp_buf[6];
 # endif
diff --git a/sysdeps/x86/nptl/bits/pthreadtypes-arch.h b/sysdeps/x86/nptl/bits/pthreadtypes-arch.h
index 399d4868a9..c5d91743d5 100644
--- a/sysdeps/x86/nptl/bits/pthreadtypes-arch.h
+++ b/sysdeps/x86/nptl/bits/pthreadtypes-arch.h
@@ -22,8 +22,8 @@
 
 #ifdef __x86_64__
 # if __WORDSIZE == 64
-#  define __SIZEOF_PTHREAD_MUTEX_T 40
-#  define __SIZEOF_PTHREAD_ATTR_T 56
+#  define __SIZEOF_PTHREAD_MUTEX_T 48
+#  define __SIZEOF_PTHREAD_ATTR_T 64
 #  define __SIZEOF_PTHREAD_RWLOCK_T 56
 #  define __SIZEOF_PTHREAD_BARRIER_T 32
 # else
@@ -38,11 +38,11 @@
 # define __SIZEOF_PTHREAD_RWLOCK_T 32
 # define __SIZEOF_PTHREAD_BARRIER_T 20
 #endif
-#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#define __SIZEOF_PTHREAD_MUTEXATTR_T 8
 #define __SIZEOF_PTHREAD_COND_T 48
-#define __SIZEOF_PTHREAD_CONDATTR_T 4
+#define __SIZEOF_PTHREAD_CONDATTR_T 8
 #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
-#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#define __SIZEOF_PTHREAD_BARRIERATTR_T 8
 
 #define __LOCK_ALIGNMENT
 #define __ONCE_ALIGNMENT
diff --git a/sysdeps/x86_64/dl-machine.h b/sysdeps/x86_64/dl-machine.h
index 74029871d8..0d9c9e28e0 100644
--- a/sysdeps/x86_64/dl-machine.h
+++ b/sysdeps/x86_64/dl-machine.h
@@ -44,6 +44,7 @@ elf_machine_dynamic (void)
 {
   /* This produces an IP-relative reloc which is resolved at link time. */
   extern const ElfW(Addr) _GLOBAL_OFFSET_TABLE_[] attribute_hidden;
+  //_dl_debug_printf ("_GLOBAL_OFFSET_TABLE = %lx\n", _GLOBAL_OFFSET_TABLE_ [0]);
   return _GLOBAL_OFFSET_TABLE_[0];
 }
 
@@ -56,6 +57,7 @@ elf_machine_load_address (void)
      by an IP-relative reference, and the link-time address found in the
      special unrelocated first GOT entry.  */
   extern ElfW(Dyn) _DYNAMIC[] attribute_hidden;
+  //_dl_debug_printf ("_DYNAMIC = %lx\n", &_DYNAMIC);
   return (ElfW(Addr)) &_DYNAMIC - elf_machine_dynamic ();
 }
 
@@ -145,6 +147,8 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 .globl _dl_start_user\n\
 _start:\n\
 	movq %rsp, %rdi\n\
+	# Save %rbp is case ld-linux is being reloaded.\n\
+	movq %rbp, %r15\n\
 	call _dl_start\n\
 _dl_start_user:\n\
 	# Save the user entry point address in %r12.\n\
@@ -181,6 +185,8 @@ _dl_start_user:\n\
 	leaq _dl_fini(%rip), %rdx\n\
 	# And make sure %rsp points to argc stored on the stack.\n\
 	movq %r13, %rsp\n\
+	# Restore %rbp\n\
+	movq %r15, %rbp\n\
 	# Jump to the user's entry point.\n\
 	jmp *%r12\n\
 .previous\n\
@@ -440,9 +446,14 @@ and creates an unsatisfiable circular dependency.\n",
 #  endif
 	      /* We know the offset of the object the symbol is contained in.
 		 It is a negative value which will be added to the
-		 thread pointer.  */
+		 thread pointer. It is a positive value to static TLS
+		 layout 3.  */
 	      value = (sym->st_value + reloc->r_addend
-		       - sym_map->l_tls_offset);
+		       + sym_map->l_tls_offset);
+
+//	      _dl_debug_printf ("%s: value = %lx, st_value = %lx, r_addend = %lx, l_tls_offset = %lx\n",
+//				__FUNCTION__, value, sym->st_value, reloc->r_addend,
+//				sym_map->l_tls_offset);
 #  ifdef __ILP32__
 	      /* The symbol and addend values are 32 bits but the GOT
 		 entry is 64 bits wide and the whole 64-bit entry is used
diff --git a/sysdeps/x86_64/multiarch/ifunc-avx2.h b/sysdeps/x86_64/multiarch/ifunc-avx2.h
index 925e5b61eb..74189b6aa5 100644
--- a/sysdeps/x86_64/multiarch/ifunc-avx2.h
+++ b/sysdeps/x86_64/multiarch/ifunc-avx2.h
@@ -30,11 +30,11 @@ IFUNC_SELECTOR (void)
   const struct cpu_features* cpu_features = __get_cpu_features ();
 
   if (CPU_FEATURES_ARCH_P (cpu_features, AVX2_Usable)
-      && CPU_FEATURES_CPU_P (cpu_features, BMI2)
       && CPU_FEATURES_ARCH_P (cpu_features, AVX_Fast_Unaligned_Load))
     {
       if (CPU_FEATURES_ARCH_P (cpu_features, AVX512VL_Usable)
-	  && CPU_FEATURES_ARCH_P (cpu_features, AVX512BW_Usable))
+	  && CPU_FEATURES_ARCH_P (cpu_features, AVX512BW_Usable)
+	  && CPU_FEATURES_CPU_P (cpu_features, BMI2))
 	return OPTIMIZE (evex);
 
       if (CPU_FEATURES_CPU_P (cpu_features, RTM))
diff --git a/sysdeps/x86_64/multiarch/ifunc-impl-list.c b/sysdeps/x86_64/multiarch/ifunc-impl-list.c
index e712b148f5..56b05ee741 100644
--- a/sysdeps/x86_64/multiarch/ifunc-impl-list.c
+++ b/sysdeps/x86_64/multiarch/ifunc-impl-list.c
@@ -41,12 +41,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/memchr.c.  */
   IFUNC_IMPL (i, name, memchr,
 	      IFUNC_IMPL_ADD (array, i, memchr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __memchr_avx2)
 	      IFUNC_IMPL_ADD (array, i, memchr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __memchr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, memchr,
@@ -168,18 +166,15 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/memrchr.c.  */
   IFUNC_IMPL (i, name, memrchr,
 	      IFUNC_IMPL_ADD (array, i, memrchr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __memrchr_avx2)
 	      IFUNC_IMPL_ADD (array, i, memrchr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __memrchr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, memrchr,
 			      (HAS_ARCH_FEATURE (AVX512VL_Usable)
-			       && HAS_ARCH_FEATURE (AVX512BW_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			       && HAS_ARCH_FEATURE (AVX512BW_Usable)),
 			      __memrchr_evex)
 
 	      IFUNC_IMPL_ADD (array, i, memrchr, 1, __memrchr_sse2))
@@ -274,12 +269,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/rawmemchr.c.  */
   IFUNC_IMPL (i, name, rawmemchr,
 	      IFUNC_IMPL_ADD (array, i, rawmemchr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __rawmemchr_avx2)
 	      IFUNC_IMPL_ADD (array, i, rawmemchr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __rawmemchr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, rawmemchr,
@@ -407,12 +400,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/strchr.c.  */
   IFUNC_IMPL (i, name, strchr,
 	      IFUNC_IMPL_ADD (array, i, strchr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __strchr_avx2)
 	      IFUNC_IMPL_ADD (array, i, strchr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __strchr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, strchr,
@@ -426,12 +417,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/strchrnul.c.  */
   IFUNC_IMPL (i, name, strchrnul,
 	      IFUNC_IMPL_ADD (array, i, strchrnul,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __strchrnul_avx2)
 	      IFUNC_IMPL_ADD (array, i, strchrnul,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __strchrnul_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, strchrnul,
@@ -444,18 +433,15 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/strrchr.c.  */
   IFUNC_IMPL (i, name, strrchr,
 	      IFUNC_IMPL_ADD (array, i, strrchr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __strrchr_avx2)
 	      IFUNC_IMPL_ADD (array, i, strrchr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __strrchr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, strrchr,
 			      (HAS_ARCH_FEATURE (AVX512VL_Usable)
-			       && HAS_ARCH_FEATURE (AVX512BW_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			       && HAS_ARCH_FEATURE (AVX512BW_Usable)),
 			      __strrchr_evex)
 	      IFUNC_IMPL_ADD (array, i, strrchr, 1, __strrchr_sse2))
 
@@ -588,12 +574,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/wcschr.c.  */
   IFUNC_IMPL (i, name, wcschr,
 	      IFUNC_IMPL_ADD (array, i, wcschr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __wcschr_avx2)
 	      IFUNC_IMPL_ADD (array, i, wcschr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __wcschr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, wcschr,
@@ -606,12 +590,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/wcsrchr.c.  */
   IFUNC_IMPL (i, name, wcsrchr,
 	      IFUNC_IMPL_ADD (array, i, wcsrchr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __wcsrchr_avx2)
 	      IFUNC_IMPL_ADD (array, i, wcsrchr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __wcsrchr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, wcsrchr,
@@ -624,12 +606,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/wcscmp.c.  */
   IFUNC_IMPL (i, name, wcscmp,
 	      IFUNC_IMPL_ADD (array, i, wcscmp,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __wcscmp_avx2)
 	      IFUNC_IMPL_ADD (array, i, wcscmp,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __wcscmp_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, wcscmp,
@@ -642,12 +622,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/wcsncmp.c.  */
   IFUNC_IMPL (i, name, wcsncmp,
 	      IFUNC_IMPL_ADD (array, i, wcsncmp,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __wcsncmp_avx2)
 	      IFUNC_IMPL_ADD (array, i, wcsncmp,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __wcsncmp_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, wcsncmp,
@@ -708,12 +686,10 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/x86_64/multiarch/wmemchr.c.  */
   IFUNC_IMPL (i, name, wmemchr,
 	      IFUNC_IMPL_ADD (array, i, wmemchr,
-			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)),
+			      HAS_ARCH_FEATURE (AVX2_Usable),
 			      __wmemchr_avx2)
 	      IFUNC_IMPL_ADD (array, i, wmemchr,
 			      (HAS_ARCH_FEATURE (AVX2_Usable)
-			       && HAS_CPU_FEATURE (BMI2)
 			       && HAS_CPU_FEATURE (RTM)),
 			      __wmemchr_avx2_rtm)
 	      IFUNC_IMPL_ADD (array, i, wmemchr,
diff --git a/sysdeps/x86_64/multiarch/strlen-avx2.S b/sysdeps/x86_64/multiarch/strlen-avx2.S
index 8cfb7391b0..45e08e64d6 100644
--- a/sysdeps/x86_64/multiarch/strlen-avx2.S
+++ b/sysdeps/x86_64/multiarch/strlen-avx2.S
@@ -542,11 +542,14 @@ L(return_vzeroupper):
 L(cross_page_less_vec):
 	tzcntl	%eax, %eax
 #  ifdef USE_AS_WCSLEN
-	/* NB: Divide by 4 to convert from byte-count to length.  */
-	shrl	$2, %eax
+	/* NB: Multiply length by 4 to get byte count.  */
+	sall	$2, %esi
 #  endif
 	cmpq	%rax, %rsi
 	cmovb	%esi, %eax
+#  ifdef USE_AS_WCSLEN
+	shrl	$2, %eax
+#  endif
 	VZEROUPPER_RETURN
 # endif
 
diff --git a/sysdeps/x86_64/nptl/tcb-offsets.sym b/sysdeps/x86_64/nptl/tcb-offsets.sym
index ae8034743b..144a381394 100644
--- a/sysdeps/x86_64/nptl/tcb-offsets.sym
+++ b/sysdeps/x86_64/nptl/tcb-offsets.sym
@@ -9,12 +9,13 @@ CLEANUP_JMP_BUF		offsetof (struct pthread, cleanup_jmp_buf)
 CLEANUP			offsetof (struct pthread, cleanup)
 CLEANUP_PREV		offsetof (struct _pthread_cleanup_buffer, __prev)
 MUTEX_FUTEX		offsetof (pthread_mutex_t, __data.__lock)
-MULTIPLE_THREADS_OFFSET	offsetof (tcbhead_t, multiple_threads)
-POINTER_GUARD		offsetof (tcbhead_t, pointer_guard)
-VGETCPU_CACHE_OFFSET	offsetof (tcbhead_t, vgetcpu_cache)
-FEATURE_1_OFFSET	offsetof (tcbhead_t, feature_1)
-SSP_BASE_OFFSET		offsetof (tcbhead_t, ssp_base)
+MULTIPLE_THREADS_OFFSET	offsetof (struct pthread, header.multiple_threads)
+POINTER_GUARD		offsetof (struct pthread, header.pointer_guard)
+VGETCPU_CACHE_OFFSET	offsetof (struct pthread, header.vgetcpu_cache)
+FEATURE_1_OFFSET	offsetof (struct pthread, header.feature_1)
+SSP_BASE_OFFSET		0x28
 
+-- SSP_BASE_OFFSET is derived from the native glibc build
 -- Not strictly offsets, but these values are also used in the TCB.
 TCB_CANCELSTATE_BITMASK	 CANCELSTATE_BITMASK
 TCB_CANCELTYPE_BITMASK	 CANCELTYPE_BITMASK
diff --git a/sysdeps/x86_64/nptl/tls.h b/sysdeps/x86_64/nptl/tls.h
index e7c1416eec..d9d7205047 100644
--- a/sysdeps/x86_64/nptl/tls.h
+++ b/sysdeps/x86_64/nptl/tls.h
@@ -29,67 +29,16 @@
 # include <libc-pointer-arith.h> /* For cast_to_integer.  */
 # include <kernel-features.h>
 # include <dl-dtv.h>
-
-/* Replacement type for __m128 since this file is included by ld.so,
-   which is compiled with -mno-sse.  It must not change the alignment
-   of rtld_savespace_sse.  */
-typedef struct
-{
-  int i[4];
-} __128bits;
-
-
-typedef struct
-{
-  void *tcb;		/* Pointer to the TCB.  Not necessarily the
-			   thread descriptor used by libpthread.  */
-  dtv_t *dtv;
-  void *self;		/* Pointer to the thread descriptor.  */
-  int multiple_threads;
-  int gscope_flag;
-  uintptr_t sysinfo;
-  uintptr_t stack_guard;
-  uintptr_t pointer_guard;
-  unsigned long int vgetcpu_cache[2];
-  /* Bit 0: X86_FEATURE_1_IBT.
-     Bit 1: X86_FEATURE_1_SHSTK.
-   */
-  unsigned int feature_1;
-  int __glibc_unused1;
-  /* Reservation of some values for the TM ABI.  */
-  void *__private_tm[4];
-  /* GCC split stack support.  */
-  void *__private_ss;
-  /* The lowest address of shadow stack,  */
-  unsigned long long int ssp_base;
-  /* Must be kept even if it is no longer used by glibc since programs,
-     like AddressSanitizer, depend on the size of tcbhead_t.  */
-  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));
-
-  void *__padding[8];
-} tcbhead_t;
-
-# ifdef __ILP32__
-/* morestack.S in libgcc uses offset 0x40 to access __private_ss,   */
-_Static_assert (offsetof (tcbhead_t, __private_ss) == 0x40,
-		"offset of __private_ss != 0x40");
-/* NB: ssp_base used to be "long int __glibc_reserved2", which was
-   changed from 32 bits to 64 bits.  Make sure that the offset of the
-   next field, __glibc_unused2, is unchanged.  */
-_Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x60,
-		"offset of __glibc_unused2 != 0x60");
-# else
-/* morestack.S in libgcc uses offset 0x70 to access __private_ss,   */
-_Static_assert (offsetof (tcbhead_t, __private_ss) == 0x70,
-		"offset of __private_ss != 0x70");
-_Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
-		"offset of __glibc_unused2 != 0x80");
-# endif
+# include <nptl/descr.h>
+# include <elf/dl-popcorn.h>
 
 #else /* __ASSEMBLER__ */
 # include <tcb-offsets.h>
 #endif
 
+#ifndef PCN_HETEROGENEOUS
+#define PCN_HETEROGENEOUS
+#endif
 
 /* Alignment requirement for the stack.  */
 #define STACK_ALIGN	16
@@ -107,43 +56,51 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # endif
 #endif
 
-/* This is the size of the initial TCB.  Can't be just sizeof (tcbhead_t),
-   because NPTL getpid, __libc_alloca_cutoff etc. need (almost) the whole
-   struct pthread even when not linked with -lpthread.  */
-# define TLS_INIT_TCB_SIZE sizeof (struct pthread)
+/* The TCB can have any size and the memory following the address the
+   thread pointer points to is unspecified.  Allocate the TCB there.  */
+# define TLS_TCB_AT_TP	0
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  void *private;
+  dtv_t *dtv;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
 
 /* Alignment requirements for the initial TCB.  */
-# define TLS_INIT_TCB_ALIGN __alignof__ (struct pthread)
+# define TLS_INIT_TCB_ALIGN	__alignof__ (struct pthread)
 
 /* This is the size of the TCB.  */
-# define TLS_TCB_SIZE sizeof (struct pthread)
+# define TLS_TCB_SIZE		sizeof (tcbhead_t)
 
-/* Alignment requirements for the TCB.  */
-# define TLS_TCB_ALIGN __alignof__ (struct pthread)
-
-/* The TCB can have any size and the memory following the address the
-   thread pointer points to is unspecified.  Allocate the TCB there.  */
-# define TLS_TCB_AT_TP	1
-# define TLS_DTV_AT_TP	0
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE	sizeof (struct pthread)
 
-/* Get the thread descriptor definition.  */
-# include <nptl/descr.h>
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
 
+/* Popcorn Linux Padding.  Necessary to maintain compatiblity shared
+   libraries that expect SSP_BASE_OFFSET to be inside tcbhead_t.  */
+# define TLS_TCB_PCN_PAD	0x40
 
 /* Install the dtv pointer.  The pointer passed is to the element with
    index -1 which contain the length.  */
-# define INSTALL_DTV(descr, dtvp) \
-  ((tcbhead_t *) (descr))->dtv = (dtvp) + 1
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
 
 /* Install new dtv for current thread.  */
-# define INSTALL_NEW_DTV(dtvp) \
-  ({ struct pthread *__pd;						      \
-     THREAD_SETMEM (__pd, header.dtv, (dtvp)); })
+# define INSTALL_NEW_DTV(dtv) \
+  ({tcbhead_t *tcb = GET_TP; tcb->dtv = dtv;})
 
 /* Return dtv of given thread descriptor.  */
-# define GET_DTV(descr) \
-  (((tcbhead_t *) (descr))->dtv)
-
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
 
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
@@ -152,13 +109,10 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
    We have to make the syscall for both uses of the macro since the
    address might be (and probably is) different.  */
 # define TLS_INIT_TP(thrdescr) \
-  ({ void *_thrdescr = (thrdescr);					      \
-     tcbhead_t *_head = _thrdescr;					      \
+  ({ tcbhead_t *_thrdescr = (thrdescr);					      \
      int _result;							      \
 									      \
-     _head->tcb = _thrdescr;						      \
-     /* For now the thread descriptor is at the same address.  */	      \
-     _head->self = _thrdescr;						      \
+     _thrdescr->private = (thrdescr);					      \
 									      \
      /* It is a simple syscall to set the %fs value for the thread.  */	      \
      asm volatile ("syscall"						      \
@@ -171,14 +125,14 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
     _result ? "cannot set %fs base address for thread-local storage" : 0;     \
   })
 
-# define TLS_DEFINE_INIT_TP(tp, pd) void *tp = (pd)
-
+/* Value passed to 'clone' for initialization of the thread register.  */
+# define TLS_DEFINE_INIT_TP(tp, pd) void *tp = (pd) + 1
 
 /* Return the address of the dtv for the current thread.  */
-# define THREAD_DTV() \
-  ({ struct pthread *__pd;						      \
-     THREAD_GETMEM (__pd, header.dtv); })
-
+# define THREAD_DTV()							     \
+  ({ dtv_t *__dtv;							     \
+     asm volatile ("mov %%fs:8, %0" : "=r" (__dtv));			     \
+     __dtv; })
 
 /* Return the thread descriptor for the current thread.
 
@@ -187,66 +141,40 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 	pthread_descr self = thread_self();
    do not get optimized away.  */
 # define THREAD_SELF \
-  ({ struct pthread *__self;						      \
-     asm ("mov %%fs:%c1,%0" : "=r" (__self)				      \
-	  : "i" (offsetof (struct pthread, header.self)));	 	      \
-     __self;})
+  ({ struct pthread *__self;						     \
+     asm volatile ("mov %%fs:0, %0": "=r" (__self));			     \
+     __self - 1; })
+
+# define GET_TP \
+  ({ void *tp;								      \
+     int _result;							      \
+									      \
+     /* It is a simple syscall to set the %fs value for the thread.  */	      \
+     asm volatile ("syscall"						      \
+		   : "=a" (_result)					      \
+		   : "0" ((unsigned long int) __NR_arch_prctl),		      \
+		     "D" ((unsigned long int) ARCH_GET_FS),		      \
+		     "S" (&tp)						      \
+		   : "memory", "cc", "r11", "cx");			      \
+									      \
+    _result ? "cannot set %fs base address for thread-local storage" : 0;     \
+    tp;									      \
+  })
+
 
 /* Magic for libthread_db to know how to do THREAD_SELF.  */
 # define DB_THREAD_SELF_INCLUDE  <sys/reg.h> /* For the FS constant.  */
 # define DB_THREAD_SELF CONST_THREAD_AREA (64, FS)
 
-/* Read member of the thread descriptor directly.  */
+/* Access to data in the thread descriptor is easy.  */
 # define THREAD_GETMEM(descr, member) \
-  ({ __typeof (descr->member) __value;					      \
-     if (sizeof (__value) == 1)						      \
-       asm volatile ("movb %%fs:%P2,%b0"				      \
-		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member)));     \
-     else if (sizeof (__value) == 4)					      \
-       asm volatile ("movl %%fs:%P1,%0"					      \
-		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member)));	      \
-     else								      \
-       {								      \
-	 if (sizeof (__value) != 8)					      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %%fs:%P1,%q0"				      \
-		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member)));	      \
-       }								      \
-     __value; })
-
-
-/* Same as THREAD_GETMEM, but the member offset can be non-constant.  */
+  descr->member
 # define THREAD_GETMEM_NC(descr, member, idx) \
-  ({ __typeof (descr->member[0]) __value;				      \
-     if (sizeof (__value) == 1)						      \
-       asm volatile ("movb %%fs:%P2(%q3),%b0"				      \
-		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member[0])),   \
-		       "r" (idx));					      \
-     else if (sizeof (__value) == 4)					      \
-       asm volatile ("movl %%fs:%P1(,%q2,4),%0"				      \
-		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member[0])), "r" (idx));\
-     else								      \
-       {								      \
-	 if (sizeof (__value) != 8)					      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %%fs:%P1(,%q2,8),%q0"			      \
-		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member[0])),	      \
-			 "r" (idx));					      \
-       }								      \
-     __value; })
-
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
 
 /* Loading addresses of objects on x86-64 needs to be treated special
    when generating PIC code.  */
@@ -256,56 +184,8 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # define IMM_MODE "ir"
 #endif
 
-
-/* Set member of the thread descriptor directly.  */
-# define THREAD_SETMEM(descr, member, value) \
-  ({ if (sizeof (descr->member) == 1)					      \
-       asm volatile ("movb %b0,%%fs:%P1" :				      \
-		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member)));	      \
-     else if (sizeof (descr->member) == 4)				      \
-       asm volatile ("movl %0,%%fs:%P1" :				      \
-		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member)));	      \
-     else								      \
-       {								      \
-	 if (sizeof (descr->member) != 8)				      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %q0,%%fs:%P1" :				      \
-		       : IMM_MODE ((uint64_t) cast_to_integer (value)),	      \
-			 "i" (offsetof (struct pthread, member)));	      \
-       }})
-
-
-/* Same as THREAD_SETMEM, but the member offset can be non-constant.  */
-# define THREAD_SETMEM_NC(descr, member, idx, value) \
-  ({ if (sizeof (descr->member[0]) == 1)				      \
-       asm volatile ("movb %b0,%%fs:%P1(%q2)" :				      \
-		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
-		       "r" (idx));					      \
-     else if (sizeof (descr->member[0]) == 4)				      \
-       asm volatile ("movl %0,%%fs:%P1(,%q2,4)" :			      \
-		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
-		       "r" (idx));					      \
-     else								      \
-       {								      \
-	 if (sizeof (descr->member[0]) != 8)				      \
-	   /* There should not be any value with a size other than 1,	      \
-	      4 or 8.  */						      \
-	   abort ();							      \
-									      \
-	 asm volatile ("movq %q0,%%fs:%P1(,%q2,8)" :			      \
-		       : IMM_MODE ((uint64_t) cast_to_integer (value)),	      \
-			 "i" (offsetof (struct pthread, member[0])),	      \
-			 "r" (idx));					      \
-       }})
-
-
+/* Disable STACK_GUARD and POINTER_GUARD for heterogeneous computing.  */
+#ifndef PCN_HETEROGENEOUS
 /* Set the stack guard field in TCB head.  */
 # define THREAD_SET_STACK_GUARD(value) \
     THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)
@@ -320,7 +200,7 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # define THREAD_COPY_POINTER_GUARD(descr) \
   ((descr)->header.pointer_guard					      \
    = THREAD_GETMEM (THREAD_SELF, header.pointer_guard))
-
+#endif
 
 /* Get and set the global scope generation counter in the TCB head.  */
 # define THREAD_GSCOPE_IN_TCB      1
@@ -329,13 +209,11 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # define THREAD_GSCOPE_FLAG_WAIT   2
 # define THREAD_GSCOPE_RESET_FLAG() \
   do									      \
-    { int __res;							      \
-      asm volatile ("xchgl %0, %%fs:%P1"				      \
-		    : "=r" (__res)					      \
-		    : "i" (offsetof (struct pthread, header.gscope_flag)),    \
-		      "0" (THREAD_GSCOPE_FLAG_UNUSED));			      \
-      if (__res == THREAD_GSCOPE_FLAG_WAIT)				      \
-	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);    \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
     }									      \
   while (0)
 # define THREAD_GSCOPE_SET_FLAG() \
